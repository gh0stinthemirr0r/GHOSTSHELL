import {
  __commonJS
} from "./chunk-34KZWS7D.js";

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@xterm/addon-ligatures/lib/addon-ligatures.js
var require_addon_ligatures = __commonJS({
  "node_modules/@xterm/addon-ligatures/lib/addon-ligatures.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t(require_fs(), require_path(), require_util(), require_stream()) : "function" == typeof define && define.amd ? define(["fs", "path", "util", "stream"], t) : "object" == typeof exports ? exports.LigaturesAddon = t(require_fs(), require_path(), require_util(), require_stream()) : e.LigaturesAddon = t(e.fs, e.path, e.util, e.stream);
    }(self, (e, t, n, s) => (() => {
      var o = { 185: (e2, t2) => {
        "use strict";
        function n2(e3) {
          const t3 = {};
          for (const [n3, o2] of Object.entries(e3.individual))
            t3[n3] = s2(o2);
          for (const { range: n3, entry: o2 } of e3.range) {
            const e4 = s2(o2);
            for (let s3 = n3[0]; s3 < n3[1]; s3++)
              t3[s3] = e4;
          }
          return t3;
        }
        function s2(e3) {
          const t3 = {};
          return e3.forward && (t3.forward = n2(e3.forward)), e3.reverse && (t3.reverse = n2(e3.reverse)), e3.lookup && (t3.lookup = e3.lookup), t3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = n2;
      }, 98: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        const s2 = n2(602), o2 = n2(593), r2 = n2(233), a2 = n2(694), i2 = n2(532), l = n2(595), u = n2(223), c = n2(439), p = n2(349), f = n2(185);
        class h {
          constructor(e3, t3) {
            this._lookupTrees = [], this._glyphLookups = {}, this._font = e3, t3.cacheSize > 0 && (this._cache = new o2({ max: t3.cacheSize, length: (e4, t4) => t4.length }));
            const n3 = (this._font.tables.gsub && this._font.tables.gsub.features.filter((e4) => "calt" === e4.tag) || []).reduce((e4, t4) => [...e4, ...t4.feature.lookupListIndexes], []), s3 = this._font.tables.gsub && this._font.tables.gsub.lookups || [], a3 = s3.filter((e4, t4) => n3.some((e5) => e5 === t4));
            for (const [e4, t4] of a3.entries()) {
              const n4 = [];
              switch (t4.lookupType) {
                case 6:
                  for (const [e5, o4] of t4.subtables.entries())
                    switch (o4.substFormat) {
                      case 1:
                        n4.push(l.default(o4, s3, e5));
                        break;
                      case 2:
                        n4.push(u.default(o4, s3, e5));
                        break;
                      case 3:
                        n4.push(c.default(o4, s3, e5));
                    }
                  break;
                case 8:
                  for (const [e5, s4] of t4.subtables.entries())
                    n4.push(p.default(s4, e5));
              }
              const o3 = f.default(r2.default(n4));
              this._lookupTrees.push({ tree: o3, processForward: 8 !== t4.lookupType });
              for (const t5 of Object.keys(o3))
                this._glyphLookups[t5] || (this._glyphLookups[t5] = []), this._glyphLookups[t5].push(e4);
            }
          }
          findLigatures(e3) {
            const t3 = this._cache && this._cache.get(e3);
            if (t3 && !Array.isArray(t3))
              return t3;
            const n3 = [];
            for (const t4 of e3)
              n3.push(this._font.charToGlyphIndex(t4));
            if (0 === this._lookupTrees.length)
              return { inputGlyphs: n3, outputGlyphs: n3, contextRanges: [] };
            const s3 = this._findInternal(n3.slice()), o3 = { inputGlyphs: n3, outputGlyphs: s3.sequence, contextRanges: s3.ranges };
            return this._cache && this._cache.set(e3, o3), o3;
          }
          findLigatureRanges(e3) {
            if (0 === this._lookupTrees.length)
              return [];
            const t3 = this._cache && this._cache.get(e3);
            if (t3)
              return Array.isArray(t3) ? t3 : t3.contextRanges;
            const n3 = [];
            for (const t4 of e3)
              n3.push(this._font.charToGlyphIndex(t4));
            const s3 = this._findInternal(n3);
            return this._cache && this._cache.set(e3, s3.ranges), s3.ranges;
          }
          _findInternal(e3) {
            const t3 = [];
            let n3 = this._getNextLookup(e3, 0);
            for (; null !== n3.index; ) {
              const s3 = this._lookupTrees[n3.index];
              if (s3.processForward) {
                let o3 = n3.last;
                for (let r3 = n3.first; r3 < o3; r3++) {
                  const n4 = a2.default(s3.tree, e3, r3, r3);
                  if (n4) {
                    for (let t4 = 0; t4 < n4.substitutions.length; t4++) {
                      const s4 = n4.substitutions[t4];
                      null !== s4 && (e3[r3 + t4] = s4);
                    }
                    i2.default(t3, n4.contextRange[0] + r3, n4.contextRange[1] + r3), r3 + n4.length >= o3 && (o3 = r3 + n4.length + 1), r3 += n4.length - 1;
                  }
                }
              } else
                for (let o3 = n3.last - 1; o3 >= n3.first; o3--) {
                  const n4 = a2.default(s3.tree, e3, o3, o3);
                  if (n4) {
                    for (let t4 = 0; t4 < n4.substitutions.length; t4++) {
                      const s4 = n4.substitutions[t4];
                      null !== s4 && (e3[o3 + t4] = s4);
                    }
                    i2.default(t3, n4.contextRange[0] + o3, n4.contextRange[1] + o3), o3 -= n4.length - 1;
                  }
                }
              n3 = this._getNextLookup(e3, n3.index + 1);
            }
            return { sequence: e3, ranges: t3 };
          }
          _getNextLookup(e3, t3) {
            const n3 = { index: null, first: 1 / 0, last: -1 };
            for (let s3 = 0; s3 < e3.length; s3++) {
              const o3 = this._glyphLookups[e3[s3]];
              if (o3)
                for (let e4 = 0; e4 < o3.length; e4++) {
                  const r3 = o3[e4];
                  if (r3 >= t3) {
                    (null === n3.index || r3 <= n3.index) && (n3.index = r3, n3.first > s3 && (n3.first = s3), n3.last = s3 + 1);
                    break;
                  }
                }
            }
            return n3;
          }
        }
        async function d(e3, t3) {
          const o3 = await Promise.resolve().then(() => n2(269)).then((t4) => t4.promisify(s2.load)(e3));
          return new h(o3, Object.assign({ cacheSize: 0 }, t3));
        }
        t2.load = async function(e3, t3) {
          const [s3] = await Promise.resolve().then(() => n2(781)).then((t4) => t4.listVariants(e3));
          if (!s3)
            throw new Error(`Font ${e3} not found`);
          return d(s3.path, t3);
        }, t2.loadFile = d, t2.loadBuffer = function(e3, t3) {
          const n3 = s2.parse(e3);
          return new h(n3, Object.assign({ cacheSize: 0 }, t3));
        };
      }, 233: (e2, t2) => {
        "use strict";
        function n2(e3, t3) {
          for (const [n3, o3] of Object.entries(t3.individual))
            if (e3.individual[n3])
              s2(e3.individual[n3], o3);
            else {
              let t4 = false;
              for (const [a3, { range: l2, entry: u }] of e3.range.entries()) {
                const c = r2(Number(n3), l2);
                if (null !== c.both) {
                  t4 = true, e3.individual[n3] = o3, s2(e3.individual[n3], i2(u)), e3.range.splice(a3, 1);
                  for (const t5 of c.second)
                    Array.isArray(t5) ? e3.range.push({ range: t5, entry: i2(u) }) : e3.individual[t5] = i2(u);
                }
              }
              t4 || (e3.individual[n3] = o3);
            }
          for (const { range: n3, entry: a3 } of t3.range) {
            let t4 = [n3];
            for (let n4 = 0; n4 < e3.range.length; n4++) {
              const { range: l2, entry: u } = e3.range[n4];
              for (const [c, p] of t4.entries()) {
                if (!Array.isArray(p)) {
                  const o3 = r2(p, l2);
                  if (null === o3.both)
                    continue;
                  e3.individual[p] = i2(a3), s2(e3.individual[p], i2(u)), e3.range.splice(n4, 1), n4--;
                  for (const t5 of o3.second)
                    Array.isArray(t5) ? e3.range.push({ range: t5, entry: i2(u) }) : e3.individual[t5] = i2(u);
                  t4.splice(c, 1, ...o3.first);
                  break;
                }
                {
                  const r3 = o2(p, l2);
                  if (null === r3.both)
                    continue;
                  e3.range.splice(n4, 1), n4--;
                  const c2 = i2(u);
                  Array.isArray(r3.both) ? e3.range.push({ range: r3.both, entry: c2 }) : e3.individual[r3.both] = c2, s2(c2, i2(a3));
                  for (const t5 of r3.second)
                    Array.isArray(t5) ? e3.range.push({ range: t5, entry: i2(u) }) : e3.individual[t5] = i2(u);
                  t4 = r3.first;
                }
              }
            }
            for (const n4 of Object.keys(e3.individual))
              for (const [o3, l2] of t4.entries()) {
                if (Array.isArray(l2)) {
                  const u = r2(Number(n4), l2);
                  if (null === u.both)
                    continue;
                  s2(e3.individual[n4], i2(a3)), t4.splice(o3, 1, ...u.second);
                  break;
                }
                if (Number(n4) === l2) {
                  s2(e3.individual[n4], i2(a3));
                  break;
                }
              }
            for (const n4 of t4)
              Array.isArray(n4) ? e3.range.push({ range: n4, entry: i2(a3) }) : e3.individual[n4] = i2(a3);
          }
        }
        function s2(e3, t3) {
          t3.lookup && (!e3.lookup || e3.lookup.index > t3.lookup.index || e3.lookup.index === t3.lookup.index && e3.lookup.subIndex > t3.lookup.subIndex) && (e3.lookup = t3.lookup), t3.forward && (e3.forward ? n2(e3.forward, t3.forward) : e3.forward = t3.forward), t3.reverse && (e3.reverse ? n2(e3.reverse, t3.reverse) : e3.reverse = t3.reverse);
        }
        function o2(e3, t3) {
          const n3 = { first: [], second: [], both: null };
          if (e3[0] < t3[1] && t3[0] < e3[1]) {
            const s3 = Math.max(e3[0], t3[0]), o3 = Math.min(e3[1], t3[1]);
            n3.both = a2(s3, o3);
          }
          if (e3[0] < t3[0]) {
            const s3 = e3[0], o3 = Math.min(t3[0], e3[1]);
            n3.first.push(a2(s3, o3));
          } else if (t3[0] < e3[0]) {
            const s3 = t3[0], o3 = Math.min(t3[1], e3[0]);
            n3.second.push(a2(s3, o3));
          }
          if (e3[1] > t3[1]) {
            const s3 = Math.max(e3[0], t3[1]), o3 = e3[1];
            n3.first.push(a2(s3, o3));
          } else if (t3[1] > e3[1]) {
            const s3 = Math.max(e3[1], t3[0]), o3 = t3[1];
            n3.second.push(a2(s3, o3));
          }
          return n3;
        }
        function r2(e3, t3) {
          if (e3 < t3[0] || e3 > t3[1])
            return { first: [e3], second: [t3], both: null };
          const n3 = { first: [], second: [], both: e3 };
          return t3[0] < e3 && n3.second.push(a2(t3[0], e3)), t3[1] > e3 && n3.second.push(a2(e3 + 1, t3[1])), n3;
        }
        function a2(e3, t3) {
          return t3 - e3 == 1 ? e3 : [e3, t3];
        }
        function i2(e3) {
          const t3 = {};
          return e3.forward && (t3.forward = l(e3.forward)), e3.reverse && (t3.reverse = l(e3.reverse)), e3.lookup && (t3.lookup = { contextRange: e3.lookup.contextRange.slice(), index: e3.lookup.index, length: e3.lookup.length, subIndex: e3.lookup.subIndex, substitutions: e3.lookup.substitutions.slice() }), t3;
        }
        function l(e3) {
          const t3 = {};
          for (const [n3, s3] of Object.entries(e3.individual))
            t3[n3] = i2(s3);
          return { individual: t3, range: e3.range.map(({ range: e4, entry: t4 }) => ({ range: e4.slice(), entry: i2(t4) })) };
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          const t3 = { individual: {}, range: [] };
          for (const s3 of e3)
            n2(t3, s3);
          return t3;
        };
      }, 532: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, n2) {
          let s2 = false;
          for (let o2 = 0; o2 < e3.length; o2++) {
            const r2 = e3[o2];
            if (s2) {
              if (n2 <= r2[0])
                return e3[o2 - 1][1] = n2, e3;
              if (n2 <= r2[1])
                return e3[o2 - 1][1] = Math.max(n2, r2[1]), e3.splice(o2, 1), s2 = false, e3;
              e3.splice(o2, 1), o2--;
            } else {
              if (n2 <= r2[0])
                return e3.splice(o2, 0, [t3, n2]), e3;
              if (n2 <= r2[1])
                return r2[0] = Math.min(t3, r2[0]), e3;
              if (!(t3 < r2[1]))
                continue;
              r2[0] = Math.min(t3, r2[0]), s2 = true;
            }
          }
          return s2 ? e3[e3.length - 1][1] = n2 : e3.push([t3, n2]), e3;
        };
      }, 595: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        const s2 = n2(283), o2 = n2(267);
        t2.default = function(e3, t3, n3) {
          const r2 = { individual: {}, range: [] }, a2 = s2.listGlyphsByIndex(e3.coverage);
          for (const { glyphId: s3, index: i2 } of a2) {
            const a3 = e3.chainRuleSets[i2];
            if (a3)
              for (const [e4, i3] of a3.entries()) {
                let a4 = o2.getInputTree(r2, i3.lookupRecords, t3, 0, s3).map(({ entry: e5, substitution: t4 }) => ({ entry: e5, substitutions: [t4] }));
                for (const [e5, n4] of i3.input.entries())
                  a4 = o2.processInputPosition([n4], e5 + 1, a4, i3.lookupRecords, t3);
                for (const e5 of i3.lookahead)
                  a4 = o2.processLookaheadPosition([e5], a4);
                for (const e5 of i3.backtrack)
                  a4 = o2.processBacktrackPosition([e5], a4);
                for (const { entry: t4, substitutions: s4 } of a4)
                  t4.lookup = { substitutions: s4, length: i3.input.length + 1, index: n3, subIndex: e4, contextRange: [-1 * i3.backtrack.length, 1 + i3.input.length + i3.lookahead.length] };
              }
          }
          return r2;
        };
      }, 223: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        const s2 = n2(233), o2 = n2(283), r2 = n2(91), a2 = n2(267);
        t2.default = function(e3, t3, n3) {
          const i2 = [], l = o2.listGlyphsByIndex(e3.coverage);
          for (const { glyphId: s3 } of l) {
            const o3 = r2.default(e3.inputClassDef, s3);
            for (const [s4, l2] of o3.entries()) {
              if (null === l2)
                continue;
              const o4 = e3.chainClassSet[l2];
              if (o4)
                for (const [l3, u] of o4.entries()) {
                  const o5 = { individual: {}, range: [] };
                  let c = a2.getInputTree(o5, u.lookupRecords, t3, 0, s4).map(({ entry: e4, substitution: t4 }) => ({ entry: e4, substitutions: [t4] }));
                  for (const [n4, s5] of u.input.entries())
                    c = a2.processInputPosition(r2.listClassGlyphs(e3.inputClassDef, s5), n4 + 1, c, u.lookupRecords, t3);
                  for (const t4 of u.lookahead)
                    c = a2.processLookaheadPosition(r2.listClassGlyphs(e3.lookaheadClassDef, t4), c);
                  for (const t4 of u.backtrack)
                    c = a2.processBacktrackPosition(r2.listClassGlyphs(e3.backtrackClassDef, t4), c);
                  for (const { entry: e4, substitutions: t4 } of c)
                    e4.lookup = { substitutions: t4, index: n3, subIndex: l3, length: u.input.length + 1, contextRange: [-1 * u.backtrack.length, 1 + u.input.length + u.lookahead.length] };
                  i2.push(o5);
                }
            }
          }
          return s2.default(i2);
        };
      }, 439: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        const s2 = n2(283), o2 = n2(267);
        t2.default = function(e3, t3, n3) {
          const r2 = { individual: {}, range: [] }, a2 = s2.listGlyphsByIndex(e3.inputCoverage[0]);
          for (const { glyphId: i2 } of a2) {
            let a3 = o2.getInputTree(r2, e3.lookupRecords, t3, 0, i2).map(({ entry: e4, substitution: t4 }) => ({ entry: e4, substitutions: [t4] }));
            for (const [n4, r3] of e3.inputCoverage.slice(1).entries())
              a3 = o2.processInputPosition(s2.listGlyphsByIndex(r3).map((e4) => e4.glyphId), n4 + 1, a3, e3.lookupRecords, t3);
            for (const t4 of e3.lookaheadCoverage)
              a3 = o2.processLookaheadPosition(s2.listGlyphsByIndex(t4).map((e4) => e4.glyphId), a3);
            for (const t4 of e3.backtrackCoverage)
              a3 = o2.processBacktrackPosition(s2.listGlyphsByIndex(t4).map((e4) => e4.glyphId), a3);
            for (const { entry: t4, substitutions: s3 } of a3)
              t4.lookup = { substitutions: s3, index: n3, subIndex: 0, length: e3.inputCoverage.length, contextRange: [-1 * e3.backtrackCoverage.length, e3.inputCoverage.length + e3.lookaheadCoverage.length] };
          }
          return r2;
        };
      }, 349: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        const s2 = n2(283), o2 = n2(267);
        t2.default = function(e3, t3) {
          const n3 = { individual: {}, range: [] }, r2 = s2.listGlyphsByIndex(e3.coverage);
          for (const { glyphId: a2, index: i2 } of r2) {
            const r3 = {};
            Array.isArray(a2) ? n3.range.push({ entry: r3, range: a2 }) : n3.individual[a2] = r3;
            let l = [{ entry: r3, substitutions: [e3.substitutes[i2]] }];
            for (const t4 of e3.lookaheadCoverage)
              l = o2.processLookaheadPosition(s2.listGlyphsByIndex(t4).map((e4) => e4.glyphId), l);
            for (const t4 of e3.backtrackCoverage)
              l = o2.processBacktrackPosition(s2.listGlyphsByIndex(t4).map((e4) => e4.glyphId), l);
            for (const { entry: n4, substitutions: s3 } of l)
              n4.lookup = { substitutions: s3, index: t3, subIndex: 0, length: 1, contextRange: [-1 * e3.backtrackCoverage.length, 1 + e3.lookaheadCoverage.length] };
          }
          return n3;
        };
      }, 91: (e2, t2) => {
        "use strict";
        function n2(e3, t3) {
          for (const n3 of e3.ranges)
            if (n3.start <= t3 && n3.end >= t3)
              return n3.classId;
          return null;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          return 2 === e3.format ? Array.isArray(t3) ? function(e4, t4) {
            let s2 = t4[0], o2 = n2(e4, s2), r2 = t4[0] + 1;
            const a2 = /* @__PURE__ */ new Map();
            for (; r2 < t4[1]; )
              n2(e4, r2) !== o2 && (r2 - s2 <= 1 ? a2.set(s2, o2) : a2.set([s2, r2], o2)), r2++;
            return r2 - s2 <= 1 ? a2.set(s2, o2) : a2.set([s2, r2], o2), a2;
          }(e3, t3) : /* @__PURE__ */ new Map([[t3, n2(e3, t3)]]) : /* @__PURE__ */ new Map([[t3, null]]);
        }, t2.listClassGlyphs = function(e3, t3) {
          if (2 === e3.format) {
            const n3 = [];
            for (const s2 of e3.ranges)
              s2.classId === t3 && (s2.end === s2.start ? n3.push(s2.start) : n3.push([s2.start, s2.end + 1]));
            return n3;
          }
          return [];
        };
      }, 283: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          switch (e3.format) {
            case 1:
              const n2 = e3.glyphs.indexOf(t3);
              return -1 !== n2 ? n2 : null;
            case 2:
              const s2 = e3.ranges.find((e4) => e4.start <= t3 && e4.end >= t3);
              return s2 ? s2.index : null;
          }
        }, t2.listGlyphsByIndex = function(e3) {
          switch (e3.format) {
            case 1:
              return e3.glyphs.map((e4, t4) => ({ glyphId: e4, index: t4 }));
            case 2:
              let t3 = [];
              for (const [n2, s2] of e3.ranges.entries())
                s2.end === s2.start ? t3.push({ glyphId: s2.start, index: n2 }) : t3.push({ glyphId: [s2.start, s2.end + 1], index: n2 });
              return t3;
          }
        };
      }, 267: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        const s2 = n2(603);
        function o2(e3, t3, n3, o3, a2) {
          const i2 = [];
          if (Array.isArray(a2)) {
            const r3 = function(e4, t4, n4, o4) {
              for (const r4 of e4.filter((e5) => e5.sequenceIndex === n4))
                for (const e5 of t4[r4.lookupListIndex].subtables) {
                  const t5 = s2.getRangeSubstitutionGlyphs(e5, o4);
                  if (!Array.from(t5.values()).every((e6) => null !== e6))
                    return t5;
                }
              return /* @__PURE__ */ new Map([[o4, null]]);
            }(t3, n3, o3, a2);
            for (const [t4, n4] of r3) {
              const s3 = {};
              Array.isArray(t4) ? e3.range.push({ range: t4, entry: s3 }) : e3.individual[t4] = {}, i2.push({ entry: s3, substitution: n4 });
            }
          } else
            e3.individual[a2] = {}, i2.push({ entry: e3.individual[a2], substitution: r2(t3, n3, o3, a2) });
          return i2;
        }
        function r2(e3, t3, n3, o3) {
          for (const r3 of e3.filter((e4) => e4.sequenceIndex === n3))
            for (const e4 of t3[r3.lookupListIndex].subtables) {
              const t4 = s2.getIndividualSubstitutionGlyph(e4, o3);
              if (null !== t4)
                return t4;
            }
          return null;
        }
        t2.processInputPosition = function(e3, t3, n3, s3, r3) {
          const a2 = [];
          for (const i2 of n3) {
            i2.entry.forward = { individual: {}, range: [] };
            for (const n4 of e3)
              a2.push(...o2(i2.entry.forward, s3, r3, t3, n4).map(({ entry: e4, substitution: t4 }) => ({ entry: e4, substitutions: [...i2.substitutions, t4] })));
          }
          return a2;
        }, t2.processLookaheadPosition = function(e3, t3) {
          const n3 = [];
          for (const s3 of t3)
            for (const t4 of e3) {
              const e4 = {};
              s3.entry.forward || (s3.entry.forward = { individual: {}, range: [] }), n3.push({ entry: e4, substitutions: s3.substitutions }), Array.isArray(t4) ? s3.entry.forward.range.push({ entry: e4, range: t4 }) : s3.entry.forward.individual[t4] = e4;
            }
          return n3;
        }, t2.processBacktrackPosition = function(e3, t3) {
          const n3 = [];
          for (const s3 of t3)
            for (const t4 of e3) {
              const e4 = {};
              s3.entry.reverse || (s3.entry.reverse = { individual: {}, range: [] }), n3.push({ entry: e4, substitutions: s3.substitutions }), Array.isArray(t4) ? s3.entry.reverse.range.push({ entry: e4, range: t4 }) : s3.entry.reverse.individual[t4] = e4;
            }
          return n3;
        }, t2.getInputTree = o2;
      }, 603: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        const s2 = n2(283);
        function o2(e3, t3) {
          const n3 = s2.default(e3.coverage, t3);
          if (null === n3)
            return null;
          switch (e3.substFormat) {
            case 1:
              return (t3 + e3.deltaGlyphId) % 65536;
            case 2:
              return null != e3.substitute[n3] ? e3.substitute[n3] : null;
          }
        }
        t2.getRangeSubstitutionGlyphs = function(e3, t3) {
          let n3 = t3[0], s3 = o2(e3, n3), r2 = t3[0] + 1;
          const a2 = /* @__PURE__ */ new Map();
          for (; r2 < t3[1]; )
            o2(e3, r2) !== s3 && (r2 - n3 <= 1 ? a2.set(n3, s3) : a2.set([n3, r2], s3)), r2++;
          return r2 - n3 <= 1 ? a2.set(n3, s3) : a2.set([n3, r2], s3), a2;
        }, t2.getIndividualSubstitutionGlyph = o2;
      }, 694: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3, n2, s2, o2) {
          let r2 = t3[n2[o2]];
          if (!r2)
            return;
          let a2 = r2.lookup;
          if (r2.reverse) {
            const e4 = function(e5, t4, n3) {
              let s3 = e5[t4[--n3]], o3 = s3 && s3.lookup;
              for (; s3 && ((!o3 && s3.lookup || s3.lookup && o3 && o3.index > s3.lookup.index) && (o3 = s3.lookup), !(--n3 < 0) && s3.reverse); )
                s3 = s3.reverse[t4[n3]];
              return o3;
            }(r2.reverse, n2, s2);
            (!a2 && e4 || e4 && a2 && (a2.index > e4.index || a2.index === e4.index && a2.subIndex > e4.subIndex)) && (a2 = e4);
          }
          if (++o2 >= n2.length || !r2.forward)
            return a2;
          const i2 = e3(r2.forward, n2, s2, o2);
          return (!a2 && i2 || i2 && a2 && (a2.index > i2.index || a2.index === i2.index && a2.subIndex > i2.subIndex)) && (a2 = i2), a2;
        };
      }, 814: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        const s2 = n2(82);
        var o2, r2;
        !function(e3) {
          e3.Serif = "serif", e3.SansSerif = "sansSerif", e3.Monospace = "monospace", e3.Cursive = "cursive", e3.Unknown = "unknown";
        }(o2 = t2.Type || (t2.Type = {})), function(e3) {
          e3.Regular = "regular", e3.Italic = "italic", e3.Oblique = "oblique", e3.Bold = "bold", e3.BoldItalic = "boldItalic", e3.BoldOblique = "boldOblique", e3.Other = "other";
        }(r2 = t2.Style || (t2.Style = {}));
        const a2 = [" Regular", " Bold", " Bold Italic", " Bold Oblique", " Italic", " Oblique"];
        function i2(e3) {
          if (!e3.os2 && !e3.head)
            return r2.Other;
          const t3 = e3.os2 ? 32 & e3.os2.fsSelection : 1 & e3.head.macStyle, n3 = e3.os2 ? 1 & e3.os2.fsSelection : e3.post ? e3.post.italicAngle < 0 : 2 & e3.head.macStyle, s3 = e3.os2 ? 512 & e3.os2.fsSelection : e3.post ? e3.post.italicAngle > 0 : 0, o3 = e3.os2 ? 320 & e3.os2.fsSelection : 1;
          return t3 ? s3 ? r2.BoldOblique : n3 ? r2.BoldItalic : r2.Bold : s3 ? r2.Oblique : n3 ? r2.Italic : o3 ? r2.Regular : r2.Other;
        }
        t2.name = function(e3, t3) {
          const n3 = e3.names.preferredFamily && e3.names.preferredFamily[t3] ? e3.names.preferredFamily[t3] : e3.names.fontFamily[t3];
          if ("win32" === s2.platform()) {
            const s3 = `${n3} ${e3.names.preferredSubfamily && e3.names.preferredSubfamily[t3] ? e3.names.preferredSubfamily[t3] : e3.names.fontSubfamily[t3]}`;
            let o3 = -1;
            for (const e4 of a2) {
              const t4 = s3.lastIndexOf(e4);
              if (-1 !== t4) {
                o3 = t4;
                break;
              }
            }
            return -1 !== o3 ? s3.substring(0, o3) : s3;
          }
          return n3;
        }, t2.type = function(e3) {
          if (e3.os2)
            switch (e3.os2.panose[0]) {
              case 2:
                return 9 === e3.os2.panose[3] ? o2.Monospace : e3.os2.panose[1] >= 11 && e3.os2.panose[1] <= 15 || 0 === e3.os2.panose[1] ? o2.SansSerif : o2.Serif;
              case 3:
                return o2.Cursive;
            }
          else if (e3.post && e3.post.isFixedPitch)
            return o2.Monospace;
          return o2.Unknown;
        }, t2.style = i2;
        const l = [r2.Bold, r2.BoldItalic, r2.BoldOblique];
        t2.weight = function(e3) {
          return e3.os2 ? e3.os2.usWeightClass : l.includes(i2(e3)) ? 700 : 400;
        };
      }, 781: function(e2, t2, n2) {
        "use strict";
        var s2 = this && this.__rest || function(e3, t3) {
          var n3 = {};
          for (var s3 in e3)
            Object.prototype.hasOwnProperty.call(e3, s3) && t3.indexOf(s3) < 0 && (n3[s3] = e3[s3]);
          if (null != e3 && "function" == typeof Object.getOwnPropertySymbols) {
            var o3 = 0;
            for (s3 = Object.getOwnPropertySymbols(e3); o3 < s3.length; o3++)
              t3.indexOf(s3[o3]) < 0 && (n3[s3[o3]] = e3[s3[o3]]);
          }
          return n3;
        };
        Object.defineProperty(t2, "__esModule", { value: true });
        const o2 = n2(459), r2 = n2(934), a2 = n2(814);
        var i2 = n2(814);
        async function l(e3) {
          const t3 = Object.assign({ concurrency: 4, language: "en" }, e3), n3 = await o2.default({ extensions: ["ttf", "otf"] }), a3 = await async function(e4, n4, s3) {
            const o3 = [];
            let a4 = 0;
            const i4 = async (e5) => {
              o3.push(await (async (e6) => {
                try {
                  return u(e6, await r2.default(e6), t3.language);
                } catch (e7) {
                  if (["TypeError", "SyntaxError", "ReferenceError", "RangeError", "AssertionError"].includes(e7.name))
                    throw e7;
                }
              })(n4[e5])), a4 < n4.length && await i4(a4++);
            }, l2 = [];
            for (; a4 < n4.length && a4 < s3; a4++)
              l2.push(i4(a4));
            return await Promise.all(l2), o3;
          }(0, n3, t3.concurrency), i3 = {};
          for (let e4 of a3.filter((e5) => e5)) {
            const { name: t4 } = e4, n4 = s2(e4, ["name"]);
            i3[t4] || (i3[t4] = []), i3[t4].push(n4);
          }
          return i3;
        }
        function u(e3, t3, n3) {
          return { name: a2.name(t3, n3), path: e3, type: a2.type(t3), weight: a2.weight(t3), style: a2.style(t3) };
        }
        t2.Type = i2.Type, t2.Style = i2.Style, t2.list = l, t2.listVariants = async function(e3, t3) {
          return (await l(t3))[e3] || [];
        }, t2.get = async function(e3, t3) {
          const n3 = Object.assign({ language: "en" }, t3);
          return u(e3, await r2.default(e3), n3.language);
        };
      }, 934: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        const s2 = n2(89), o2 = n2(896), r2 = n2(380), a2 = n2(879), i2 = n2(130), l = n2(731), u = n2(954);
        var c;
        !function(e3) {
          e3[e3.TrueType = 0] = "TrueType", e3[e3.CFF = 1] = "CFF", e3[e3.Woff = 2] = "Woff";
        }(c || (c = {}));
        const p = { name: { tag: Buffer.from("name"), parse: r2.default }, ltag: { tag: Buffer.from("ltag"), parse: a2.default }, os2: { tag: Buffer.from("OS/2"), parse: i2.default }, head: { tag: Buffer.from("head"), parse: l.default }, post: { tag: Buffer.from("post"), parse: u.default } };
        t2.default = async function(e3) {
          return new Promise((t3, n3) => {
            (async () => {
              const t4 = o2.default(), r3 = s2.createReadStream(e3);
              let a3 = false;
              const i3 = () => {
                a3 = true;
              };
              r3.once("close", i3), r3.once("end", i3), r3.once("error", (e4) => {
                a3 = true, n3(e4);
              }), r3.pipe(t4);
              try {
                switch (function(e4) {
                  if (e4.equals(f.one) || e4.equals(f.true) || e4.equals(f.typ1))
                    return c.TrueType;
                  if (e4.equals(f.otto))
                    return c.CFF;
                  if (e4.equals(f.woff))
                    return c.Woff;
                  throw new Error(`Unsupported signature type: ${e4}`);
                }(await t4.read(4))) {
                  case c.TrueType:
                  case c.CFF:
                    const n4 = (await t4.read(2)).readUInt16BE(0);
                    await t4.skip(6);
                    const s3 = await async function(e4, t5) {
                      const n5 = {};
                      for (let s4 = 0; s4 < t5; s4++) {
                        const t6 = await e4.read(4), s5 = await e4.read(12);
                        for (const [e5, o4] of Object.entries(p))
                          if (t6.equals(o4.tag) && (n5[e5] = { offset: s5.readUInt32BE(4), length: s5.readUInt32BE(8) }, n5.name && n5.ltag && n5.os2))
                            return n5;
                      }
                      return n5;
                    }(t4, n4), o3 = Object.entries(s3).sort((e4, t5) => e4[1].offset - t5[1].offset), r4 = {};
                    for (const [e4, n5] of o3)
                      await t4.skip(n5.offset - t4.offset), r4[e4] = await t4.read(n5.length);
                    let a4 = [];
                    if (r4.ltag && (a4 = p.ltag.parse(r4.ltag)), !r4.name)
                      throw new Error(`missing required OpenType table 'name' in font file: ${e3}`);
                    return { names: p.name.parse(r4.name, a4), os2: r4.os2 && p.os2.parse(r4.os2), head: r4.head && p.head.parse(r4.head), post: r4.post && p.post.parse(r4.post) };
                  case c.Woff:
                  default:
                    throw new Error("provided font type is not supported yet");
                }
              } finally {
                r3.unpipe(t4), a3 || (r3.destroy(), t4.destroy());
              }
            })().then(t3, n3);
          });
        };
        const f = { one: Buffer.from([0, 1, 0, 0]), otto: Buffer.from("OTTO"), true: Buffer.from("true"), typ1: Buffer.from("typ1"), woff: Buffer.from("wOFF") };
      }, 731: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        const s2 = n2(980);
        t2.default = function(e3) {
          return { version: s2.formatFixed(e3.readUInt16BE(0), e3.readUInt16BE(2)), fontRevision: s2.formatFixed(e3.readUInt16BE(4), e3.readUInt16BE(6)), checkSumAdjustment: e3.readUInt32BE(8), magicNumber: e3.readUInt32BE(12), flags: e3.readUInt16BE(16), unitsPerEm: e3.readUInt16BE(18), created: s2.formatLongDateTime(e3.readUInt32BE(20), e3.readUInt32BE(24)), modified: s2.formatLongDateTime(e3.readUInt32BE(28), e3.readUInt32BE(32)), xMin: e3.readInt16BE(36), yMin: e3.readInt16BE(38), xMax: e3.readInt16BE(40), yMax: e3.readInt16BE(42), macStyle: e3.readUInt16BE(44), lowestRecPPEM: e3.readUInt16BE(46), fontDirectionHint: e3.readInt16BE(48), indexToLocFormat: e3.readInt16BE(50), glyphDataFormat: e3.readInt16BE(52) };
        };
      }, 879: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          if (1 !== e3.readUInt32BE(0))
            throw new Error("Unsupported ltag table version.");
          const t3 = e3.readUInt32BE(8), n2 = [];
          for (let s2 = 0; s2 < t3; s2++) {
            let t4 = "";
            const o2 = e3.readUInt16BE(12 + 4 * s2), r2 = e3.readUInt16BE(14 + 4 * s2);
            for (let n3 = o2; n3 < o2 + r2; ++n3)
              t4 += String.fromCharCode(e3.readInt8(n3));
            n2.push(t4);
          }
          return n2;
        };
      }, 380: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        const n2 = ["copyright", "fontFamily", "fontSubfamily", "uniqueID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "manufacturerURL", "designerURL", "license", "licenseURL", "reserved", "preferredFamily", "preferredSubfamily", "compatibleFullName", "sampleText", "postScriptFindFontName", "wwsFamily", "wwsSubfamily"], s2 = { 0: "en", 1: "fr", 2: "de", 3: "it", 4: "nl", 5: "sv", 6: "es", 7: "da", 8: "pt", 9: "no", 10: "he", 11: "ja", 12: "ar", 13: "fi", 14: "el", 15: "is", 16: "mt", 17: "tr", 18: "hr", 19: "zh-Hant", 20: "ur", 21: "hi", 22: "th", 23: "ko", 24: "lt", 25: "pl", 26: "hu", 27: "es", 28: "lv", 29: "se", 30: "fo", 31: "fa", 32: "ru", 33: "zh", 34: "nl-BE", 35: "ga", 36: "sq", 37: "ro", 38: "cz", 39: "sk", 40: "si", 41: "yi", 42: "sr", 43: "mk", 44: "bg", 45: "uk", 46: "be", 47: "uz", 48: "kk", 49: "az-Cyrl", 50: "az-Arab", 51: "hy", 52: "ka", 53: "mo", 54: "ky", 55: "tg", 56: "tk", 57: "mn-CN", 58: "mn", 59: "ps", 60: "ks", 61: "ku", 62: "sd", 63: "bo", 64: "ne", 65: "sa", 66: "mr", 67: "bn", 68: "as", 69: "gu", 70: "pa", 71: "or", 72: "ml", 73: "kn", 74: "ta", 75: "te", 76: "si", 77: "my", 78: "km", 79: "lo", 80: "vi", 81: "id", 82: "tl", 83: "ms", 84: "ms-Arab", 85: "am", 86: "ti", 87: "om", 88: "so", 89: "sw", 90: "rw", 91: "rn", 92: "ny", 93: "mg", 94: "eo", 128: "cy", 129: "eu", 130: "ca", 131: "la", 132: "qu", 133: "gn", 134: "ay", 135: "tt", 136: "ug", 137: "dz", 138: "jv", 139: "su", 140: "gl", 141: "af", 142: "br", 143: "iu", 144: "gd", 145: "gv", 146: "ga", 147: "to", 148: "el-polyton", 149: "kl", 150: "az", 151: "nn" }, o2 = { 1078: "af", 1052: "sq", 1156: "gsw", 1118: "am", 5121: "ar-DZ", 15361: "ar-BH", 3073: "ar", 2049: "ar-IQ", 11265: "ar-JO", 13313: "ar-KW", 12289: "ar-LB", 4097: "ar-LY", 6145: "ary", 8193: "ar-OM", 16385: "ar-QA", 1025: "ar-SA", 10241: "ar-SY", 7169: "aeb", 14337: "ar-AE", 9217: "ar-YE", 1067: "hy", 1101: "as", 2092: "az-Cyrl", 1068: "az", 1133: "ba", 1069: "eu", 1059: "be", 2117: "bn", 1093: "bn-IN", 8218: "bs-Cyrl", 5146: "bs", 1150: "br", 1026: "bg", 1027: "ca", 3076: "zh-HK", 5124: "zh-MO", 2052: "zh", 4100: "zh-SG", 1028: "zh-TW", 1155: "co", 1050: "hr", 4122: "hr-BA", 1029: "cs", 1030: "da", 1164: "prs", 1125: "dv", 2067: "nl-BE", 1043: "nl", 3081: "en-AU", 10249: "en-BZ", 4105: "en-CA", 9225: "en-029", 16393: "en-IN", 6153: "en-IE", 8201: "en-JM", 17417: "en-MY", 5129: "en-NZ", 13321: "en-PH", 18441: "en-SG", 7177: "en-ZA", 11273: "en-TT", 2057: "en-GB", 1033: "en", 12297: "en-ZW", 1061: "et", 1080: "fo", 1124: "fil", 1035: "fi", 2060: "fr-BE", 3084: "fr-CA", 1036: "fr", 5132: "fr-LU", 6156: "fr-MC", 4108: "fr-CH", 1122: "fy", 1110: "gl", 1079: "ka", 3079: "de-AT", 1031: "de", 5127: "de-LI", 4103: "de-LU", 2055: "de-CH", 1032: "el", 1135: "kl", 1095: "gu", 1128: "ha", 1037: "he", 1081: "hi", 1038: "hu", 1039: "is", 1136: "ig", 1057: "id", 1117: "iu", 2141: "iu-Latn", 2108: "ga", 1076: "xh", 1077: "zu", 1040: "it", 2064: "it-CH", 1041: "ja", 1099: "kn", 1087: "kk", 1107: "km", 1158: "quc", 1159: "rw", 1089: "sw", 1111: "kok", 1042: "ko", 1088: "ky", 1108: "lo", 1062: "lv", 1063: "lt", 2094: "dsb", 1134: "lb", 1071: "mk", 2110: "ms-BN", 1086: "ms", 1100: "ml", 1082: "mt", 1153: "mi", 1146: "arn", 1102: "mr", 1148: "moh", 1104: "mn", 2128: "mn-CN", 1121: "ne", 1044: "nb", 2068: "nn", 1154: "oc", 1096: "or", 1123: "ps", 1045: "pl", 1046: "pt", 2070: "pt-PT", 1094: "pa", 1131: "qu-BO", 2155: "qu-EC", 3179: "qu", 1048: "ro", 1047: "rm", 1049: "ru", 9275: "smn", 4155: "smj-NO", 5179: "smj", 3131: "se-FI", 1083: "se", 2107: "se-SE", 8251: "sms", 6203: "sma-NO", 7227: "sms", 1103: "sa", 7194: "sr-Cyrl-BA", 3098: "sr", 6170: "sr-Latn-BA", 2074: "sr-Latn", 1132: "nso", 1074: "tn", 1115: "si", 1051: "sk", 1060: "sl", 11274: "es-AR", 16394: "es-BO", 13322: "es-CL", 9226: "es-CO", 5130: "es-CR", 7178: "es-DO", 12298: "es-EC", 17418: "es-SV", 4106: "es-GT", 18442: "es-HN", 2058: "es-MX", 19466: "es-NI", 6154: "es-PA", 15370: "es-PY", 10250: "es-PE", 20490: "es-PR", 3082: "es", 1034: "es", 21514: "es-US", 14346: "es-UY", 8202: "es-VE", 2077: "sv-FI", 1053: "sv", 1114: "syr", 1064: "tg", 2143: "tzm", 1097: "ta", 1092: "tt", 1098: "te", 1054: "th", 1105: "bo", 1055: "tr", 1090: "tk", 1152: "ug", 1058: "uk", 1070: "hsb", 1056: "ur", 2115: "uz-Cyrl", 1091: "uz", 1066: "vi", 1106: "cy", 1160: "wo", 1157: "sah", 1144: "ii", 1130: "yo" };
        function r2(e3, t3, n3) {
          switch (e3) {
            case 0:
              if (65535 === t3)
                return "und";
              if (n3)
                return n3[t3];
              break;
            case 1:
              return s2[t3];
            case 3:
              return o2[t3];
          }
        }
        const a2 = "utf-16", i2 = { 0: "macintosh", 1: "x-mac-japanese", 2: "x-mac-chinesetrad", 3: "x-mac-korean", 6: "x-mac-greek", 7: "x-mac-cyrillic", 9: "x-mac-devanagai", 10: "x-mac-gurmukhi", 11: "x-mac-gujarati", 12: "x-mac-oriya", 13: "x-mac-bengali", 14: "x-mac-tamil", 15: "x-mac-telugu", 16: "x-mac-kannada", 17: "x-mac-malayalam", 18: "x-mac-sinhalese", 19: "x-mac-burmese", 20: "x-mac-khmer", 21: "x-mac-thai", 22: "x-mac-lao", 23: "x-mac-georgian", 24: "x-mac-armenian", 25: "x-mac-chinesesimp", 26: "x-mac-tibetan", 27: "x-mac-mongolian", 28: "x-mac-ethiopic", 29: "x-mac-ce", 30: "x-mac-vietnamese", 31: "x-mac-extarabic" }, l = { 15: "x-mac-icelandic", 17: "x-mac-turkish", 18: "x-mac-croatian", 24: "x-mac-ce", 25: "x-mac-ce", 26: "x-mac-ce", 27: "x-mac-ce", 28: "x-mac-ce", 30: "x-mac-icelandic", 37: "x-mac-romanian", 38: "x-mac-ce", 39: "x-mac-ce", 40: "x-mac-ce", 143: "x-mac-inuit", 146: "x-mac-gaelic" };
        function u(e3, t3, n3) {
          switch (e3) {
            case 0:
              return a2;
            case 1:
              return l[n3] || i2[t3];
            case 3:
              if (1 === t3 || 10 === t3)
                return a2;
          }
        }
        t2.default = function(e3, t3) {
          const s3 = {}, o3 = e3.readUInt16BE(2), i3 = e3.readUInt16BE(4);
          let l2 = 6;
          for (let c2 = 0; c2 < o3; c2++) {
            const o4 = e3.readUInt16BE(l2 + 0), c3 = e3.readUInt16BE(l2 + 2), f = e3.readUInt16BE(l2 + 4), h = e3.readUInt16BE(l2 + 6), d = n2[h] || String(h), g = e3.readUInt16BE(l2 + 8), m = e3.readUInt16BE(l2 + 10), y = r2(o4, f, t3), v = u(o4, c3, f);
            if (l2 += 12, void 0 !== v && void 0 !== y) {
              let t4;
              if (v === a2) {
                const n3 = g / 2, s4 = Array(n3);
                for (let t5 = 0; t5 < n3; t5++)
                  s4[t5] = e3.readUInt16BE(i3 + m + 2 * t5);
                t4 = String.fromCharCode(...s4);
              } else
                t4 = p(e3, i3 + m, g, v);
              if (t4) {
                let e4 = s3[d];
                void 0 === e4 && (e4 = s3[d] = {}), e4[y] = t4;
              }
            }
          }
          return s3;
        };
        const c = { "x-mac-croatian": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ", "x-mac-cyrillic": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю", "x-mac-gaelic": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæøṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ", "x-mac-greek": "Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩάΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ­", "x-mac-icelandic": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ", "x-mac-inuit": "ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł", "x-mac-ce": "ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ", macintosh: "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ", "x-mac-romanian": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ", "x-mac-turkish": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ" };
        function p(e3, t3, n3, s3) {
          const o3 = c[s3];
          if (void 0 === o3)
            return;
          let r3 = "";
          for (let s4 = 0; s4 < n3; s4++) {
            const n4 = e3.readUInt8(t3 + s4);
            r3 += n4 <= 127 ? String.fromCharCode(n4) : o3[127 & n4];
          }
          return r3;
        }
      }, 130: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          const t3 = { version: e3.readUInt16BE(0), xAvgCharWidth: e3.readUInt16BE(2), usWeightClass: e3.readUInt16BE(4), usWidthClass: e3.readUInt16BE(6), fsType: e3.readUInt16BE(8), ySubscriptXSize: e3.readInt16BE(10), ySubscriptYSize: e3.readInt16BE(12), ySubscriptXOffset: e3.readInt16BE(14), ySubscriptYOffset: e3.readInt16BE(16), ySuperscriptXSize: e3.readInt16BE(18), ySuperscriptYSize: e3.readInt16BE(20), ySuperscriptXOffset: e3.readInt16BE(22), ySuperscriptYOffset: e3.readInt16BE(24), yStrikeoutSize: e3.readInt16BE(26), yStrikeoutPosition: e3.readInt16BE(28), sFamilyClass: e3.readInt16BE(30), panose: [e3.readUInt8(32), e3.readUInt8(33), e3.readUInt8(34), e3.readUInt8(35), e3.readUInt8(36), e3.readUInt8(37), e3.readUInt8(38), e3.readUInt8(39), e3.readUInt8(40), e3.readUInt8(41)], ulUnicodeRange1: e3.readUInt32BE(42), ulUnicodeRange2: e3.readUInt32BE(46), ulUnicodeRange3: e3.readUInt32BE(50), ulUnicodeRange4: e3.readUInt32BE(54), achVendID: String.fromCharCode(e3.readUInt8(58), e3.readUInt8(59), e3.readUInt8(60), e3.readUInt8(61)), fsSelection: e3.readUInt16BE(62), usFirstCharIndex: e3.readUInt16BE(64), usLastCharIndex: e3.readUInt16BE(66), sTypoAscender: e3.readInt16BE(68), sTypoDescender: e3.readInt16BE(70), sTypoLineGap: e3.readInt16BE(72), usWinAscent: e3.readUInt16BE(74), usWinDescent: e3.readUInt16BE(76) };
          return t3.version >= 1 && (t3.ulCodePageRange1 = e3.readUInt32BE(78), t3.ulCodePageRange2 = e3.readUInt32BE(82)), t3.version >= 2 && (t3.sxHeight = e3.readInt16BE(86), t3.sCapHeight = e3.readInt16BE(88), t3.usDefaultChar = e3.readUInt16BE(90), t3.usBreakChar = e3.readUInt16BE(92), t3.usMaxContent = e3.readUInt16BE(94)), t3;
        };
      }, 954: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        const s2 = n2(980);
        t2.default = function(e3) {
          return { version: s2.formatFixed(e3.readUInt16BE(0), e3.readUInt16BE(2)), italicAngle: s2.formatFixed(e3.readUInt16BE(4), e3.readUInt16BE(6)), underlinePosition: e3.readInt16BE(8), underlineThickness: e3.readInt16BE(10), isFixedPitch: e3.readUInt32BE(12), minMemType42: e3.readUInt32BE(16), maxMemType42: e3.readUInt32BE(20), minMemType1: e3.readUInt32BE(24), maxMemType1: e3.readUInt32BE(28) };
        };
      }, 980: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.formatFixed = function(e3, t3) {
          return e3 + t3 / 65536;
        }, t2.formatLongDateTime = function(e3, t3) {
          return 1e3 * (e3 * 2 ** 32 + t3 - 2082844800);
        };
      }, 459: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        const s2 = n2(56), o2 = n2(456), r2 = n2(49), a2 = { win32: () => process.env.WINDIR ? [s2.join(process.env.WINDIR, "Fonts")] : ["C:\\Windows\\Fonts"], darwin: () => {
          const e3 = o2.homedir();
          return [...e3 ? [s2.join(e3, "/Library/Fonts")] : [], "/Library/Fonts", "/Network/Library/Fonts", "/System/Library/Fonts", "/System Folder/Fonts"];
        }, linux: () => {
          const e3 = o2.homedir();
          return ["/usr/share/fonts", "/usr/local/share/fonts", ...e3 ? [s2.join(e3, ".fonts"), s2.join(e3, ".local/share/fonts")] : []];
        } };
        function i2(e3) {
          const t3 = Object.assign({ extensions: ["ttf", "otf", "ttc", "woff", "woff2"], additionalFolders: [] }, e3), n3 = o2.platform(), s3 = a2[n3];
          if (!s3)
            throw new Error(`Unsupported platform: ${n3}`);
          const i3 = s3();
          return r2.default([...i3, ...t3.additionalFolders], t3.extensions);
        }
        e2.exports = Object.assign(i2, { default: i2 }), t2.default = i2;
      }, 49: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        const s2 = n2(89), o2 = n2(269), r2 = n2(56), a2 = o2.promisify(s2.readdir), i2 = o2.promisify(s2.stat);
        async function l(e3, t3, n3 = 10) {
          if (n3 <= 0)
            return [];
          let s3;
          try {
            s3 = await a2(e3);
          } catch (e4) {
            return [];
          }
          const o3 = [];
          return await Promise.all(s3.map(async (s4) => {
            const a3 = r2.join(e3, s4);
            let u;
            try {
              u = await i2(a3);
            } catch (e4) {
              return;
            }
            u.isFile() && t3.test(a3) ? o3.push(a3) : u.isDirectory() && o3.push(...await l(a3, t3, n3 - 1));
          })), o3;
        }
        t2.default = async function(e3, t3) {
          const n3 = /* @__PURE__ */ new Set();
          return await Promise.all(e3.map(async (e4) => {
            const s3 = await l(r2.resolve(e4), new RegExp(`\\.${t3.map((e5) => `(?:${e5})`).join("|")}$`));
            for (const e5 of s3)
              n3.add(e5);
          })), [...n3];
        };
      }, 593: (e2, t2, n2) => {
        "use strict";
        const s2 = n2(411), o2 = Symbol("max"), r2 = Symbol("length"), a2 = Symbol("lengthCalculator"), i2 = Symbol("allowStale"), l = Symbol("maxAge"), u = Symbol("dispose"), c = Symbol("noDisposeOnSet"), p = Symbol("lruList"), f = Symbol("cache"), h = Symbol("updateAgeOnGet"), d = () => 1, g = (e3, t3, n3) => {
          const s3 = e3[f].get(t3);
          if (s3) {
            const t4 = s3.value;
            if (m(e3, t4)) {
              if (v(e3, s3), !e3[i2])
                return;
            } else
              n3 && (e3[h] && (s3.value.now = Date.now()), e3[p].unshiftNode(s3));
            return t4.value;
          }
        }, m = (e3, t3) => {
          if (!t3 || !t3.maxAge && !e3[l])
            return false;
          const n3 = Date.now() - t3.now;
          return t3.maxAge ? n3 > t3.maxAge : e3[l] && n3 > e3[l];
        }, y = (e3) => {
          if (e3[r2] > e3[o2])
            for (let t3 = e3[p].tail; e3[r2] > e3[o2] && null !== t3; ) {
              const n3 = t3.prev;
              v(e3, t3), t3 = n3;
            }
        }, v = (e3, t3) => {
          if (t3) {
            const n3 = t3.value;
            e3[u] && e3[u](n3.key, n3.value), e3[r2] -= n3.length, e3[f].delete(n3.key), e3[p].removeNode(t3);
          }
        };
        class b {
          constructor(e3, t3, n3, s3, o3) {
            this.key = e3, this.value = t3, this.length = n3, this.now = s3, this.maxAge = o3 || 0;
          }
        }
        const x = (e3, t3, n3, s3) => {
          let o3 = n3.value;
          m(e3, o3) && (v(e3, n3), e3[i2] || (o3 = void 0)), o3 && t3.call(s3, o3.value, o3.key, e3);
        };
        e2.exports = class {
          constructor(e3) {
            if ("number" == typeof e3 && (e3 = { max: e3 }), e3 || (e3 = {}), e3.max && ("number" != typeof e3.max || e3.max < 0))
              throw new TypeError("max must be a non-negative number");
            this[o2] = e3.max || 1 / 0;
            const t3 = e3.length || d;
            if (this[a2] = "function" != typeof t3 ? d : t3, this[i2] = e3.stale || false, e3.maxAge && "number" != typeof e3.maxAge)
              throw new TypeError("maxAge must be a number");
            this[l] = e3.maxAge || 0, this[u] = e3.dispose, this[c] = e3.noDisposeOnSet || false, this[h] = e3.updateAgeOnGet || false, this.reset();
          }
          set max(e3) {
            if ("number" != typeof e3 || e3 < 0)
              throw new TypeError("max must be a non-negative number");
            this[o2] = e3 || 1 / 0, y(this);
          }
          get max() {
            return this[o2];
          }
          set allowStale(e3) {
            this[i2] = !!e3;
          }
          get allowStale() {
            return this[i2];
          }
          set maxAge(e3) {
            if ("number" != typeof e3)
              throw new TypeError("maxAge must be a non-negative number");
            this[l] = e3, y(this);
          }
          get maxAge() {
            return this[l];
          }
          set lengthCalculator(e3) {
            "function" != typeof e3 && (e3 = d), e3 !== this[a2] && (this[a2] = e3, this[r2] = 0, this[p].forEach((e4) => {
              e4.length = this[a2](e4.value, e4.key), this[r2] += e4.length;
            })), y(this);
          }
          get lengthCalculator() {
            return this[a2];
          }
          get length() {
            return this[r2];
          }
          get itemCount() {
            return this[p].length;
          }
          rforEach(e3, t3) {
            t3 = t3 || this;
            for (let n3 = this[p].tail; null !== n3; ) {
              const s3 = n3.prev;
              x(this, e3, n3, t3), n3 = s3;
            }
          }
          forEach(e3, t3) {
            t3 = t3 || this;
            for (let n3 = this[p].head; null !== n3; ) {
              const s3 = n3.next;
              x(this, e3, n3, t3), n3 = s3;
            }
          }
          keys() {
            return this[p].toArray().map((e3) => e3.key);
          }
          values() {
            return this[p].toArray().map((e3) => e3.value);
          }
          reset() {
            this[u] && this[p] && this[p].length && this[p].forEach((e3) => this[u](e3.key, e3.value)), this[f] = /* @__PURE__ */ new Map(), this[p] = new s2(), this[r2] = 0;
          }
          dump() {
            return this[p].map((e3) => !m(this, e3) && { k: e3.key, v: e3.value, e: e3.now + (e3.maxAge || 0) }).toArray().filter((e3) => e3);
          }
          dumpLru() {
            return this[p];
          }
          set(e3, t3, n3) {
            if ((n3 = n3 || this[l]) && "number" != typeof n3)
              throw new TypeError("maxAge must be a number");
            const s3 = n3 ? Date.now() : 0, i3 = this[a2](t3, e3);
            if (this[f].has(e3)) {
              if (i3 > this[o2])
                return v(this, this[f].get(e3)), false;
              const a3 = this[f].get(e3).value;
              return this[u] && (this[c] || this[u](e3, a3.value)), a3.now = s3, a3.maxAge = n3, a3.value = t3, this[r2] += i3 - a3.length, a3.length = i3, this.get(e3), y(this), true;
            }
            const h2 = new b(e3, t3, i3, s3, n3);
            return h2.length > this[o2] ? (this[u] && this[u](e3, t3), false) : (this[r2] += h2.length, this[p].unshift(h2), this[f].set(e3, this[p].head), y(this), true);
          }
          has(e3) {
            if (!this[f].has(e3))
              return false;
            const t3 = this[f].get(e3).value;
            return !m(this, t3);
          }
          get(e3) {
            return g(this, e3, true);
          }
          peek(e3) {
            return g(this, e3, false);
          }
          pop() {
            const e3 = this[p].tail;
            return e3 ? (v(this, e3), e3.value) : null;
          }
          del(e3) {
            v(this, this[f].get(e3));
          }
          load(e3) {
            this.reset();
            const t3 = Date.now();
            for (let n3 = e3.length - 1; n3 >= 0; n3--) {
              const s3 = e3[n3], o3 = s3.e || 0;
              if (0 === o3)
                this.set(s3.k, s3.v);
              else {
                const e4 = o3 - t3;
                e4 > 0 && this.set(s3.k, s3.v, e4);
              }
            }
          }
          prune() {
            this[f].forEach((e3, t3) => g(this, t3, false));
          }
        };
      }, 602: (e2, t2, n2) => {
        "use strict";
        n2.r(t2), n2.d(t2, { BoundingBox: () => i2, Font: () => gn, Glyph: () => ie, Path: () => u, _parse: () => z, load: () => Cn, loadSync: () => Dn, parse: () => Bn });
        var s2 = n2(311), o2 = n2.n(s2);
        function r2(e3, t3, n3, s3, o3) {
          return Math.pow(1 - o3, 3) * e3 + 3 * Math.pow(1 - o3, 2) * o3 * t3 + 3 * (1 - o3) * Math.pow(o3, 2) * n3 + Math.pow(o3, 3) * s3;
        }
        function a2() {
          this.x1 = Number.NaN, this.y1 = Number.NaN, this.x2 = Number.NaN, this.y2 = Number.NaN;
        }
        a2.prototype.isEmpty = function() {
          return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
        }, a2.prototype.addPoint = function(e3, t3) {
          "number" == typeof e3 && ((isNaN(this.x1) || isNaN(this.x2)) && (this.x1 = e3, this.x2 = e3), e3 < this.x1 && (this.x1 = e3), e3 > this.x2 && (this.x2 = e3)), "number" == typeof t3 && ((isNaN(this.y1) || isNaN(this.y2)) && (this.y1 = t3, this.y2 = t3), t3 < this.y1 && (this.y1 = t3), t3 > this.y2 && (this.y2 = t3));
        }, a2.prototype.addX = function(e3) {
          this.addPoint(e3, null);
        }, a2.prototype.addY = function(e3) {
          this.addPoint(null, e3);
        }, a2.prototype.addBezier = function(e3, t3, n3, s3, o3, a3, i3, l2) {
          const u2 = [e3, t3], c2 = [n3, s3], p2 = [o3, a3], f2 = [i3, l2];
          this.addPoint(e3, t3), this.addPoint(i3, l2);
          for (let e4 = 0; e4 <= 1; e4++) {
            const t4 = 6 * u2[e4] - 12 * c2[e4] + 6 * p2[e4], n4 = -3 * u2[e4] + 9 * c2[e4] - 9 * p2[e4] + 3 * f2[e4], s4 = 3 * c2[e4] - 3 * u2[e4];
            if (0 === n4) {
              if (0 === t4)
                continue;
              const n5 = -s4 / t4;
              0 < n5 && n5 < 1 && (0 === e4 && this.addX(r2(u2[e4], c2[e4], p2[e4], f2[e4], n5)), 1 === e4 && this.addY(r2(u2[e4], c2[e4], p2[e4], f2[e4], n5)));
              continue;
            }
            const o4 = Math.pow(t4, 2) - 4 * s4 * n4;
            if (o4 < 0)
              continue;
            const a4 = (-t4 + Math.sqrt(o4)) / (2 * n4);
            0 < a4 && a4 < 1 && (0 === e4 && this.addX(r2(u2[e4], c2[e4], p2[e4], f2[e4], a4)), 1 === e4 && this.addY(r2(u2[e4], c2[e4], p2[e4], f2[e4], a4)));
            const i4 = (-t4 - Math.sqrt(o4)) / (2 * n4);
            0 < i4 && i4 < 1 && (0 === e4 && this.addX(r2(u2[e4], c2[e4], p2[e4], f2[e4], i4)), 1 === e4 && this.addY(r2(u2[e4], c2[e4], p2[e4], f2[e4], i4)));
          }
        }, a2.prototype.addQuad = function(e3, t3, n3, s3, o3, r3) {
          const a3 = e3 + 2 / 3 * (n3 - e3), i3 = t3 + 2 / 3 * (s3 - t3), l2 = a3 + 1 / 3 * (o3 - e3), u2 = i3 + 1 / 3 * (r3 - t3);
          this.addBezier(e3, t3, a3, i3, l2, u2, o3, r3);
        };
        const i2 = a2;
        function l() {
          this.commands = [], this.fill = "black", this.stroke = null, this.strokeWidth = 1;
        }
        l.prototype.moveTo = function(e3, t3) {
          this.commands.push({ type: "M", x: e3, y: t3 });
        }, l.prototype.lineTo = function(e3, t3) {
          this.commands.push({ type: "L", x: e3, y: t3 });
        }, l.prototype.curveTo = l.prototype.bezierCurveTo = function(e3, t3, n3, s3, o3, r3) {
          this.commands.push({ type: "C", x1: e3, y1: t3, x2: n3, y2: s3, x: o3, y: r3 });
        }, l.prototype.quadTo = l.prototype.quadraticCurveTo = function(e3, t3, n3, s3) {
          this.commands.push({ type: "Q", x1: e3, y1: t3, x: n3, y: s3 });
        }, l.prototype.close = l.prototype.closePath = function() {
          this.commands.push({ type: "Z" });
        }, l.prototype.extend = function(e3) {
          if (e3.commands)
            e3 = e3.commands;
          else if (e3 instanceof i2) {
            const t3 = e3;
            return this.moveTo(t3.x1, t3.y1), this.lineTo(t3.x2, t3.y1), this.lineTo(t3.x2, t3.y2), this.lineTo(t3.x1, t3.y2), void this.close();
          }
          Array.prototype.push.apply(this.commands, e3);
        }, l.prototype.getBoundingBox = function() {
          const e3 = new i2();
          let t3 = 0, n3 = 0, s3 = 0, o3 = 0;
          for (let r3 = 0; r3 < this.commands.length; r3++) {
            const a3 = this.commands[r3];
            switch (a3.type) {
              case "M":
                e3.addPoint(a3.x, a3.y), t3 = s3 = a3.x, n3 = o3 = a3.y;
                break;
              case "L":
                e3.addPoint(a3.x, a3.y), s3 = a3.x, o3 = a3.y;
                break;
              case "Q":
                e3.addQuad(s3, o3, a3.x1, a3.y1, a3.x, a3.y), s3 = a3.x, o3 = a3.y;
                break;
              case "C":
                e3.addBezier(s3, o3, a3.x1, a3.y1, a3.x2, a3.y2, a3.x, a3.y), s3 = a3.x, o3 = a3.y;
                break;
              case "Z":
                s3 = t3, o3 = n3;
                break;
              default:
                throw new Error("Unexpected path command " + a3.type);
            }
          }
          return e3.isEmpty() && e3.addPoint(0, 0), e3;
        }, l.prototype.draw = function(e3) {
          e3.beginPath();
          for (let t3 = 0; t3 < this.commands.length; t3 += 1) {
            const n3 = this.commands[t3];
            "M" === n3.type ? e3.moveTo(n3.x, n3.y) : "L" === n3.type ? e3.lineTo(n3.x, n3.y) : "C" === n3.type ? e3.bezierCurveTo(n3.x1, n3.y1, n3.x2, n3.y2, n3.x, n3.y) : "Q" === n3.type ? e3.quadraticCurveTo(n3.x1, n3.y1, n3.x, n3.y) : "Z" === n3.type && e3.closePath();
          }
          this.fill && (e3.fillStyle = this.fill, e3.fill()), this.stroke && (e3.strokeStyle = this.stroke, e3.lineWidth = this.strokeWidth, e3.stroke());
        }, l.prototype.toPathData = function(e3) {
          function t3(t4) {
            return Math.round(t4) === t4 ? "" + Math.round(t4) : t4.toFixed(e3);
          }
          function n3() {
            let e4 = "";
            for (let n4 = 0; n4 < arguments.length; n4 += 1) {
              const s4 = arguments[n4];
              s4 >= 0 && n4 > 0 && (e4 += " "), e4 += t3(s4);
            }
            return e4;
          }
          e3 = void 0 !== e3 ? e3 : 2;
          let s3 = "";
          for (let e4 = 0; e4 < this.commands.length; e4 += 1) {
            const t4 = this.commands[e4];
            "M" === t4.type ? s3 += "M" + n3(t4.x, t4.y) : "L" === t4.type ? s3 += "L" + n3(t4.x, t4.y) : "C" === t4.type ? s3 += "C" + n3(t4.x1, t4.y1, t4.x2, t4.y2, t4.x, t4.y) : "Q" === t4.type ? s3 += "Q" + n3(t4.x1, t4.y1, t4.x, t4.y) : "Z" === t4.type && (s3 += "Z");
          }
          return s3;
        }, l.prototype.toSVG = function(e3) {
          let t3 = '<path d="';
          return t3 += this.toPathData(e3), t3 += '"', this.fill && "black" !== this.fill && (null === this.fill ? t3 += ' fill="none"' : t3 += ' fill="' + this.fill + '"'), this.stroke && (t3 += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"'), t3 += "/>", t3;
        }, l.prototype.toDOMElement = function(e3) {
          const t3 = this.toPathData(e3), n3 = document.createElementNS("http://www.w3.org/2000/svg", "path");
          return n3.setAttribute("d", t3), n3;
        };
        const u = l;
        function c(e3) {
          throw new Error(e3);
        }
        function p(e3, t3) {
          e3 || c(t3);
        }
        const f = { fail: c, argument: p, assert: p }, h = 2147483648, d = {}, g = {}, m = {};
        function y(e3) {
          return function() {
            return e3;
          };
        }
        g.BYTE = function(e3) {
          return f.argument(e3 >= 0 && e3 <= 255, "Byte value should be between 0 and 255."), [e3];
        }, m.BYTE = y(1), g.CHAR = function(e3) {
          return [e3.charCodeAt(0)];
        }, m.CHAR = y(1), g.CHARARRAY = function(e3) {
          const t3 = [];
          for (let n3 = 0; n3 < e3.length; n3 += 1)
            t3[n3] = e3.charCodeAt(n3);
          return t3;
        }, m.CHARARRAY = function(e3) {
          return e3.length;
        }, g.USHORT = function(e3) {
          return [e3 >> 8 & 255, 255 & e3];
        }, m.USHORT = y(2), g.SHORT = function(e3) {
          return e3 >= 32768 && (e3 = -(65536 - e3)), [e3 >> 8 & 255, 255 & e3];
        }, m.SHORT = y(2), g.UINT24 = function(e3) {
          return [e3 >> 16 & 255, e3 >> 8 & 255, 255 & e3];
        }, m.UINT24 = y(3), g.ULONG = function(e3) {
          return [e3 >> 24 & 255, e3 >> 16 & 255, e3 >> 8 & 255, 255 & e3];
        }, m.ULONG = y(4), g.LONG = function(e3) {
          return e3 >= h && (e3 = -(2 * h - e3)), [e3 >> 24 & 255, e3 >> 16 & 255, e3 >> 8 & 255, 255 & e3];
        }, m.LONG = y(4), g.FIXED = g.ULONG, m.FIXED = m.ULONG, g.FWORD = g.SHORT, m.FWORD = m.SHORT, g.UFWORD = g.USHORT, m.UFWORD = m.USHORT, g.LONGDATETIME = function(e3) {
          return [0, 0, 0, 0, e3 >> 24 & 255, e3 >> 16 & 255, e3 >> 8 & 255, 255 & e3];
        }, m.LONGDATETIME = y(8), g.TAG = function(e3) {
          return f.argument(4 === e3.length, "Tag should be exactly 4 ASCII characters."), [e3.charCodeAt(0), e3.charCodeAt(1), e3.charCodeAt(2), e3.charCodeAt(3)];
        }, m.TAG = y(4), g.Card8 = g.BYTE, m.Card8 = m.BYTE, g.Card16 = g.USHORT, m.Card16 = m.USHORT, g.OffSize = g.BYTE, m.OffSize = m.BYTE, g.SID = g.USHORT, m.SID = m.USHORT, g.NUMBER = function(e3) {
          return e3 >= -107 && e3 <= 107 ? [e3 + 139] : e3 >= 108 && e3 <= 1131 ? [247 + ((e3 -= 108) >> 8), 255 & e3] : e3 >= -1131 && e3 <= -108 ? [251 + ((e3 = -e3 - 108) >> 8), 255 & e3] : e3 >= -32768 && e3 <= 32767 ? g.NUMBER16(e3) : g.NUMBER32(e3);
        }, m.NUMBER = function(e3) {
          return g.NUMBER(e3).length;
        }, g.NUMBER16 = function(e3) {
          return [28, e3 >> 8 & 255, 255 & e3];
        }, m.NUMBER16 = y(3), g.NUMBER32 = function(e3) {
          return [29, e3 >> 24 & 255, e3 >> 16 & 255, e3 >> 8 & 255, 255 & e3];
        }, m.NUMBER32 = y(5), g.REAL = function(e3) {
          let t3 = e3.toString();
          const n3 = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(t3);
          if (n3) {
            const s4 = parseFloat("1e" + ((n3[2] ? +n3[2] : 0) + n3[1].length));
            t3 = (Math.round(e3 * s4) / s4).toString();
          }
          let s3 = "";
          for (let e4 = 0, n4 = t3.length; e4 < n4; e4 += 1) {
            const n5 = t3[e4];
            s3 += "e" === n5 ? "-" === t3[++e4] ? "c" : "b" : "." === n5 ? "a" : "-" === n5 ? "e" : n5;
          }
          s3 += 1 & s3.length ? "f" : "ff";
          const o3 = [30];
          for (let e4 = 0, t4 = s3.length; e4 < t4; e4 += 2)
            o3.push(parseInt(s3.substr(e4, 2), 16));
          return o3;
        }, m.REAL = function(e3) {
          return g.REAL(e3).length;
        }, g.NAME = g.CHARARRAY, m.NAME = m.CHARARRAY, g.STRING = g.CHARARRAY, m.STRING = m.CHARARRAY, d.UTF8 = function(e3, t3, n3) {
          const s3 = [], o3 = n3;
          for (let n4 = 0; n4 < o3; n4++, t3 += 1)
            s3[n4] = e3.getUint8(t3);
          return String.fromCharCode.apply(null, s3);
        }, d.UTF16 = function(e3, t3, n3) {
          const s3 = [], o3 = n3 / 2;
          for (let n4 = 0; n4 < o3; n4++, t3 += 2)
            s3[n4] = e3.getUint16(t3);
          return String.fromCharCode.apply(null, s3);
        }, g.UTF16 = function(e3) {
          const t3 = [];
          for (let n3 = 0; n3 < e3.length; n3 += 1) {
            const s3 = e3.charCodeAt(n3);
            t3[t3.length] = s3 >> 8 & 255, t3[t3.length] = 255 & s3;
          }
          return t3;
        }, m.UTF16 = function(e3) {
          return 2 * e3.length;
        };
        const v = { "x-mac-croatian": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ", "x-mac-cyrillic": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю", "x-mac-gaelic": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæøṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ", "x-mac-greek": "Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩάΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ­", "x-mac-icelandic": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ", "x-mac-inuit": "ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł", "x-mac-ce": "ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ", macintosh: "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ", "x-mac-romanian": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ", "x-mac-turkish": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ" };
        d.MACSTRING = function(e3, t3, n3, s3) {
          const o3 = v[s3];
          if (void 0 === o3)
            return;
          let r3 = "";
          for (let s4 = 0; s4 < n3; s4++) {
            const n4 = e3.getUint8(t3 + s4);
            r3 += n4 <= 127 ? String.fromCharCode(n4) : o3[127 & n4];
          }
          return r3;
        };
        const b = "function" == typeof WeakMap && /* @__PURE__ */ new WeakMap();
        let x;
        function S(e3) {
          return e3 >= -128 && e3 <= 127;
        }
        function U(e3, t3, n3) {
          let s3 = 0;
          const o3 = e3.length;
          for (; t3 < o3 && s3 < 64 && 0 === e3[t3]; )
            ++t3, ++s3;
          return n3.push(128 | s3 - 1), t3;
        }
        function k(e3, t3, n3) {
          let s3 = 0;
          const o3 = e3.length;
          let r3 = t3;
          for (; r3 < o3 && s3 < 64; ) {
            const t4 = e3[r3];
            if (!S(t4))
              break;
            if (0 === t4 && r3 + 1 < o3 && 0 === e3[r3 + 1])
              break;
            ++r3, ++s3;
          }
          n3.push(s3 - 1);
          for (let s4 = t3; s4 < r3; ++s4)
            n3.push(e3[s4] + 256 & 255);
          return r3;
        }
        function T(e3, t3, n3) {
          let s3 = 0;
          const o3 = e3.length;
          let r3 = t3;
          for (; r3 < o3 && s3 < 64; ) {
            const t4 = e3[r3];
            if (0 === t4)
              break;
            if (S(t4) && r3 + 1 < o3 && S(e3[r3 + 1]))
              break;
            ++r3, ++s3;
          }
          n3.push(64 | s3 - 1);
          for (let s4 = t3; s4 < r3; ++s4) {
            const t4 = e3[s4];
            n3.push(t4 + 65536 >> 8 & 255, t4 + 256 & 255);
          }
          return r3;
        }
        g.MACSTRING = function(e3, t3) {
          const n3 = function(e4) {
            if (!x) {
              x = {};
              for (let e5 in v)
                x[e5] = new String(e5);
            }
            const t4 = x[e4];
            if (void 0 === t4)
              return;
            if (b) {
              const e5 = b.get(t4);
              if (void 0 !== e5)
                return e5;
            }
            const n4 = v[e4];
            if (void 0 === n4)
              return;
            const s4 = {};
            for (let e5 = 0; e5 < n4.length; e5++)
              s4[n4.charCodeAt(e5)] = e5 + 128;
            return b && b.set(t4, s4), s4;
          }(t3);
          if (void 0 === n3)
            return;
          const s3 = [];
          for (let t4 = 0; t4 < e3.length; t4++) {
            let o3 = e3.charCodeAt(t4);
            if (o3 >= 128 && (o3 = n3[o3], void 0 === o3))
              return;
            s3[t4] = o3;
          }
          return s3;
        }, m.MACSTRING = function(e3, t3) {
          const n3 = g.MACSTRING(e3, t3);
          return void 0 !== n3 ? n3.length : 0;
        }, g.VARDELTAS = function(e3) {
          let t3 = 0;
          const n3 = [];
          for (; t3 < e3.length; ) {
            const s3 = e3[t3];
            t3 = 0 === s3 ? U(e3, t3, n3) : s3 >= -128 && s3 <= 127 ? k(e3, t3, n3) : T(e3, t3, n3);
          }
          return n3;
        }, g.INDEX = function(e3) {
          let t3 = 1;
          const n3 = [t3], s3 = [];
          for (let o4 = 0; o4 < e3.length; o4 += 1) {
            const r4 = g.OBJECT(e3[o4]);
            Array.prototype.push.apply(s3, r4), t3 += r4.length, n3.push(t3);
          }
          if (0 === s3.length)
            return [0, 0];
          const o3 = [], r3 = 1 + Math.floor(Math.log(t3) / Math.log(2)) / 8 | 0, a3 = [void 0, g.BYTE, g.USHORT, g.UINT24, g.ULONG][r3];
          for (let e4 = 0; e4 < n3.length; e4 += 1) {
            const t4 = a3(n3[e4]);
            Array.prototype.push.apply(o3, t4);
          }
          return Array.prototype.concat(g.Card16(e3.length), g.OffSize(r3), o3, s3);
        }, m.INDEX = function(e3) {
          return g.INDEX(e3).length;
        }, g.DICT = function(e3) {
          let t3 = [];
          const n3 = Object.keys(e3), s3 = n3.length;
          for (let o3 = 0; o3 < s3; o3 += 1) {
            const s4 = parseInt(n3[o3], 0), r3 = e3[s4];
            t3 = t3.concat(g.OPERAND(r3.value, r3.type)), t3 = t3.concat(g.OPERATOR(s4));
          }
          return t3;
        }, m.DICT = function(e3) {
          return g.DICT(e3).length;
        }, g.OPERATOR = function(e3) {
          return e3 < 1200 ? [e3] : [12, e3 - 1200];
        }, g.OPERAND = function(e3, t3) {
          let n3 = [];
          if (Array.isArray(t3))
            for (let s3 = 0; s3 < t3.length; s3 += 1)
              f.argument(e3.length === t3.length, "Not enough arguments given for type" + t3), n3 = n3.concat(g.OPERAND(e3[s3], t3[s3]));
          else if ("SID" === t3)
            n3 = n3.concat(g.NUMBER(e3));
          else if ("offset" === t3)
            n3 = n3.concat(g.NUMBER32(e3));
          else if ("number" === t3)
            n3 = n3.concat(g.NUMBER(e3));
          else {
            if ("real" !== t3)
              throw new Error("Unknown operand type " + t3);
            n3 = n3.concat(g.REAL(e3));
          }
          return n3;
        }, g.OP = g.BYTE, m.OP = m.BYTE;
        const E = "function" == typeof WeakMap && /* @__PURE__ */ new WeakMap();
        function w(e3, t3, n3) {
          for (let e4 = 0; e4 < t3.length; e4 += 1) {
            const n4 = t3[e4];
            this[n4.name] = n4.value;
          }
          if (this.tableName = e3, this.fields = t3, n3) {
            const e4 = Object.keys(n3);
            for (let t4 = 0; t4 < e4.length; t4 += 1) {
              const s3 = e4[t4], o3 = n3[s3];
              void 0 !== this[s3] && (this[s3] = o3);
            }
          }
        }
        function O(e3, t3, n3) {
          void 0 === n3 && (n3 = t3.length);
          const s3 = new Array(t3.length + 1);
          s3[0] = { name: e3 + "Count", type: "USHORT", value: n3 };
          for (let n4 = 0; n4 < t3.length; n4++)
            s3[n4 + 1] = { name: e3 + n4, type: "USHORT", value: t3[n4] };
          return s3;
        }
        function I(e3, t3, n3) {
          const s3 = t3.length, o3 = new Array(s3 + 1);
          o3[0] = { name: e3 + "Count", type: "USHORT", value: s3 };
          for (let r3 = 0; r3 < s3; r3++)
            o3[r3 + 1] = { name: e3 + r3, type: "TABLE", value: n3(t3[r3], r3) };
          return o3;
        }
        function R(e3, t3, n3) {
          const s3 = t3.length;
          let o3 = [];
          o3[0] = { name: e3 + "Count", type: "USHORT", value: s3 };
          for (let e4 = 0; e4 < s3; e4++)
            o3 = o3.concat(n3(t3[e4], e4));
          return o3;
        }
        function L(e3) {
          1 === e3.format ? w.call(this, "coverageTable", [{ name: "coverageFormat", type: "USHORT", value: 1 }].concat(O("glyph", e3.glyphs))) : f.assert(false, "Can't create coverage table format 2 yet.");
        }
        function B(e3) {
          w.call(this, "scriptListTable", R("scriptRecord", e3, function(e4, t3) {
            const n3 = e4.script;
            let s3 = n3.defaultLangSys;
            return f.assert(!!s3, "Unable to write GSUB: script " + e4.tag + " has no default language system."), [{ name: "scriptTag" + t3, type: "TAG", value: e4.tag }, { name: "script" + t3, type: "TABLE", value: new w("scriptTable", [{ name: "defaultLangSys", type: "TABLE", value: new w("defaultLangSys", [{ name: "lookupOrder", type: "USHORT", value: 0 }, { name: "reqFeatureIndex", type: "USHORT", value: s3.reqFeatureIndex }].concat(O("featureIndex", s3.featureIndexes))) }].concat(R("langSys", n3.langSysRecords, function(e5, t4) {
              const n4 = e5.langSys;
              return [{ name: "langSysTag" + t4, type: "TAG", value: e5.tag }, { name: "langSys" + t4, type: "TABLE", value: new w("langSys", [{ name: "lookupOrder", type: "USHORT", value: 0 }, { name: "reqFeatureIndex", type: "USHORT", value: n4.reqFeatureIndex }].concat(O("featureIndex", n4.featureIndexes))) }];
            }))) }];
          }));
        }
        function C(e3) {
          w.call(this, "featureListTable", R("featureRecord", e3, function(e4, t3) {
            const n3 = e4.feature;
            return [{ name: "featureTag" + t3, type: "TAG", value: e4.tag }, { name: "feature" + t3, type: "TABLE", value: new w("featureTable", [{ name: "featureParams", type: "USHORT", value: n3.featureParams }].concat(O("lookupListIndex", n3.lookupListIndexes))) }];
          }));
        }
        function D(e3, t3) {
          w.call(this, "lookupListTable", I("lookup", e3, function(e4) {
            let n3 = t3[e4.lookupType];
            return f.assert(!!n3, "Unable to write GSUB lookup type " + e4.lookupType + " tables."), new w("lookupTable", [{ name: "lookupType", type: "USHORT", value: e4.lookupType }, { name: "lookupFlag", type: "USHORT", value: e4.lookupFlag }].concat(I("subtable", e4.subtables, n3)));
          }));
        }
        g.CHARSTRING = function(e3) {
          if (E) {
            const t4 = E.get(e3);
            if (void 0 !== t4)
              return t4;
          }
          let t3 = [];
          const n3 = e3.length;
          for (let s3 = 0; s3 < n3; s3 += 1) {
            const n4 = e3[s3];
            t3 = t3.concat(g[n4.type](n4.value));
          }
          return E && E.set(e3, t3), t3;
        }, m.CHARSTRING = function(e3) {
          return g.CHARSTRING(e3).length;
        }, g.OBJECT = function(e3) {
          const t3 = g[e3.type];
          return f.argument(void 0 !== t3, "No encoding function for type " + e3.type), t3(e3.value);
        }, m.OBJECT = function(e3) {
          const t3 = m[e3.type];
          return f.argument(void 0 !== t3, "No sizeOf function for type " + e3.type), t3(e3.value);
        }, g.TABLE = function(e3) {
          let t3 = [];
          const n3 = e3.fields.length, s3 = [], o3 = [];
          for (let r3 = 0; r3 < n3; r3 += 1) {
            const n4 = e3.fields[r3], a3 = g[n4.type];
            f.argument(void 0 !== a3, "No encoding function for field type " + n4.type + " (" + n4.name + ")");
            let i3 = e3[n4.name];
            void 0 === i3 && (i3 = n4.value);
            const l2 = a3(i3);
            "TABLE" === n4.type ? (o3.push(t3.length), t3 = t3.concat([0, 0]), s3.push(l2)) : t3 = t3.concat(l2);
          }
          for (let n4 = 0; n4 < s3.length; n4 += 1) {
            const r3 = o3[n4], a3 = t3.length;
            f.argument(a3 < 65536, "Table " + e3.tableName + " too big."), t3[r3] = a3 >> 8, t3[r3 + 1] = 255 & a3, t3 = t3.concat(s3[n4]);
          }
          return t3;
        }, m.TABLE = function(e3) {
          let t3 = 0;
          const n3 = e3.fields.length;
          for (let s3 = 0; s3 < n3; s3 += 1) {
            const n4 = e3.fields[s3], o3 = m[n4.type];
            f.argument(void 0 !== o3, "No sizeOf function for field type " + n4.type + " (" + n4.name + ")");
            let r3 = e3[n4.name];
            void 0 === r3 && (r3 = n4.value), t3 += o3(r3), "TABLE" === n4.type && (t3 += 2);
          }
          return t3;
        }, g.RECORD = g.TABLE, m.RECORD = m.TABLE, g.LITERAL = function(e3) {
          return e3;
        }, m.LITERAL = function(e3) {
          return e3.length;
        }, w.prototype.encode = function() {
          return g.TABLE(this);
        }, w.prototype.sizeOf = function() {
          return m.TABLE(this);
        }, L.prototype = Object.create(w.prototype), L.prototype.constructor = L, B.prototype = Object.create(w.prototype), B.prototype.constructor = B, C.prototype = Object.create(w.prototype), C.prototype.constructor = C, D.prototype = Object.create(w.prototype), D.prototype.constructor = D;
        const M = { Table: w, Record: w, Coverage: L, ScriptList: B, FeatureList: C, LookupList: D, ushortList: O, tableList: I, recordList: R };
        function A(e3, t3) {
          return e3.getUint8(t3);
        }
        function P(e3, t3) {
          return e3.getUint16(t3, false);
        }
        function G(e3, t3) {
          return e3.getUint32(t3, false);
        }
        function N(e3, t3) {
          return e3.getInt16(t3, false) + e3.getUint16(t3 + 2, false) / 65535;
        }
        const F = { byte: 1, uShort: 2, short: 2, uLong: 4, fixed: 4, longDateTime: 8, tag: 4 };
        function _(e3, t3) {
          this.data = e3, this.offset = t3, this.relativeOffset = 0;
        }
        _.prototype.parseByte = function() {
          const e3 = this.data.getUint8(this.offset + this.relativeOffset);
          return this.relativeOffset += 1, e3;
        }, _.prototype.parseChar = function() {
          const e3 = this.data.getInt8(this.offset + this.relativeOffset);
          return this.relativeOffset += 1, e3;
        }, _.prototype.parseCard8 = _.prototype.parseByte, _.prototype.parseUShort = function() {
          const e3 = this.data.getUint16(this.offset + this.relativeOffset);
          return this.relativeOffset += 2, e3;
        }, _.prototype.parseCard16 = _.prototype.parseUShort, _.prototype.parseSID = _.prototype.parseUShort, _.prototype.parseOffset16 = _.prototype.parseUShort, _.prototype.parseShort = function() {
          const e3 = this.data.getInt16(this.offset + this.relativeOffset);
          return this.relativeOffset += 2, e3;
        }, _.prototype.parseF2Dot14 = function() {
          const e3 = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
          return this.relativeOffset += 2, e3;
        }, _.prototype.parseULong = function() {
          const e3 = G(this.data, this.offset + this.relativeOffset);
          return this.relativeOffset += 4, e3;
        }, _.prototype.parseOffset32 = _.prototype.parseULong, _.prototype.parseFixed = function() {
          const e3 = N(this.data, this.offset + this.relativeOffset);
          return this.relativeOffset += 4, e3;
        }, _.prototype.parseString = function(e3) {
          const t3 = this.data, n3 = this.offset + this.relativeOffset;
          let s3 = "";
          this.relativeOffset += e3;
          for (let o3 = 0; o3 < e3; o3++)
            s3 += String.fromCharCode(t3.getUint8(n3 + o3));
          return s3;
        }, _.prototype.parseTag = function() {
          return this.parseString(4);
        }, _.prototype.parseLongDateTime = function() {
          let e3 = G(this.data, this.offset + this.relativeOffset + 4);
          return e3 -= 2082844800, this.relativeOffset += 8, e3;
        }, _.prototype.parseVersion = function(e3) {
          const t3 = P(this.data, this.offset + this.relativeOffset), n3 = P(this.data, this.offset + this.relativeOffset + 2);
          return this.relativeOffset += 4, void 0 === e3 && (e3 = 4096), t3 + n3 / e3 / 10;
        }, _.prototype.skip = function(e3, t3) {
          void 0 === t3 && (t3 = 1), this.relativeOffset += F[e3] * t3;
        }, _.prototype.parseULongList = function(e3) {
          void 0 === e3 && (e3 = this.parseULong());
          const t3 = new Array(e3), n3 = this.data;
          let s3 = this.offset + this.relativeOffset;
          for (let o3 = 0; o3 < e3; o3++)
            t3[o3] = n3.getUint32(s3), s3 += 4;
          return this.relativeOffset += 4 * e3, t3;
        }, _.prototype.parseOffset16List = _.prototype.parseUShortList = function(e3) {
          void 0 === e3 && (e3 = this.parseUShort());
          const t3 = new Array(e3), n3 = this.data;
          let s3 = this.offset + this.relativeOffset;
          for (let o3 = 0; o3 < e3; o3++)
            t3[o3] = n3.getUint16(s3), s3 += 2;
          return this.relativeOffset += 2 * e3, t3;
        }, _.prototype.parseShortList = function(e3) {
          const t3 = new Array(e3), n3 = this.data;
          let s3 = this.offset + this.relativeOffset;
          for (let o3 = 0; o3 < e3; o3++)
            t3[o3] = n3.getInt16(s3), s3 += 2;
          return this.relativeOffset += 2 * e3, t3;
        }, _.prototype.parseByteList = function(e3) {
          const t3 = new Array(e3), n3 = this.data;
          let s3 = this.offset + this.relativeOffset;
          for (let o3 = 0; o3 < e3; o3++)
            t3[o3] = n3.getUint8(s3++);
          return this.relativeOffset += e3, t3;
        }, _.prototype.parseList = function(e3, t3) {
          t3 || (t3 = e3, e3 = this.parseUShort());
          const n3 = new Array(e3);
          for (let s3 = 0; s3 < e3; s3++)
            n3[s3] = t3.call(this);
          return n3;
        }, _.prototype.parseList32 = function(e3, t3) {
          t3 || (t3 = e3, e3 = this.parseULong());
          const n3 = new Array(e3);
          for (let s3 = 0; s3 < e3; s3++)
            n3[s3] = t3.call(this);
          return n3;
        }, _.prototype.parseRecordList = function(e3, t3) {
          t3 || (t3 = e3, e3 = this.parseUShort());
          const n3 = new Array(e3), s3 = Object.keys(t3);
          for (let o3 = 0; o3 < e3; o3++) {
            const e4 = {};
            for (let n4 = 0; n4 < s3.length; n4++) {
              const o4 = s3[n4], r3 = t3[o4];
              e4[o4] = r3.call(this);
            }
            n3[o3] = e4;
          }
          return n3;
        }, _.prototype.parseRecordList32 = function(e3, t3) {
          t3 || (t3 = e3, e3 = this.parseULong());
          const n3 = new Array(e3), s3 = Object.keys(t3);
          for (let o3 = 0; o3 < e3; o3++) {
            const e4 = {};
            for (let n4 = 0; n4 < s3.length; n4++) {
              const o4 = s3[n4], r3 = t3[o4];
              e4[o4] = r3.call(this);
            }
            n3[o3] = e4;
          }
          return n3;
        }, _.prototype.parseStruct = function(e3) {
          if ("function" == typeof e3)
            return e3.call(this);
          {
            const t3 = Object.keys(e3), n3 = {};
            for (let s3 = 0; s3 < t3.length; s3++) {
              const o3 = t3[s3], r3 = e3[o3];
              n3[o3] = r3.call(this);
            }
            return n3;
          }
        }, _.prototype.parseValueRecord = function(e3) {
          if (void 0 === e3 && (e3 = this.parseUShort()), 0 === e3)
            return;
          const t3 = {};
          return 1 & e3 && (t3.xPlacement = this.parseShort()), 2 & e3 && (t3.yPlacement = this.parseShort()), 4 & e3 && (t3.xAdvance = this.parseShort()), 8 & e3 && (t3.yAdvance = this.parseShort()), 16 & e3 && (t3.xPlaDevice = void 0, this.parseShort()), 32 & e3 && (t3.yPlaDevice = void 0, this.parseShort()), 64 & e3 && (t3.xAdvDevice = void 0, this.parseShort()), 128 & e3 && (t3.yAdvDevice = void 0, this.parseShort()), t3;
        }, _.prototype.parseValueRecordList = function() {
          const e3 = this.parseUShort(), t3 = this.parseUShort(), n3 = new Array(t3);
          for (let s3 = 0; s3 < t3; s3++)
            n3[s3] = this.parseValueRecord(e3);
          return n3;
        }, _.prototype.parsePointer = function(e3) {
          const t3 = this.parseOffset16();
          if (t3 > 0)
            return new _(this.data, this.offset + t3).parseStruct(e3);
        }, _.prototype.parsePointer32 = function(e3) {
          const t3 = this.parseOffset32();
          if (t3 > 0)
            return new _(this.data, this.offset + t3).parseStruct(e3);
        }, _.prototype.parseListOfLists = function(e3) {
          const t3 = this.parseOffset16List(), n3 = t3.length, s3 = this.relativeOffset, o3 = new Array(n3);
          for (let s4 = 0; s4 < n3; s4++) {
            const n4 = t3[s4];
            if (0 !== n4)
              if (this.relativeOffset = n4, e3) {
                const t4 = this.parseOffset16List(), r3 = new Array(t4.length);
                for (let s5 = 0; s5 < t4.length; s5++)
                  this.relativeOffset = n4 + t4[s5], r3[s5] = e3.call(this);
                o3[s4] = r3;
              } else
                o3[s4] = this.parseUShortList();
            else
              o3[s4] = void 0;
          }
          return this.relativeOffset = s3, o3;
        }, _.prototype.parseCoverage = function() {
          const e3 = this.offset + this.relativeOffset, t3 = this.parseUShort(), n3 = this.parseUShort();
          if (1 === t3)
            return { format: 1, glyphs: this.parseUShortList(n3) };
          if (2 === t3) {
            const e4 = new Array(n3);
            for (let t4 = 0; t4 < n3; t4++)
              e4[t4] = { start: this.parseUShort(), end: this.parseUShort(), index: this.parseUShort() };
            return { format: 2, ranges: e4 };
          }
          throw new Error("0x" + e3.toString(16) + ": Coverage format must be 1 or 2.");
        }, _.prototype.parseClassDef = function() {
          const e3 = this.offset + this.relativeOffset, t3 = this.parseUShort();
          if (1 === t3)
            return { format: 1, startGlyph: this.parseUShort(), classes: this.parseUShortList() };
          if (2 === t3)
            return { format: 2, ranges: this.parseRecordList({ start: _.uShort, end: _.uShort, classId: _.uShort }) };
          throw new Error("0x" + e3.toString(16) + ": ClassDef format must be 1 or 2.");
        }, _.list = function(e3, t3) {
          return function() {
            return this.parseList(e3, t3);
          };
        }, _.list32 = function(e3, t3) {
          return function() {
            return this.parseList32(e3, t3);
          };
        }, _.recordList = function(e3, t3) {
          return function() {
            return this.parseRecordList(e3, t3);
          };
        }, _.recordList32 = function(e3, t3) {
          return function() {
            return this.parseRecordList32(e3, t3);
          };
        }, _.pointer = function(e3) {
          return function() {
            return this.parsePointer(e3);
          };
        }, _.pointer32 = function(e3) {
          return function() {
            return this.parsePointer32(e3);
          };
        }, _.tag = _.prototype.parseTag, _.byte = _.prototype.parseByte, _.uShort = _.offset16 = _.prototype.parseUShort, _.uShortList = _.prototype.parseUShortList, _.uLong = _.offset32 = _.prototype.parseULong, _.uLongList = _.prototype.parseULongList, _.struct = _.prototype.parseStruct, _.coverage = _.prototype.parseCoverage, _.classDef = _.prototype.parseClassDef;
        const H = { reserved: _.uShort, reqFeatureIndex: _.uShort, featureIndexes: _.uShortList };
        _.prototype.parseScriptList = function() {
          return this.parsePointer(_.recordList({ tag: _.tag, script: _.pointer({ defaultLangSys: _.pointer(H), langSysRecords: _.recordList({ tag: _.tag, langSys: _.pointer(H) }) }) })) || [];
        }, _.prototype.parseFeatureList = function() {
          return this.parsePointer(_.recordList({ tag: _.tag, feature: _.pointer({ featureParams: _.offset16, lookupListIndexes: _.uShortList }) })) || [];
        }, _.prototype.parseLookupList = function(e3) {
          return this.parsePointer(_.list(_.pointer(function() {
            const t3 = this.parseUShort();
            f.argument(1 <= t3 && t3 <= 9, "GPOS/GSUB lookup type " + t3 + " unknown.");
            const n3 = this.parseUShort(), s3 = 16 & n3;
            return { lookupType: t3, lookupFlag: n3, subtables: this.parseList(_.pointer(e3[t3])), markFilteringSet: s3 ? this.parseUShort() : void 0 };
          }))) || [];
        }, _.prototype.parseFeatureVariationsList = function() {
          return this.parsePointer32(function() {
            const e3 = this.parseUShort(), t3 = this.parseUShort();
            return f.argument(1 === e3 && t3 < 1, "GPOS/GSUB feature variations table unknown."), this.parseRecordList32({ conditionSetOffset: _.offset32, featureTableSubstitutionOffset: _.offset32 });
          }) || [];
        };
        const z = { getByte: A, getCard8: A, getUShort: P, getCard16: P, getShort: function(e3, t3) {
          return e3.getInt16(t3, false);
        }, getULong: G, getFixed: N, getTag: function(e3, t3) {
          let n3 = "";
          for (let s3 = t3; s3 < t3 + 4; s3 += 1)
            n3 += String.fromCharCode(e3.getInt8(s3));
          return n3;
        }, getOffset: function(e3, t3, n3) {
          let s3 = 0;
          for (let o3 = 0; o3 < n3; o3 += 1)
            s3 <<= 8, s3 += e3.getUint8(t3 + o3);
          return s3;
        }, getBytes: function(e3, t3, n3) {
          const s3 = [];
          for (let o3 = t3; o3 < n3; o3 += 1)
            s3.push(e3.getUint8(o3));
          return s3;
        }, bytesToString: function(e3) {
          let t3 = "";
          for (let n3 = 0; n3 < e3.length; n3 += 1)
            t3 += String.fromCharCode(e3[n3]);
          return t3;
        }, Parser: _ };
        function W(e3, t3, n3) {
          e3.segments.push({ end: t3, start: t3, delta: -(t3 - n3), offset: 0, glyphIndex: n3 });
        }
        const q = { parse: function(e3, t3) {
          const n3 = {};
          n3.version = z.getUShort(e3, t3), f.argument(0 === n3.version, "cmap table version should be 0."), n3.numTables = z.getUShort(e3, t3 + 2);
          let s3 = -1;
          for (let o4 = n3.numTables - 1; o4 >= 0; o4 -= 1) {
            const n4 = z.getUShort(e3, t3 + 4 + 8 * o4), r3 = z.getUShort(e3, t3 + 4 + 8 * o4 + 2);
            if (3 === n4 && (0 === r3 || 1 === r3 || 10 === r3)) {
              s3 = z.getULong(e3, t3 + 4 + 8 * o4 + 4);
              break;
            }
          }
          if (-1 === s3)
            throw new Error("No valid cmap sub-tables found.");
          const o3 = new z.Parser(e3, t3 + s3);
          if (n3.format = o3.parseUShort(), 12 === n3.format)
            !function(e4, t4) {
              let n4;
              t4.parseUShort(), e4.length = t4.parseULong(), e4.language = t4.parseULong(), e4.groupCount = n4 = t4.parseULong(), e4.glyphIndexMap = {};
              for (let s4 = 0; s4 < n4; s4 += 1) {
                const n5 = t4.parseULong(), s5 = t4.parseULong();
                let o4 = t4.parseULong();
                for (let t5 = n5; t5 <= s5; t5 += 1)
                  e4.glyphIndexMap[t5] = o4, o4++;
              }
            }(n3, o3);
          else {
            if (4 !== n3.format)
              throw new Error("Only format 4 and 12 cmap tables are supported (found format " + n3.format + ").");
            !function(e4, t4, n4, s4, o4) {
              let r3;
              e4.length = t4.parseUShort(), e4.language = t4.parseUShort(), e4.segCount = r3 = t4.parseUShort() >> 1, t4.skip("uShort", 3), e4.glyphIndexMap = {};
              const a3 = new z.Parser(n4, s4 + o4 + 14), i3 = new z.Parser(n4, s4 + o4 + 16 + 2 * r3), l2 = new z.Parser(n4, s4 + o4 + 16 + 4 * r3), u2 = new z.Parser(n4, s4 + o4 + 16 + 6 * r3);
              let c2 = s4 + o4 + 16 + 8 * r3;
              for (let t5 = 0; t5 < r3 - 1; t5 += 1) {
                let t6;
                const s5 = a3.parseUShort(), o5 = i3.parseUShort(), r4 = l2.parseShort(), p2 = u2.parseUShort();
                for (let a4 = o5; a4 <= s5; a4 += 1)
                  0 !== p2 ? (c2 = u2.offset + u2.relativeOffset - 2, c2 += p2, c2 += 2 * (a4 - o5), t6 = z.getUShort(n4, c2), 0 !== t6 && (t6 = t6 + r4 & 65535)) : t6 = a4 + r4 & 65535, e4.glyphIndexMap[a4] = t6;
              }
            }(n3, o3, e3, t3, s3);
          }
          return n3;
        }, make: function(e3) {
          let t3, n3 = true;
          for (t3 = e3.length - 1; t3 > 0; t3 -= 1)
            if (e3.get(t3).unicode > 65535) {
              console.log("Adding CMAP format 12 (needed!)"), n3 = false;
              break;
            }
          let s3 = [{ name: "version", type: "USHORT", value: 0 }, { name: "numTables", type: "USHORT", value: n3 ? 1 : 2 }, { name: "platformID", type: "USHORT", value: 3 }, { name: "encodingID", type: "USHORT", value: 1 }, { name: "offset", type: "ULONG", value: n3 ? 12 : 20 }];
          n3 || (s3 = s3.concat([{ name: "cmap12PlatformID", type: "USHORT", value: 3 }, { name: "cmap12EncodingID", type: "USHORT", value: 10 }, { name: "cmap12Offset", type: "ULONG", value: 0 }])), s3 = s3.concat([{ name: "format", type: "USHORT", value: 4 }, { name: "cmap4Length", type: "USHORT", value: 0 }, { name: "language", type: "USHORT", value: 0 }, { name: "segCountX2", type: "USHORT", value: 0 }, { name: "searchRange", type: "USHORT", value: 0 }, { name: "entrySelector", type: "USHORT", value: 0 }, { name: "rangeShift", type: "USHORT", value: 0 }]);
          const o3 = new M.Table("cmap", s3);
          for (o3.segments = [], t3 = 0; t3 < e3.length; t3 += 1) {
            const n4 = e3.get(t3);
            for (let e4 = 0; e4 < n4.unicodes.length; e4 += 1)
              W(o3, n4.unicodes[e4], t3);
            o3.segments = o3.segments.sort(function(e4, t4) {
              return e4.start - t4.start;
            });
          }
          !function(e4) {
            e4.segments.push({ end: 65535, start: 65535, delta: 1, offset: 0 });
          }(o3);
          const r3 = o3.segments.length;
          let a3 = 0, i3 = [], l2 = [], u2 = [], c2 = [], p2 = [], f2 = [];
          for (t3 = 0; t3 < r3; t3 += 1) {
            const e4 = o3.segments[t3];
            e4.end <= 65535 && e4.start <= 65535 ? (i3 = i3.concat({ name: "end_" + t3, type: "USHORT", value: e4.end }), l2 = l2.concat({ name: "start_" + t3, type: "USHORT", value: e4.start }), u2 = u2.concat({ name: "idDelta_" + t3, type: "SHORT", value: e4.delta }), c2 = c2.concat({ name: "idRangeOffset_" + t3, type: "USHORT", value: e4.offset }), void 0 !== e4.glyphId && (p2 = p2.concat({ name: "glyph_" + t3, type: "USHORT", value: e4.glyphId }))) : a3 += 1, n3 || void 0 === e4.glyphIndex || (f2 = f2.concat({ name: "cmap12Start_" + t3, type: "ULONG", value: e4.start }), f2 = f2.concat({ name: "cmap12End_" + t3, type: "ULONG", value: e4.end }), f2 = f2.concat({ name: "cmap12Glyph_" + t3, type: "ULONG", value: e4.glyphIndex }));
          }
          if (o3.segCountX2 = 2 * (r3 - a3), o3.searchRange = 2 * Math.pow(2, Math.floor(Math.log(r3 - a3) / Math.log(2))), o3.entrySelector = Math.log(o3.searchRange / 2) / Math.log(2), o3.rangeShift = o3.segCountX2 - o3.searchRange, o3.fields = o3.fields.concat(i3), o3.fields.push({ name: "reservedPad", type: "USHORT", value: 0 }), o3.fields = o3.fields.concat(l2), o3.fields = o3.fields.concat(u2), o3.fields = o3.fields.concat(c2), o3.fields = o3.fields.concat(p2), o3.cmap4Length = 14 + 2 * i3.length + 2 + 2 * l2.length + 2 * u2.length + 2 * c2.length + 2 * p2.length, !n3) {
            const e4 = 16 + 4 * f2.length;
            o3.cmap12Offset = 20 + o3.cmap4Length, o3.fields = o3.fields.concat([{ name: "cmap12Format", type: "USHORT", value: 12 }, { name: "cmap12Reserved", type: "USHORT", value: 0 }, { name: "cmap12Length", type: "ULONG", value: e4 }, { name: "cmap12Language", type: "ULONG", value: 0 }, { name: "cmap12nGroups", type: "ULONG", value: f2.length / 3 }]), o3.fields = o3.fields.concat(f2);
          }
          return o3;
        } }, j = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "266 ff", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"], X = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls"], V = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"], Y = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
        function Z(e3) {
          this.font = e3;
        }
        function Q(e3) {
          this.cmap = e3;
        }
        function J(e3, t3) {
          this.encoding = e3, this.charset = t3;
        }
        function K(e3) {
          switch (e3.version) {
            case 1:
              this.names = Y.slice();
              break;
            case 2:
              this.names = new Array(e3.numberOfGlyphs);
              for (let t3 = 0; t3 < e3.numberOfGlyphs; t3++)
                e3.glyphNameIndex[t3] < Y.length ? this.names[t3] = Y[e3.glyphNameIndex[t3]] : this.names[t3] = e3.names[e3.glyphNameIndex[t3] - Y.length];
              break;
            case 2.5:
              this.names = new Array(e3.numberOfGlyphs);
              for (let t3 = 0; t3 < e3.numberOfGlyphs; t3++)
                this.names[t3] = Y[t3 + e3.glyphNameIndex[t3]];
              break;
            default:
              this.names = [];
          }
        }
        Z.prototype.charToGlyphIndex = function(e3) {
          const t3 = e3.charCodeAt(0), n3 = this.font.glyphs;
          if (n3)
            for (let e4 = 0; e4 < n3.length; e4 += 1) {
              const s3 = n3.get(e4);
              for (let n4 = 0; n4 < s3.unicodes.length; n4 += 1)
                if (s3.unicodes[n4] === t3)
                  return e4;
            }
          return null;
        }, Q.prototype.charToGlyphIndex = function(e3) {
          return this.cmap.glyphIndexMap[e3.charCodeAt(0)] || 0;
        }, J.prototype.charToGlyphIndex = function(e3) {
          const t3 = e3.charCodeAt(0), n3 = this.encoding[t3];
          return this.charset.indexOf(n3);
        }, K.prototype.nameToGlyphIndex = function(e3) {
          return this.names.indexOf(e3);
        }, K.prototype.glyphIndexToName = function(e3) {
          return this.names[e3];
        };
        const $ = function(e3, t3, n3, s3, o3) {
          e3.beginPath(), e3.moveTo(t3, n3), e3.lineTo(s3, o3), e3.stroke();
        };
        function ee(e3, t3, n3, s3, o3) {
          let r3;
          return (t3 & s3) > 0 ? (r3 = e3.parseByte(), 0 == (t3 & o3) && (r3 = -r3), r3 = n3 + r3) : r3 = (t3 & o3) > 0 ? n3 : n3 + e3.parseShort(), r3;
        }
        function te(e3, t3, n3) {
          const s3 = new z.Parser(t3, n3);
          let o3, r3;
          if (e3.numberOfContours = s3.parseShort(), e3._xMin = s3.parseShort(), e3._yMin = s3.parseShort(), e3._xMax = s3.parseShort(), e3._yMax = s3.parseShort(), e3.numberOfContours > 0) {
            const t4 = e3.endPointIndices = [];
            for (let n5 = 0; n5 < e3.numberOfContours; n5 += 1)
              t4.push(s3.parseUShort());
            e3.instructionLength = s3.parseUShort(), e3.instructions = [];
            for (let t5 = 0; t5 < e3.instructionLength; t5 += 1)
              e3.instructions.push(s3.parseByte());
            const n4 = t4[t4.length - 1] + 1;
            o3 = [];
            for (let e4 = 0; e4 < n4; e4 += 1)
              if (r3 = s3.parseByte(), o3.push(r3), (8 & r3) > 0) {
                const t5 = s3.parseByte();
                for (let n5 = 0; n5 < t5; n5 += 1)
                  o3.push(r3), e4 += 1;
              }
            if (f.argument(o3.length === n4, "Bad flags."), t4.length > 0) {
              const a3 = [];
              let i3;
              if (n4 > 0) {
                for (let e5 = 0; e5 < n4; e5 += 1)
                  r3 = o3[e5], i3 = {}, i3.onCurve = !!(1 & r3), i3.lastPointOfContour = t4.indexOf(e5) >= 0, a3.push(i3);
                let e4 = 0;
                for (let t5 = 0; t5 < n4; t5 += 1)
                  r3 = o3[t5], i3 = a3[t5], i3.x = ee(s3, r3, e4, 2, 16), e4 = i3.x;
                let l2 = 0;
                for (let e5 = 0; e5 < n4; e5 += 1)
                  r3 = o3[e5], i3 = a3[e5], i3.y = ee(s3, r3, l2, 4, 32), l2 = i3.y;
              }
              e3.points = a3;
            } else
              e3.points = [];
          } else if (0 === e3.numberOfContours)
            e3.points = [];
          else {
            e3.isComposite = true, e3.points = [], e3.components = [];
            let t4 = true;
            for (; t4; ) {
              o3 = s3.parseUShort();
              const n4 = { glyphIndex: s3.parseUShort(), xScale: 1, scale01: 0, scale10: 0, yScale: 1, dx: 0, dy: 0 };
              (1 & o3) > 0 ? (2 & o3) > 0 ? (n4.dx = s3.parseShort(), n4.dy = s3.parseShort()) : n4.matchedPoints = [s3.parseUShort(), s3.parseUShort()] : (2 & o3) > 0 ? (n4.dx = s3.parseChar(), n4.dy = s3.parseChar()) : n4.matchedPoints = [s3.parseByte(), s3.parseByte()], (8 & o3) > 0 ? n4.xScale = n4.yScale = s3.parseF2Dot14() : (64 & o3) > 0 ? (n4.xScale = s3.parseF2Dot14(), n4.yScale = s3.parseF2Dot14()) : (128 & o3) > 0 && (n4.xScale = s3.parseF2Dot14(), n4.scale01 = s3.parseF2Dot14(), n4.scale10 = s3.parseF2Dot14(), n4.yScale = s3.parseF2Dot14()), e3.components.push(n4), t4 = !!(32 & o3);
            }
            if (256 & o3) {
              e3.instructionLength = s3.parseUShort(), e3.instructions = [];
              for (let t5 = 0; t5 < e3.instructionLength; t5 += 1)
                e3.instructions.push(s3.parseByte());
            }
          }
        }
        function ne(e3, t3) {
          const n3 = [];
          for (let s3 = 0; s3 < e3.length; s3 += 1) {
            const o3 = e3[s3], r3 = { x: t3.xScale * o3.x + t3.scale01 * o3.y + t3.dx, y: t3.scale10 * o3.x + t3.yScale * o3.y + t3.dy, onCurve: o3.onCurve, lastPointOfContour: o3.lastPointOfContour };
            n3.push(r3);
          }
          return n3;
        }
        function se(e3) {
          const t3 = new u();
          if (!e3)
            return t3;
          const n3 = function(e4) {
            const t4 = [];
            let n4 = [];
            for (let s3 = 0; s3 < e4.length; s3 += 1) {
              const o3 = e4[s3];
              n4.push(o3), o3.lastPointOfContour && (t4.push(n4), n4 = []);
            }
            return f.argument(0 === n4.length, "There are still points left in the current contour."), t4;
          }(e3);
          for (let e4 = 0; e4 < n3.length; ++e4) {
            const s3 = n3[e4];
            let o3 = null, r3 = s3[s3.length - 1], a3 = s3[0];
            if (r3.onCurve)
              t3.moveTo(r3.x, r3.y);
            else if (a3.onCurve)
              t3.moveTo(a3.x, a3.y);
            else {
              const e5 = { x: 0.5 * (r3.x + a3.x), y: 0.5 * (r3.y + a3.y) };
              t3.moveTo(e5.x, e5.y);
            }
            for (let e5 = 0; e5 < s3.length; ++e5)
              if (o3 = r3, r3 = a3, a3 = s3[(e5 + 1) % s3.length], r3.onCurve)
                t3.lineTo(r3.x, r3.y);
              else {
                let e6 = o3, n4 = a3;
                o3.onCurve || (e6 = { x: 0.5 * (r3.x + o3.x), y: 0.5 * (r3.y + o3.y) }, t3.lineTo(e6.x, e6.y)), a3.onCurve || (n4 = { x: 0.5 * (r3.x + a3.x), y: 0.5 * (r3.y + a3.y) }), t3.lineTo(e6.x, e6.y), t3.quadraticCurveTo(r3.x, r3.y, n4.x, n4.y);
              }
            t3.closePath();
          }
          return t3;
        }
        function oe(e3, t3) {
          if (t3.isComposite)
            for (let n3 = 0; n3 < t3.components.length; n3 += 1) {
              const s3 = t3.components[n3], o3 = e3.get(s3.glyphIndex);
              if (o3.getPath(), o3.points) {
                let e4;
                if (void 0 === s3.matchedPoints)
                  e4 = ne(o3.points, s3);
                else {
                  if (s3.matchedPoints[0] > t3.points.length - 1 || s3.matchedPoints[1] > o3.points.length - 1)
                    throw Error("Matched points out of range in " + t3.name);
                  const n4 = t3.points[s3.matchedPoints[0]];
                  let r3 = o3.points[s3.matchedPoints[1]];
                  const a3 = { xScale: s3.xScale, scale01: s3.scale01, scale10: s3.scale10, yScale: s3.yScale, dx: 0, dy: 0 };
                  r3 = ne([r3], a3)[0], a3.dx = n4.x - r3.x, a3.dy = n4.y - r3.y, e4 = ne(o3.points, a3);
                }
                t3.points = t3.points.concat(e4);
              }
            }
          return se(t3.points);
        }
        const re = { getPath: se, parse: function(e3, t3, n3, s3) {
          const o3 = new ce.GlyphSet(s3);
          for (let r3 = 0; r3 < n3.length - 1; r3 += 1) {
            const a3 = n3[r3];
            a3 !== n3[r3 + 1] ? o3.push(r3, ce.ttfGlyphLoader(s3, r3, te, e3, t3 + a3, oe)) : o3.push(r3, ce.glyphLoader(s3, r3));
          }
          return o3;
        } };
        function ae(e3) {
          this.bindConstructorValues(e3);
        }
        ae.prototype.bindConstructorValues = function(e3) {
          this.index = e3.index || 0, this.name = e3.name || null, this.unicode = e3.unicode || void 0, this.unicodes = e3.unicodes || void 0 !== e3.unicode ? [e3.unicode] : [], e3.xMin && (this.xMin = e3.xMin), e3.yMin && (this.yMin = e3.yMin), e3.xMax && (this.xMax = e3.xMax), e3.yMax && (this.yMax = e3.yMax), e3.advanceWidth && (this.advanceWidth = e3.advanceWidth), Object.defineProperty(this, "path", function(e4, t3) {
            let n3 = t3 || new u();
            return { configurable: true, get: function() {
              return "function" == typeof n3 && (n3 = n3()), n3;
            }, set: function(e5) {
              n3 = e5;
            } };
          }(0, e3.path));
        }, ae.prototype.addUnicode = function(e3) {
          0 === this.unicodes.length && (this.unicode = e3), this.unicodes.push(e3);
        }, ae.prototype.getBoundingBox = function() {
          return this.path.getBoundingBox();
        }, ae.prototype.getPath = function(e3, t3, n3, s3, o3) {
          let r3, a3;
          e3 = void 0 !== e3 ? e3 : 0, t3 = void 0 !== t3 ? t3 : 0, n3 = void 0 !== n3 ? n3 : 72, s3 || (s3 = {});
          let i3 = s3.xScale, l2 = s3.yScale;
          if (s3.hinting && o3 && o3.hinting && (a3 = this.path && o3.hinting.exec(this, n3)), a3)
            r3 = re.getPath(a3).commands, e3 = Math.round(e3), t3 = Math.round(t3), i3 = l2 = 1;
          else {
            r3 = this.path.commands;
            const e4 = 1 / this.path.unitsPerEm * n3;
            void 0 === i3 && (i3 = e4), void 0 === l2 && (l2 = e4);
          }
          const c2 = new u();
          for (let n4 = 0; n4 < r3.length; n4 += 1) {
            const s4 = r3[n4];
            "M" === s4.type ? c2.moveTo(e3 + s4.x * i3, t3 + -s4.y * l2) : "L" === s4.type ? c2.lineTo(e3 + s4.x * i3, t3 + -s4.y * l2) : "Q" === s4.type ? c2.quadraticCurveTo(e3 + s4.x1 * i3, t3 + -s4.y1 * l2, e3 + s4.x * i3, t3 + -s4.y * l2) : "C" === s4.type ? c2.curveTo(e3 + s4.x1 * i3, t3 + -s4.y1 * l2, e3 + s4.x2 * i3, t3 + -s4.y2 * l2, e3 + s4.x * i3, t3 + -s4.y * l2) : "Z" === s4.type && c2.closePath();
          }
          return c2;
        }, ae.prototype.getContours = function() {
          if (void 0 === this.points)
            return [];
          const e3 = [];
          let t3 = [];
          for (let n3 = 0; n3 < this.points.length; n3 += 1) {
            const s3 = this.points[n3];
            t3.push(s3), s3.lastPointOfContour && (e3.push(t3), t3 = []);
          }
          return f.argument(0 === t3.length, "There are still points left in the current contour."), e3;
        }, ae.prototype.getMetrics = function() {
          const e3 = this.path.commands, t3 = [], n3 = [];
          for (let s4 = 0; s4 < e3.length; s4 += 1) {
            const o3 = e3[s4];
            "Z" !== o3.type && (t3.push(o3.x), n3.push(o3.y)), "Q" !== o3.type && "C" !== o3.type || (t3.push(o3.x1), n3.push(o3.y1)), "C" === o3.type && (t3.push(o3.x2), n3.push(o3.y2));
          }
          const s3 = { xMin: Math.min.apply(null, t3), yMin: Math.min.apply(null, n3), xMax: Math.max.apply(null, t3), yMax: Math.max.apply(null, n3), leftSideBearing: this.leftSideBearing };
          return isFinite(s3.xMin) || (s3.xMin = 0), isFinite(s3.xMax) || (s3.xMax = this.advanceWidth), isFinite(s3.yMin) || (s3.yMin = 0), isFinite(s3.yMax) || (s3.yMax = 0), s3.rightSideBearing = this.advanceWidth - s3.leftSideBearing - (s3.xMax - s3.xMin), s3;
        }, ae.prototype.draw = function(e3, t3, n3, s3, o3) {
          this.getPath(t3, n3, s3, o3).draw(e3);
        }, ae.prototype.drawPoints = function(e3, t3, n3, s3) {
          function o3(t4, n4, s4, o4) {
            const r4 = 2 * Math.PI;
            e3.beginPath();
            for (let a4 = 0; a4 < t4.length; a4 += 1)
              e3.moveTo(n4 + t4[a4].x * o4, s4 + t4[a4].y * o4), e3.arc(n4 + t4[a4].x * o4, s4 + t4[a4].y * o4, 2, 0, r4, false);
            e3.closePath(), e3.fill();
          }
          t3 = void 0 !== t3 ? t3 : 0, n3 = void 0 !== n3 ? n3 : 0, s3 = void 0 !== s3 ? s3 : 24;
          const r3 = 1 / this.path.unitsPerEm * s3, a3 = [], i3 = [], l2 = this.path;
          for (let e4 = 0; e4 < l2.commands.length; e4 += 1) {
            const t4 = l2.commands[e4];
            void 0 !== t4.x && a3.push({ x: t4.x, y: -t4.y }), void 0 !== t4.x1 && i3.push({ x: t4.x1, y: -t4.y1 }), void 0 !== t4.x2 && i3.push({ x: t4.x2, y: -t4.y2 });
          }
          e3.fillStyle = "blue", o3(a3, t3, n3, r3), e3.fillStyle = "red", o3(i3, t3, n3, r3);
        }, ae.prototype.drawMetrics = function(e3, t3, n3, s3) {
          let o3;
          t3 = void 0 !== t3 ? t3 : 0, n3 = void 0 !== n3 ? n3 : 0, s3 = void 0 !== s3 ? s3 : 24, o3 = 1 / this.path.unitsPerEm * s3, e3.lineWidth = 1, e3.strokeStyle = "black", $(e3, t3, -1e4, t3, 1e4), $(e3, -1e4, n3, 1e4, n3);
          const r3 = this.xMin || 0;
          let a3 = this.yMin || 0;
          const i3 = this.xMax || 0;
          let l2 = this.yMax || 0;
          const u2 = this.advanceWidth || 0;
          e3.strokeStyle = "blue", $(e3, t3 + r3 * o3, -1e4, t3 + r3 * o3, 1e4), $(e3, t3 + i3 * o3, -1e4, t3 + i3 * o3, 1e4), $(e3, -1e4, n3 + -a3 * o3, 1e4, n3 + -a3 * o3), $(e3, -1e4, n3 + -l2 * o3, 1e4, n3 + -l2 * o3), e3.strokeStyle = "green", $(e3, t3 + u2 * o3, -1e4, t3 + u2 * o3, 1e4);
        };
        const ie = ae;
        function le(e3, t3, n3) {
          Object.defineProperty(e3, t3, { get: function() {
            return e3.path, e3[n3];
          }, set: function(t4) {
            e3[n3] = t4;
          }, enumerable: true, configurable: true });
        }
        function ue(e3, t3) {
          if (this.font = e3, this.glyphs = {}, Array.isArray(t3))
            for (let e4 = 0; e4 < t3.length; e4++)
              this.glyphs[e4] = t3[e4];
          this.length = t3 && t3.length || 0;
        }
        ue.prototype.get = function(e3) {
          return "function" == typeof this.glyphs[e3] && (this.glyphs[e3] = this.glyphs[e3]()), this.glyphs[e3];
        }, ue.prototype.push = function(e3, t3) {
          this.glyphs[e3] = t3, this.length++;
        };
        const ce = { GlyphSet: ue, glyphLoader: function(e3, t3) {
          return new ie({ index: t3, font: e3 });
        }, ttfGlyphLoader: function(e3, t3, n3, s3, o3, r3) {
          return function() {
            const a3 = new ie({ index: t3, font: e3 });
            return a3.path = function() {
              n3(a3, s3, o3);
              const t4 = r3(e3.glyphs, a3);
              return t4.unitsPerEm = e3.unitsPerEm, t4;
            }, le(a3, "xMin", "_xMin"), le(a3, "xMax", "_xMax"), le(a3, "yMin", "_yMin"), le(a3, "yMax", "_yMax"), a3;
          };
        }, cffGlyphLoader: function(e3, t3, n3, s3) {
          return function() {
            const o3 = new ie({ index: t3, font: e3 });
            return o3.path = function() {
              const t4 = n3(e3, o3, s3);
              return t4.unitsPerEm = e3.unitsPerEm, t4;
            }, o3;
          };
        } };
        function pe(e3, t3) {
          if (e3 === t3)
            return true;
          if (Array.isArray(e3) && Array.isArray(t3)) {
            if (e3.length !== t3.length)
              return false;
            for (let n3 = 0; n3 < e3.length; n3 += 1)
              if (!pe(e3[n3], t3[n3]))
                return false;
            return true;
          }
          return false;
        }
        function fe(e3) {
          let t3;
          return t3 = e3.length < 1240 ? 107 : e3.length < 33900 ? 1131 : 32768, t3;
        }
        function he(e3, t3, n3) {
          const s3 = [], o3 = [], r3 = z.getCard16(e3, t3);
          let a3, i3;
          if (0 !== r3) {
            const n4 = z.getByte(e3, t3 + 2);
            a3 = t3 + (r3 + 1) * n4 + 2;
            let o4 = t3 + 3;
            for (let t4 = 0; t4 < r3 + 1; t4 += 1)
              s3.push(z.getOffset(e3, o4, n4)), o4 += n4;
            i3 = a3 + s3[r3];
          } else
            i3 = t3 + 2;
          for (let t4 = 0; t4 < s3.length - 1; t4 += 1) {
            let r4 = z.getBytes(e3, a3 + s3[t4], a3 + s3[t4 + 1]);
            n3 && (r4 = n3(r4)), o3.push(r4);
          }
          return { objects: o3, startOffset: t3, endOffset: i3 };
        }
        function de(e3, t3) {
          let n3, s3, o3, r3;
          if (28 === t3)
            return n3 = e3.parseByte(), s3 = e3.parseByte(), n3 << 8 | s3;
          if (29 === t3)
            return n3 = e3.parseByte(), s3 = e3.parseByte(), o3 = e3.parseByte(), r3 = e3.parseByte(), n3 << 24 | s3 << 16 | o3 << 8 | r3;
          if (30 === t3)
            return function(e4) {
              let t4 = "";
              const n4 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];
              for (; ; ) {
                const s4 = e4.parseByte(), o4 = s4 >> 4, r4 = 15 & s4;
                if (15 === o4)
                  break;
                if (t4 += n4[o4], 15 === r4)
                  break;
                t4 += n4[r4];
              }
              return parseFloat(t4);
            }(e3);
          if (t3 >= 32 && t3 <= 246)
            return t3 - 139;
          if (t3 >= 247 && t3 <= 250)
            return n3 = e3.parseByte(), 256 * (t3 - 247) + n3 + 108;
          if (t3 >= 251 && t3 <= 254)
            return n3 = e3.parseByte(), 256 * -(t3 - 251) - n3 - 108;
          throw new Error("Invalid b0 " + t3);
        }
        function ge(e3, t3, n3) {
          t3 = void 0 !== t3 ? t3 : 0;
          const s3 = new z.Parser(e3, t3), o3 = [];
          let r3 = [];
          for (n3 = void 0 !== n3 ? n3 : e3.length; s3.relativeOffset < n3; ) {
            let e4 = s3.parseByte();
            e4 <= 21 ? (12 === e4 && (e4 = 1200 + s3.parseByte()), o3.push([e4, r3]), r3 = []) : r3.push(de(s3, e4));
          }
          return function(e4) {
            const t4 = {};
            for (let n4 = 0; n4 < e4.length; n4 += 1) {
              const s4 = e4[n4][0], o4 = e4[n4][1];
              let r4;
              if (r4 = 1 === o4.length ? o4[0] : o4, t4.hasOwnProperty(s4) && !isNaN(t4[s4]))
                throw new Error("Object " + t4 + " already has key " + s4);
              t4[s4] = r4;
            }
            return t4;
          }(o3);
        }
        function me(e3, t3) {
          return t3 <= 390 ? j[t3] : e3[t3 - 391];
        }
        function ye(e3, t3, n3) {
          const s3 = {};
          let o3;
          for (let r3 = 0; r3 < t3.length; r3 += 1) {
            const a3 = t3[r3];
            if (Array.isArray(a3.type)) {
              const t4 = [];
              t4.length = a3.type.length;
              for (let s4 = 0; s4 < a3.type.length; s4++)
                o3 = void 0 !== e3[a3.op] ? e3[a3.op][s4] : void 0, void 0 === o3 && (o3 = void 0 !== a3.value && void 0 !== a3.value[s4] ? a3.value[s4] : null), "SID" === a3.type[s4] && (o3 = me(n3, o3)), t4[s4] = o3;
              s3[a3.name] = t4;
            } else
              o3 = e3[a3.op], void 0 === o3 && (o3 = void 0 !== a3.value ? a3.value : null), "SID" === a3.type && (o3 = me(n3, o3)), s3[a3.name] = o3;
          }
          return s3;
        }
        const ve = [{ name: "version", op: 0, type: "SID" }, { name: "notice", op: 1, type: "SID" }, { name: "copyright", op: 1200, type: "SID" }, { name: "fullName", op: 2, type: "SID" }, { name: "familyName", op: 3, type: "SID" }, { name: "weight", op: 4, type: "SID" }, { name: "isFixedPitch", op: 1201, type: "number", value: 0 }, { name: "italicAngle", op: 1202, type: "number", value: 0 }, { name: "underlinePosition", op: 1203, type: "number", value: -100 }, { name: "underlineThickness", op: 1204, type: "number", value: 50 }, { name: "paintType", op: 1205, type: "number", value: 0 }, { name: "charstringType", op: 1206, type: "number", value: 2 }, { name: "fontMatrix", op: 1207, type: ["real", "real", "real", "real", "real", "real"], value: [1e-3, 0, 0, 1e-3, 0, 0] }, { name: "uniqueId", op: 13, type: "number" }, { name: "fontBBox", op: 5, type: ["number", "number", "number", "number"], value: [0, 0, 0, 0] }, { name: "strokeWidth", op: 1208, type: "number", value: 0 }, { name: "xuid", op: 14, type: [], value: null }, { name: "charset", op: 15, type: "offset", value: 0 }, { name: "encoding", op: 16, type: "offset", value: 0 }, { name: "charStrings", op: 17, type: "offset", value: 0 }, { name: "private", op: 18, type: ["number", "offset"], value: [0, 0] }, { name: "ros", op: 1230, type: ["SID", "SID", "number"] }, { name: "cidFontVersion", op: 1231, type: "number", value: 0 }, { name: "cidFontRevision", op: 1232, type: "number", value: 0 }, { name: "cidFontType", op: 1233, type: "number", value: 0 }, { name: "cidCount", op: 1234, type: "number", value: 8720 }, { name: "uidBase", op: 1235, type: "number" }, { name: "fdArray", op: 1236, type: "offset" }, { name: "fdSelect", op: 1237, type: "offset" }, { name: "fontName", op: 1238, type: "SID" }], be = [{ name: "subrs", op: 19, type: "offset", value: 0 }, { name: "defaultWidthX", op: 20, type: "number", value: 0 }, { name: "nominalWidthX", op: 21, type: "number", value: 0 }];
        function xe(e3, t3) {
          return ye(ge(e3, 0, e3.byteLength), ve, t3);
        }
        function Se(e3, t3, n3, s3) {
          return ye(ge(e3, t3, n3), be, s3);
        }
        function Ue(e3, t3, n3, s3) {
          const o3 = [];
          for (let r3 = 0; r3 < n3.length; r3 += 1) {
            const a3 = xe(new DataView(new Uint8Array(n3[r3]).buffer), s3);
            a3._subrs = [], a3._subrsBias = 0;
            const i3 = a3.private[0], l2 = a3.private[1];
            if (0 !== i3 && 0 !== l2) {
              const n4 = Se(e3, l2 + t3, i3, s3);
              if (a3._defaultWidthX = n4.defaultWidthX, a3._nominalWidthX = n4.nominalWidthX, 0 !== n4.subrs) {
                const s4 = he(e3, l2 + n4.subrs + t3);
                a3._subrs = s4.objects, a3._subrsBias = fe(a3._subrs);
              }
              a3._privateDict = n4;
            }
            o3.push(a3);
          }
          return o3;
        }
        function ke(e3, t3, n3) {
          let s3, o3, r3, a3;
          const i3 = new u(), l2 = [];
          let c2, p2, f2, h2, d2 = 0, g2 = false, m2 = false, y2 = 0, v2 = 0;
          if (e3.isCIDFont) {
            const n4 = e3.tables.cff.topDict._fdSelect[t3.index], s4 = e3.tables.cff.topDict._fdArray[n4];
            c2 = s4._subrs, p2 = s4._subrsBias, f2 = s4._defaultWidthX, h2 = s4._nominalWidthX;
          } else
            c2 = e3.tables.cff.topDict._subrs, p2 = e3.tables.cff.topDict._subrsBias, f2 = e3.tables.cff.topDict._defaultWidthX, h2 = e3.tables.cff.topDict._nominalWidthX;
          let b2 = f2;
          function x2(e4, t4) {
            m2 && i3.closePath(), i3.moveTo(e4, t4), m2 = true;
          }
          function S2() {
            let e4;
            e4 = l2.length % 2 != 0, e4 && !g2 && (b2 = l2.shift() + h2), d2 += l2.length >> 1, l2.length = 0, g2 = true;
          }
          return function n4(u2) {
            let f3, U2, k2, T2, E2, w2, O2, I2, R2, L2, B2, C2, D2 = 0;
            for (; D2 < u2.length; ) {
              let M2 = u2[D2];
              switch (D2 += 1, M2) {
                case 1:
                case 3:
                case 18:
                case 23:
                  S2();
                  break;
                case 4:
                  l2.length > 1 && !g2 && (b2 = l2.shift() + h2, g2 = true), v2 += l2.pop(), x2(y2, v2);
                  break;
                case 5:
                  for (; l2.length > 0; )
                    y2 += l2.shift(), v2 += l2.shift(), i3.lineTo(y2, v2);
                  break;
                case 6:
                  for (; l2.length > 0 && (y2 += l2.shift(), i3.lineTo(y2, v2), 0 !== l2.length); )
                    v2 += l2.shift(), i3.lineTo(y2, v2);
                  break;
                case 7:
                  for (; l2.length > 0 && (v2 += l2.shift(), i3.lineTo(y2, v2), 0 !== l2.length); )
                    y2 += l2.shift(), i3.lineTo(y2, v2);
                  break;
                case 8:
                  for (; l2.length > 0; )
                    s3 = y2 + l2.shift(), o3 = v2 + l2.shift(), r3 = s3 + l2.shift(), a3 = o3 + l2.shift(), y2 = r3 + l2.shift(), v2 = a3 + l2.shift(), i3.curveTo(s3, o3, r3, a3, y2, v2);
                  break;
                case 10:
                  E2 = l2.pop() + p2, w2 = c2[E2], w2 && n4(w2);
                  break;
                case 11:
                  return;
                case 12:
                  switch (M2 = u2[D2], D2 += 1, M2) {
                    case 35:
                      s3 = y2 + l2.shift(), o3 = v2 + l2.shift(), r3 = s3 + l2.shift(), a3 = o3 + l2.shift(), O2 = r3 + l2.shift(), I2 = a3 + l2.shift(), R2 = O2 + l2.shift(), L2 = I2 + l2.shift(), B2 = R2 + l2.shift(), C2 = L2 + l2.shift(), y2 = B2 + l2.shift(), v2 = C2 + l2.shift(), l2.shift(), i3.curveTo(s3, o3, r3, a3, O2, I2), i3.curveTo(R2, L2, B2, C2, y2, v2);
                      break;
                    case 34:
                      s3 = y2 + l2.shift(), o3 = v2, r3 = s3 + l2.shift(), a3 = o3 + l2.shift(), O2 = r3 + l2.shift(), I2 = a3, R2 = O2 + l2.shift(), L2 = a3, B2 = R2 + l2.shift(), C2 = v2, y2 = B2 + l2.shift(), i3.curveTo(s3, o3, r3, a3, O2, I2), i3.curveTo(R2, L2, B2, C2, y2, v2);
                      break;
                    case 36:
                      s3 = y2 + l2.shift(), o3 = v2 + l2.shift(), r3 = s3 + l2.shift(), a3 = o3 + l2.shift(), O2 = r3 + l2.shift(), I2 = a3, R2 = O2 + l2.shift(), L2 = a3, B2 = R2 + l2.shift(), C2 = L2 + l2.shift(), y2 = B2 + l2.shift(), i3.curveTo(s3, o3, r3, a3, O2, I2), i3.curveTo(R2, L2, B2, C2, y2, v2);
                      break;
                    case 37:
                      s3 = y2 + l2.shift(), o3 = v2 + l2.shift(), r3 = s3 + l2.shift(), a3 = o3 + l2.shift(), O2 = r3 + l2.shift(), I2 = a3 + l2.shift(), R2 = O2 + l2.shift(), L2 = I2 + l2.shift(), B2 = R2 + l2.shift(), C2 = L2 + l2.shift(), Math.abs(B2 - y2) > Math.abs(C2 - v2) ? y2 = B2 + l2.shift() : v2 = C2 + l2.shift(), i3.curveTo(s3, o3, r3, a3, O2, I2), i3.curveTo(R2, L2, B2, C2, y2, v2);
                      break;
                    default:
                      console.log("Glyph " + t3.index + ": unknown operator 1200" + M2), l2.length = 0;
                  }
                  break;
                case 14:
                  l2.length > 0 && !g2 && (b2 = l2.shift() + h2, g2 = true), m2 && (i3.closePath(), m2 = false);
                  break;
                case 19:
                case 20:
                  S2(), D2 += d2 + 7 >> 3;
                  break;
                case 21:
                  l2.length > 2 && !g2 && (b2 = l2.shift() + h2, g2 = true), v2 += l2.pop(), y2 += l2.pop(), x2(y2, v2);
                  break;
                case 22:
                  l2.length > 1 && !g2 && (b2 = l2.shift() + h2, g2 = true), y2 += l2.pop(), x2(y2, v2);
                  break;
                case 24:
                  for (; l2.length > 2; )
                    s3 = y2 + l2.shift(), o3 = v2 + l2.shift(), r3 = s3 + l2.shift(), a3 = o3 + l2.shift(), y2 = r3 + l2.shift(), v2 = a3 + l2.shift(), i3.curveTo(s3, o3, r3, a3, y2, v2);
                  y2 += l2.shift(), v2 += l2.shift(), i3.lineTo(y2, v2);
                  break;
                case 25:
                  for (; l2.length > 6; )
                    y2 += l2.shift(), v2 += l2.shift(), i3.lineTo(y2, v2);
                  s3 = y2 + l2.shift(), o3 = v2 + l2.shift(), r3 = s3 + l2.shift(), a3 = o3 + l2.shift(), y2 = r3 + l2.shift(), v2 = a3 + l2.shift(), i3.curveTo(s3, o3, r3, a3, y2, v2);
                  break;
                case 26:
                  for (l2.length % 2 && (y2 += l2.shift()); l2.length > 0; )
                    s3 = y2, o3 = v2 + l2.shift(), r3 = s3 + l2.shift(), a3 = o3 + l2.shift(), y2 = r3, v2 = a3 + l2.shift(), i3.curveTo(s3, o3, r3, a3, y2, v2);
                  break;
                case 27:
                  for (l2.length % 2 && (v2 += l2.shift()); l2.length > 0; )
                    s3 = y2 + l2.shift(), o3 = v2, r3 = s3 + l2.shift(), a3 = o3 + l2.shift(), y2 = r3 + l2.shift(), v2 = a3, i3.curveTo(s3, o3, r3, a3, y2, v2);
                  break;
                case 28:
                  f3 = u2[D2], U2 = u2[D2 + 1], l2.push((f3 << 24 | U2 << 16) >> 16), D2 += 2;
                  break;
                case 29:
                  E2 = l2.pop() + e3.gsubrsBias, w2 = e3.gsubrs[E2], w2 && n4(w2);
                  break;
                case 30:
                  for (; l2.length > 0 && (s3 = y2, o3 = v2 + l2.shift(), r3 = s3 + l2.shift(), a3 = o3 + l2.shift(), y2 = r3 + l2.shift(), v2 = a3 + (1 === l2.length ? l2.shift() : 0), i3.curveTo(s3, o3, r3, a3, y2, v2), 0 !== l2.length); )
                    s3 = y2 + l2.shift(), o3 = v2, r3 = s3 + l2.shift(), a3 = o3 + l2.shift(), v2 = a3 + l2.shift(), y2 = r3 + (1 === l2.length ? l2.shift() : 0), i3.curveTo(s3, o3, r3, a3, y2, v2);
                  break;
                case 31:
                  for (; l2.length > 0 && (s3 = y2 + l2.shift(), o3 = v2, r3 = s3 + l2.shift(), a3 = o3 + l2.shift(), v2 = a3 + l2.shift(), y2 = r3 + (1 === l2.length ? l2.shift() : 0), i3.curveTo(s3, o3, r3, a3, y2, v2), 0 !== l2.length); )
                    s3 = y2, o3 = v2 + l2.shift(), r3 = s3 + l2.shift(), a3 = o3 + l2.shift(), y2 = r3 + l2.shift(), v2 = a3 + (1 === l2.length ? l2.shift() : 0), i3.curveTo(s3, o3, r3, a3, y2, v2);
                  break;
                default:
                  M2 < 32 ? console.log("Glyph " + t3.index + ": unknown operator " + M2) : M2 < 247 ? l2.push(M2 - 139) : M2 < 251 ? (f3 = u2[D2], D2 += 1, l2.push(256 * (M2 - 247) + f3 + 108)) : M2 < 255 ? (f3 = u2[D2], D2 += 1, l2.push(256 * -(M2 - 251) - f3 - 108)) : (f3 = u2[D2], U2 = u2[D2 + 1], k2 = u2[D2 + 2], T2 = u2[D2 + 3], D2 += 4, l2.push((f3 << 24 | U2 << 16 | k2 << 8 | T2) / 65536));
              }
            }
          }(n3), t3.advanceWidth = b2, i3;
        }
        function Te(e3, t3) {
          let n3, s3 = j.indexOf(e3);
          return s3 >= 0 && (n3 = s3), s3 = t3.indexOf(e3), s3 >= 0 ? n3 = s3 + j.length : (n3 = j.length + t3.length, t3.push(e3)), n3;
        }
        function Ee(e3, t3, n3) {
          const s3 = {};
          for (let o3 = 0; o3 < e3.length; o3 += 1) {
            const r3 = e3[o3];
            let a3 = t3[r3.name];
            void 0 === a3 || pe(a3, r3.value) || ("SID" === r3.type && (a3 = Te(a3, n3)), s3[r3.op] = { name: r3.name, type: r3.type, value: a3 });
          }
          return s3;
        }
        function we(e3, t3) {
          const n3 = new M.Record("Top DICT", [{ name: "dict", type: "DICT", value: {} }]);
          return n3.dict = Ee(ve, e3, t3), n3;
        }
        function Oe(e3) {
          const t3 = new M.Record("Top DICT INDEX", [{ name: "topDicts", type: "INDEX", value: [] }]);
          return t3.topDicts = [{ name: "topDict_0", type: "TABLE", value: e3 }], t3;
        }
        function Ie(e3) {
          const t3 = [], n3 = e3.path;
          t3.push({ name: "width", type: "NUMBER", value: e3.advanceWidth });
          let s3 = 0, o3 = 0;
          for (let e4 = 0; e4 < n3.commands.length; e4 += 1) {
            let r3, a3, i3 = n3.commands[e4];
            if ("Q" === i3.type) {
              const e5 = 1 / 3, t4 = 2 / 3;
              i3 = { type: "C", x: i3.x, y: i3.y, x1: e5 * s3 + t4 * i3.x1, y1: e5 * o3 + t4 * i3.y1, x2: e5 * i3.x + t4 * i3.x1, y2: e5 * i3.y + t4 * i3.y1 };
            }
            if ("M" === i3.type)
              r3 = Math.round(i3.x - s3), a3 = Math.round(i3.y - o3), t3.push({ name: "dx", type: "NUMBER", value: r3 }), t3.push({ name: "dy", type: "NUMBER", value: a3 }), t3.push({ name: "rmoveto", type: "OP", value: 21 }), s3 = Math.round(i3.x), o3 = Math.round(i3.y);
            else if ("L" === i3.type)
              r3 = Math.round(i3.x - s3), a3 = Math.round(i3.y - o3), t3.push({ name: "dx", type: "NUMBER", value: r3 }), t3.push({ name: "dy", type: "NUMBER", value: a3 }), t3.push({ name: "rlineto", type: "OP", value: 5 }), s3 = Math.round(i3.x), o3 = Math.round(i3.y);
            else if ("C" === i3.type) {
              const e5 = Math.round(i3.x1 - s3), n4 = Math.round(i3.y1 - o3), l2 = Math.round(i3.x2 - i3.x1), u2 = Math.round(i3.y2 - i3.y1);
              r3 = Math.round(i3.x - i3.x2), a3 = Math.round(i3.y - i3.y2), t3.push({ name: "dx1", type: "NUMBER", value: e5 }), t3.push({ name: "dy1", type: "NUMBER", value: n4 }), t3.push({ name: "dx2", type: "NUMBER", value: l2 }), t3.push({ name: "dy2", type: "NUMBER", value: u2 }), t3.push({ name: "dx", type: "NUMBER", value: r3 }), t3.push({ name: "dy", type: "NUMBER", value: a3 }), t3.push({ name: "rrcurveto", type: "OP", value: 8 }), s3 = Math.round(i3.x), o3 = Math.round(i3.y);
            }
          }
          return t3.push({ name: "endchar", type: "OP", value: 14 }), t3;
        }
        const Re = { parse: function(e3, t3, n3) {
          n3.tables.cff = {};
          const s3 = function(e4, t4) {
            const n4 = {};
            return n4.formatMajor = z.getCard8(e4, t4), n4.formatMinor = z.getCard8(e4, t4 + 1), n4.size = z.getCard8(e4, t4 + 2), n4.offsetSize = z.getCard8(e4, t4 + 3), n4.startOffset = t4, n4.endOffset = t4 + 4, n4;
          }(e3, t3), o3 = he(e3, s3.endOffset, z.bytesToString), r3 = he(e3, o3.endOffset), a3 = he(e3, r3.endOffset, z.bytesToString), i3 = he(e3, a3.endOffset);
          n3.gsubrs = i3.objects, n3.gsubrsBias = fe(n3.gsubrs);
          const l2 = Ue(e3, t3, r3.objects, a3.objects);
          if (1 !== l2.length)
            throw new Error("CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = " + l2.length);
          const u2 = l2[0];
          if (n3.tables.cff.topDict = u2, u2._privateDict && (n3.defaultWidthX = u2._privateDict.defaultWidthX, n3.nominalWidthX = u2._privateDict.nominalWidthX), void 0 !== u2.ros[0] && void 0 !== u2.ros[1] && (n3.isCIDFont = true), n3.isCIDFont) {
            let s4 = u2.fdArray, o4 = u2.fdSelect;
            if (0 === s4 || 0 === o4)
              throw new Error("Font is marked as a CID font, but FDArray and/or FDSelect information is missing");
            s4 += t3;
            const r4 = Ue(e3, t3, he(e3, s4).objects, a3.objects);
            u2._fdArray = r4, o4 += t3, u2._fdSelect = function(e4, t4, n4, s5) {
              const o5 = [];
              let r5;
              const a4 = new z.Parser(e4, t4), i4 = a4.parseCard8();
              if (0 === i4)
                for (let e5 = 0; e5 < n4; e5++) {
                  if (r5 = a4.parseCard8(), r5 >= s5)
                    throw new Error("CFF table CID Font FDSelect has bad FD index value " + r5 + " (FD count " + s5 + ")");
                  o5.push(r5);
                }
              else {
                if (3 !== i4)
                  throw new Error("CFF Table CID Font FDSelect table has unsupported format " + i4);
                {
                  const e5 = a4.parseCard16();
                  let t5, i5 = a4.parseCard16();
                  if (0 !== i5)
                    throw new Error("CFF Table CID Font FDSelect format 3 range has bad initial GID " + i5);
                  for (let l3 = 0; l3 < e5; l3++) {
                    if (r5 = a4.parseCard8(), t5 = a4.parseCard16(), r5 >= s5)
                      throw new Error("CFF table CID Font FDSelect has bad FD index value " + r5 + " (FD count " + s5 + ")");
                    if (t5 > n4)
                      throw new Error("CFF Table CID Font FDSelect format 3 range has bad GID " + t5);
                    for (; i5 < t5; i5++)
                      o5.push(r5);
                    i5 = t5;
                  }
                  if (t5 !== n4)
                    throw new Error("CFF Table CID Font FDSelect format 3 range has bad final GID " + t5);
                }
              }
              return o5;
            }(e3, o4, n3.numGlyphs, r4.length);
          }
          const c2 = t3 + u2.private[1], p2 = Se(e3, c2, u2.private[0], a3.objects);
          if (n3.defaultWidthX = p2.defaultWidthX, n3.nominalWidthX = p2.nominalWidthX, 0 !== p2.subrs) {
            const t4 = he(e3, c2 + p2.subrs);
            n3.subrs = t4.objects, n3.subrsBias = fe(n3.subrs);
          } else
            n3.subrs = [], n3.subrsBias = 0;
          const f2 = he(e3, t3 + u2.charStrings);
          n3.nGlyphs = f2.objects.length;
          const h2 = function(e4, t4, n4, s4) {
            let o4, r4;
            const a4 = new z.Parser(e4, t4);
            n4 -= 1;
            const i4 = [".notdef"], l3 = a4.parseCard8();
            if (0 === l3)
              for (let e5 = 0; e5 < n4; e5 += 1)
                o4 = a4.parseSID(), i4.push(me(s4, o4));
            else if (1 === l3)
              for (; i4.length <= n4; ) {
                o4 = a4.parseSID(), r4 = a4.parseCard8();
                for (let e5 = 0; e5 <= r4; e5 += 1)
                  i4.push(me(s4, o4)), o4 += 1;
              }
            else {
              if (2 !== l3)
                throw new Error("Unknown charset format " + l3);
              for (; i4.length <= n4; ) {
                o4 = a4.parseSID(), r4 = a4.parseCard16();
                for (let e5 = 0; e5 <= r4; e5 += 1)
                  i4.push(me(s4, o4)), o4 += 1;
              }
            }
            return i4;
          }(e3, t3 + u2.charset, n3.nGlyphs, a3.objects);
          0 === u2.encoding ? n3.cffEncoding = new J(X, h2) : 1 === u2.encoding ? n3.cffEncoding = new J(V, h2) : n3.cffEncoding = function(e4, t4, n4) {
            let s4;
            const o4 = {}, r4 = new z.Parser(e4, t4), a4 = r4.parseCard8();
            if (0 === a4) {
              const e5 = r4.parseCard8();
              for (let t5 = 0; t5 < e5; t5 += 1)
                s4 = r4.parseCard8(), o4[s4] = t5;
            } else {
              if (1 !== a4)
                throw new Error("Unknown encoding format " + a4);
              {
                const e5 = r4.parseCard8();
                s4 = 1;
                for (let t5 = 0; t5 < e5; t5 += 1) {
                  const e6 = r4.parseCard8(), t6 = r4.parseCard8();
                  for (let n5 = e6; n5 <= e6 + t6; n5 += 1)
                    o4[n5] = s4, s4 += 1;
                }
              }
            }
            return new J(o4, n4);
          }(e3, t3 + u2.encoding, h2), n3.encoding = n3.encoding || n3.cffEncoding, n3.glyphs = new ce.GlyphSet(n3);
          for (let e4 = 0; e4 < n3.nGlyphs; e4 += 1) {
            const t4 = f2.objects[e4];
            n3.glyphs.push(e4, ce.cffGlyphLoader(n3, e4, ke, t4));
          }
        }, make: function(e3, t3) {
          const n3 = new M.Table("CFF ", [{ name: "header", type: "RECORD" }, { name: "nameIndex", type: "RECORD" }, { name: "topDictIndex", type: "RECORD" }, { name: "stringIndex", type: "RECORD" }, { name: "globalSubrIndex", type: "RECORD" }, { name: "charsets", type: "RECORD" }, { name: "charStringsIndex", type: "RECORD" }, { name: "privateDict", type: "RECORD" }]), s3 = 1 / t3.unitsPerEm, o3 = { version: t3.version, fullName: t3.fullName, familyName: t3.familyName, weight: t3.weightName, fontBBox: t3.fontBBox || [0, 0, 0, 0], fontMatrix: [s3, 0, 0, s3, 0, 0], charset: 999, encoding: 0, charStrings: 999, private: [0, 999] }, r3 = [];
          let a3;
          for (let t4 = 1; t4 < e3.length; t4 += 1)
            a3 = e3.get(t4), r3.push(a3.name);
          const i3 = [];
          n3.header = new M.Record("Header", [{ name: "major", type: "Card8", value: 1 }, { name: "minor", type: "Card8", value: 0 }, { name: "hdrSize", type: "Card8", value: 4 }, { name: "major", type: "Card8", value: 1 }]), n3.nameIndex = function(e4) {
            const t4 = new M.Record("Name INDEX", [{ name: "names", type: "INDEX", value: [] }]);
            t4.names = [];
            for (let n4 = 0; n4 < e4.length; n4 += 1)
              t4.names.push({ name: "name_" + n4, type: "NAME", value: e4[n4] });
            return t4;
          }([t3.postScriptName]);
          let l2 = we(o3, i3);
          n3.topDictIndex = Oe(l2), n3.globalSubrIndex = new M.Record("Global Subr INDEX", [{ name: "subrs", type: "INDEX", value: [] }]), n3.charsets = function(e4, t4) {
            const n4 = new M.Record("Charsets", [{ name: "format", type: "Card8", value: 0 }]);
            for (let s4 = 0; s4 < e4.length; s4 += 1) {
              const o4 = Te(e4[s4], t4);
              n4.fields.push({ name: "glyph_" + s4, type: "SID", value: o4 });
            }
            return n4;
          }(r3, i3), n3.charStringsIndex = function(e4) {
            const t4 = new M.Record("CharStrings INDEX", [{ name: "charStrings", type: "INDEX", value: [] }]);
            for (let n4 = 0; n4 < e4.length; n4 += 1) {
              const s4 = e4.get(n4), o4 = Ie(s4);
              t4.charStrings.push({ name: s4.name, type: "CHARSTRING", value: o4 });
            }
            return t4;
          }(e3), n3.privateDict = function(e4, t4) {
            const n4 = new M.Record("Private DICT", [{ name: "dict", type: "DICT", value: {} }]);
            return n4.dict = Ee(be, {}, t4), n4;
          }(0, i3), n3.stringIndex = function(e4) {
            const t4 = new M.Record("String INDEX", [{ name: "strings", type: "INDEX", value: [] }]);
            t4.strings = [];
            for (let n4 = 0; n4 < e4.length; n4 += 1)
              t4.strings.push({ name: "string_" + n4, type: "STRING", value: e4[n4] });
            return t4;
          }(i3);
          const u2 = n3.header.sizeOf() + n3.nameIndex.sizeOf() + n3.topDictIndex.sizeOf() + n3.stringIndex.sizeOf() + n3.globalSubrIndex.sizeOf();
          return o3.charset = u2, o3.encoding = 0, o3.charStrings = o3.charset + n3.charsets.sizeOf(), o3.private[1] = o3.charStrings + n3.charStringsIndex.sizeOf(), l2 = we(o3, i3), n3.topDictIndex = Oe(l2), n3;
        } }, Le = { parse: function(e3, t3) {
          const n3 = {}, s3 = new z.Parser(e3, t3);
          return n3.version = s3.parseVersion(), n3.fontRevision = Math.round(1e3 * s3.parseFixed()) / 1e3, n3.checkSumAdjustment = s3.parseULong(), n3.magicNumber = s3.parseULong(), f.argument(1594834165 === n3.magicNumber, "Font header has wrong magic number."), n3.flags = s3.parseUShort(), n3.unitsPerEm = s3.parseUShort(), n3.created = s3.parseLongDateTime(), n3.modified = s3.parseLongDateTime(), n3.xMin = s3.parseShort(), n3.yMin = s3.parseShort(), n3.xMax = s3.parseShort(), n3.yMax = s3.parseShort(), n3.macStyle = s3.parseUShort(), n3.lowestRecPPEM = s3.parseUShort(), n3.fontDirectionHint = s3.parseShort(), n3.indexToLocFormat = s3.parseShort(), n3.glyphDataFormat = s3.parseShort(), n3;
        }, make: function(e3) {
          const t3 = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) + 2082844800;
          let n3 = t3;
          return e3.createdTimestamp && (n3 = e3.createdTimestamp + 2082844800), new M.Table("head", [{ name: "version", type: "FIXED", value: 65536 }, { name: "fontRevision", type: "FIXED", value: 65536 }, { name: "checkSumAdjustment", type: "ULONG", value: 0 }, { name: "magicNumber", type: "ULONG", value: 1594834165 }, { name: "flags", type: "USHORT", value: 0 }, { name: "unitsPerEm", type: "USHORT", value: 1e3 }, { name: "created", type: "LONGDATETIME", value: n3 }, { name: "modified", type: "LONGDATETIME", value: t3 }, { name: "xMin", type: "SHORT", value: 0 }, { name: "yMin", type: "SHORT", value: 0 }, { name: "xMax", type: "SHORT", value: 0 }, { name: "yMax", type: "SHORT", value: 0 }, { name: "macStyle", type: "USHORT", value: 0 }, { name: "lowestRecPPEM", type: "USHORT", value: 0 }, { name: "fontDirectionHint", type: "SHORT", value: 2 }, { name: "indexToLocFormat", type: "SHORT", value: 0 }, { name: "glyphDataFormat", type: "SHORT", value: 0 }], e3);
        } }, Be = { parse: function(e3, t3) {
          const n3 = {}, s3 = new z.Parser(e3, t3);
          return n3.version = s3.parseVersion(), n3.ascender = s3.parseShort(), n3.descender = s3.parseShort(), n3.lineGap = s3.parseShort(), n3.advanceWidthMax = s3.parseUShort(), n3.minLeftSideBearing = s3.parseShort(), n3.minRightSideBearing = s3.parseShort(), n3.xMaxExtent = s3.parseShort(), n3.caretSlopeRise = s3.parseShort(), n3.caretSlopeRun = s3.parseShort(), n3.caretOffset = s3.parseShort(), s3.relativeOffset += 8, n3.metricDataFormat = s3.parseShort(), n3.numberOfHMetrics = s3.parseUShort(), n3;
        }, make: function(e3) {
          return new M.Table("hhea", [{ name: "version", type: "FIXED", value: 65536 }, { name: "ascender", type: "FWORD", value: 0 }, { name: "descender", type: "FWORD", value: 0 }, { name: "lineGap", type: "FWORD", value: 0 }, { name: "advanceWidthMax", type: "UFWORD", value: 0 }, { name: "minLeftSideBearing", type: "FWORD", value: 0 }, { name: "minRightSideBearing", type: "FWORD", value: 0 }, { name: "xMaxExtent", type: "FWORD", value: 0 }, { name: "caretSlopeRise", type: "SHORT", value: 1 }, { name: "caretSlopeRun", type: "SHORT", value: 0 }, { name: "caretOffset", type: "SHORT", value: 0 }, { name: "reserved1", type: "SHORT", value: 0 }, { name: "reserved2", type: "SHORT", value: 0 }, { name: "reserved3", type: "SHORT", value: 0 }, { name: "reserved4", type: "SHORT", value: 0 }, { name: "metricDataFormat", type: "SHORT", value: 0 }, { name: "numberOfHMetrics", type: "USHORT", value: 0 }], e3);
        } }, Ce = { parse: function(e3, t3, n3, s3, o3) {
          let r3, a3;
          const i3 = new z.Parser(e3, t3);
          for (let e4 = 0; e4 < s3; e4 += 1) {
            e4 < n3 && (r3 = i3.parseUShort(), a3 = i3.parseShort());
            const t4 = o3.get(e4);
            t4.advanceWidth = r3, t4.leftSideBearing = a3;
          }
        }, make: function(e3) {
          const t3 = new M.Table("hmtx", []);
          for (let n3 = 0; n3 < e3.length; n3 += 1) {
            const s3 = e3.get(n3), o3 = s3.advanceWidth || 0, r3 = s3.leftSideBearing || 0;
            t3.fields.push({ name: "advanceWidth_" + n3, type: "USHORT", value: o3 }), t3.fields.push({ name: "leftSideBearing_" + n3, type: "SHORT", value: r3 });
          }
          return t3;
        } }, De = { make: function(e3) {
          const t3 = new M.Table("ltag", [{ name: "version", type: "ULONG", value: 1 }, { name: "flags", type: "ULONG", value: 0 }, { name: "numTags", type: "ULONG", value: e3.length }]);
          let n3 = "";
          const s3 = 12 + 4 * e3.length;
          for (let o3 = 0; o3 < e3.length; ++o3) {
            let r3 = n3.indexOf(e3[o3]);
            r3 < 0 && (r3 = n3.length, n3 += e3[o3]), t3.fields.push({ name: "offset " + o3, type: "USHORT", value: s3 + r3 }), t3.fields.push({ name: "length " + o3, type: "USHORT", value: e3[o3].length });
          }
          return t3.fields.push({ name: "stringPool", type: "CHARARRAY", value: n3 }), t3;
        }, parse: function(e3, t3) {
          const n3 = new z.Parser(e3, t3), s3 = n3.parseULong();
          f.argument(1 === s3, "Unsupported ltag table version."), n3.skip("uLong", 1);
          const o3 = n3.parseULong(), r3 = [];
          for (let s4 = 0; s4 < o3; s4++) {
            let s5 = "";
            const o4 = t3 + n3.parseUShort(), a3 = n3.parseUShort();
            for (let t4 = o4; t4 < o4 + a3; ++t4)
              s5 += String.fromCharCode(e3.getInt8(t4));
            r3.push(s5);
          }
          return r3;
        } }, Me = { parse: function(e3, t3) {
          const n3 = {}, s3 = new z.Parser(e3, t3);
          return n3.version = s3.parseVersion(), n3.numGlyphs = s3.parseUShort(), 1 === n3.version && (n3.maxPoints = s3.parseUShort(), n3.maxContours = s3.parseUShort(), n3.maxCompositePoints = s3.parseUShort(), n3.maxCompositeContours = s3.parseUShort(), n3.maxZones = s3.parseUShort(), n3.maxTwilightPoints = s3.parseUShort(), n3.maxStorage = s3.parseUShort(), n3.maxFunctionDefs = s3.parseUShort(), n3.maxInstructionDefs = s3.parseUShort(), n3.maxStackElements = s3.parseUShort(), n3.maxSizeOfInstructions = s3.parseUShort(), n3.maxComponentElements = s3.parseUShort(), n3.maxComponentDepth = s3.parseUShort()), n3;
        }, make: function(e3) {
          return new M.Table("maxp", [{ name: "version", type: "FIXED", value: 20480 }, { name: "numGlyphs", type: "USHORT", value: e3 }]);
        } }, Ae = ["copyright", "fontFamily", "fontSubfamily", "uniqueID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "manufacturerURL", "designerURL", "license", "licenseURL", "reserved", "preferredFamily", "preferredSubfamily", "compatibleFullName", "sampleText", "postScriptFindFontName", "wwsFamily", "wwsSubfamily"], Pe = { 0: "en", 1: "fr", 2: "de", 3: "it", 4: "nl", 5: "sv", 6: "es", 7: "da", 8: "pt", 9: "no", 10: "he", 11: "ja", 12: "ar", 13: "fi", 14: "el", 15: "is", 16: "mt", 17: "tr", 18: "hr", 19: "zh-Hant", 20: "ur", 21: "hi", 22: "th", 23: "ko", 24: "lt", 25: "pl", 26: "hu", 27: "es", 28: "lv", 29: "se", 30: "fo", 31: "fa", 32: "ru", 33: "zh", 34: "nl-BE", 35: "ga", 36: "sq", 37: "ro", 38: "cz", 39: "sk", 40: "si", 41: "yi", 42: "sr", 43: "mk", 44: "bg", 45: "uk", 46: "be", 47: "uz", 48: "kk", 49: "az-Cyrl", 50: "az-Arab", 51: "hy", 52: "ka", 53: "mo", 54: "ky", 55: "tg", 56: "tk", 57: "mn-CN", 58: "mn", 59: "ps", 60: "ks", 61: "ku", 62: "sd", 63: "bo", 64: "ne", 65: "sa", 66: "mr", 67: "bn", 68: "as", 69: "gu", 70: "pa", 71: "or", 72: "ml", 73: "kn", 74: "ta", 75: "te", 76: "si", 77: "my", 78: "km", 79: "lo", 80: "vi", 81: "id", 82: "tl", 83: "ms", 84: "ms-Arab", 85: "am", 86: "ti", 87: "om", 88: "so", 89: "sw", 90: "rw", 91: "rn", 92: "ny", 93: "mg", 94: "eo", 128: "cy", 129: "eu", 130: "ca", 131: "la", 132: "qu", 133: "gn", 134: "ay", 135: "tt", 136: "ug", 137: "dz", 138: "jv", 139: "su", 140: "gl", 141: "af", 142: "br", 143: "iu", 144: "gd", 145: "gv", 146: "ga", 147: "to", 148: "el-polyton", 149: "kl", 150: "az", 151: "nn" }, Ge = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 5, 11: 1, 12: 4, 13: 0, 14: 6, 15: 0, 16: 0, 17: 0, 18: 0, 19: 2, 20: 4, 21: 9, 22: 21, 23: 3, 24: 29, 25: 29, 26: 29, 27: 29, 28: 29, 29: 0, 30: 0, 31: 4, 32: 7, 33: 25, 34: 0, 35: 0, 36: 0, 37: 0, 38: 29, 39: 29, 40: 0, 41: 5, 42: 7, 43: 7, 44: 7, 45: 7, 46: 7, 47: 7, 48: 7, 49: 7, 50: 4, 51: 24, 52: 23, 53: 7, 54: 7, 55: 7, 56: 7, 57: 27, 58: 7, 59: 4, 60: 4, 61: 4, 62: 4, 63: 26, 64: 9, 65: 9, 66: 9, 67: 13, 68: 13, 69: 11, 70: 10, 71: 12, 72: 17, 73: 16, 74: 14, 75: 15, 76: 18, 77: 19, 78: 20, 79: 22, 80: 30, 81: 0, 82: 0, 83: 0, 84: 4, 85: 28, 86: 28, 87: 28, 88: 0, 89: 0, 90: 0, 91: 0, 92: 0, 93: 0, 94: 0, 128: 0, 129: 0, 130: 0, 131: 0, 132: 0, 133: 0, 134: 0, 135: 7, 136: 4, 137: 26, 138: 0, 139: 0, 140: 0, 141: 0, 142: 0, 143: 28, 144: 0, 145: 0, 146: 0, 147: 0, 148: 6, 149: 0, 150: 0, 151: 0 }, Ne = { 1078: "af", 1052: "sq", 1156: "gsw", 1118: "am", 5121: "ar-DZ", 15361: "ar-BH", 3073: "ar", 2049: "ar-IQ", 11265: "ar-JO", 13313: "ar-KW", 12289: "ar-LB", 4097: "ar-LY", 6145: "ary", 8193: "ar-OM", 16385: "ar-QA", 1025: "ar-SA", 10241: "ar-SY", 7169: "aeb", 14337: "ar-AE", 9217: "ar-YE", 1067: "hy", 1101: "as", 2092: "az-Cyrl", 1068: "az", 1133: "ba", 1069: "eu", 1059: "be", 2117: "bn", 1093: "bn-IN", 8218: "bs-Cyrl", 5146: "bs", 1150: "br", 1026: "bg", 1027: "ca", 3076: "zh-HK", 5124: "zh-MO", 2052: "zh", 4100: "zh-SG", 1028: "zh-TW", 1155: "co", 1050: "hr", 4122: "hr-BA", 1029: "cs", 1030: "da", 1164: "prs", 1125: "dv", 2067: "nl-BE", 1043: "nl", 3081: "en-AU", 10249: "en-BZ", 4105: "en-CA", 9225: "en-029", 16393: "en-IN", 6153: "en-IE", 8201: "en-JM", 17417: "en-MY", 5129: "en-NZ", 13321: "en-PH", 18441: "en-SG", 7177: "en-ZA", 11273: "en-TT", 2057: "en-GB", 1033: "en", 12297: "en-ZW", 1061: "et", 1080: "fo", 1124: "fil", 1035: "fi", 2060: "fr-BE", 3084: "fr-CA", 1036: "fr", 5132: "fr-LU", 6156: "fr-MC", 4108: "fr-CH", 1122: "fy", 1110: "gl", 1079: "ka", 3079: "de-AT", 1031: "de", 5127: "de-LI", 4103: "de-LU", 2055: "de-CH", 1032: "el", 1135: "kl", 1095: "gu", 1128: "ha", 1037: "he", 1081: "hi", 1038: "hu", 1039: "is", 1136: "ig", 1057: "id", 1117: "iu", 2141: "iu-Latn", 2108: "ga", 1076: "xh", 1077: "zu", 1040: "it", 2064: "it-CH", 1041: "ja", 1099: "kn", 1087: "kk", 1107: "km", 1158: "quc", 1159: "rw", 1089: "sw", 1111: "kok", 1042: "ko", 1088: "ky", 1108: "lo", 1062: "lv", 1063: "lt", 2094: "dsb", 1134: "lb", 1071: "mk", 2110: "ms-BN", 1086: "ms", 1100: "ml", 1082: "mt", 1153: "mi", 1146: "arn", 1102: "mr", 1148: "moh", 1104: "mn", 2128: "mn-CN", 1121: "ne", 1044: "nb", 2068: "nn", 1154: "oc", 1096: "or", 1123: "ps", 1045: "pl", 1046: "pt", 2070: "pt-PT", 1094: "pa", 1131: "qu-BO", 2155: "qu-EC", 3179: "qu", 1048: "ro", 1047: "rm", 1049: "ru", 9275: "smn", 4155: "smj-NO", 5179: "smj", 3131: "se-FI", 1083: "se", 2107: "se-SE", 8251: "sms", 6203: "sma-NO", 7227: "sms", 1103: "sa", 7194: "sr-Cyrl-BA", 3098: "sr", 6170: "sr-Latn-BA", 2074: "sr-Latn", 1132: "nso", 1074: "tn", 1115: "si", 1051: "sk", 1060: "sl", 11274: "es-AR", 16394: "es-BO", 13322: "es-CL", 9226: "es-CO", 5130: "es-CR", 7178: "es-DO", 12298: "es-EC", 17418: "es-SV", 4106: "es-GT", 18442: "es-HN", 2058: "es-MX", 19466: "es-NI", 6154: "es-PA", 15370: "es-PY", 10250: "es-PE", 20490: "es-PR", 3082: "es", 1034: "es", 21514: "es-US", 14346: "es-UY", 8202: "es-VE", 2077: "sv-FI", 1053: "sv", 1114: "syr", 1064: "tg", 2143: "tzm", 1097: "ta", 1092: "tt", 1098: "te", 1054: "th", 1105: "bo", 1055: "tr", 1090: "tk", 1152: "ug", 1058: "uk", 1070: "hsb", 1056: "ur", 2115: "uz-Cyrl", 1091: "uz", 1066: "vi", 1106: "cy", 1160: "wo", 1157: "sah", 1144: "ii", 1130: "yo" };
        function Fe(e3, t3, n3) {
          switch (e3) {
            case 0:
              if (65535 === t3)
                return "und";
              if (n3)
                return n3[t3];
              break;
            case 1:
              return Pe[t3];
            case 3:
              return Ne[t3];
          }
        }
        const _e = "utf-16", He = { 0: "macintosh", 1: "x-mac-japanese", 2: "x-mac-chinesetrad", 3: "x-mac-korean", 6: "x-mac-greek", 7: "x-mac-cyrillic", 9: "x-mac-devanagai", 10: "x-mac-gurmukhi", 11: "x-mac-gujarati", 12: "x-mac-oriya", 13: "x-mac-bengali", 14: "x-mac-tamil", 15: "x-mac-telugu", 16: "x-mac-kannada", 17: "x-mac-malayalam", 18: "x-mac-sinhalese", 19: "x-mac-burmese", 20: "x-mac-khmer", 21: "x-mac-thai", 22: "x-mac-lao", 23: "x-mac-georgian", 24: "x-mac-armenian", 25: "x-mac-chinesesimp", 26: "x-mac-tibetan", 27: "x-mac-mongolian", 28: "x-mac-ethiopic", 29: "x-mac-ce", 30: "x-mac-vietnamese", 31: "x-mac-extarabic" }, ze = { 15: "x-mac-icelandic", 17: "x-mac-turkish", 18: "x-mac-croatian", 24: "x-mac-ce", 25: "x-mac-ce", 26: "x-mac-ce", 27: "x-mac-ce", 28: "x-mac-ce", 30: "x-mac-icelandic", 37: "x-mac-romanian", 38: "x-mac-ce", 39: "x-mac-ce", 40: "x-mac-ce", 143: "x-mac-inuit", 146: "x-mac-gaelic" };
        function We(e3, t3, n3) {
          switch (e3) {
            case 0:
              return _e;
            case 1:
              return ze[n3] || He[t3];
            case 3:
              if (1 === t3 || 10 === t3)
                return _e;
          }
        }
        function qe(e3) {
          const t3 = {};
          for (let n3 in e3)
            t3[e3[n3]] = parseInt(n3);
          return t3;
        }
        function je(e3, t3, n3, s3, o3, r3) {
          return new M.Record("NameRecord", [{ name: "platformID", type: "USHORT", value: e3 }, { name: "encodingID", type: "USHORT", value: t3 }, { name: "languageID", type: "USHORT", value: n3 }, { name: "nameID", type: "USHORT", value: s3 }, { name: "length", type: "USHORT", value: o3 }, { name: "offset", type: "USHORT", value: r3 }]);
        }
        function Xe(e3, t3) {
          let n3 = function(e4, t4) {
            const n4 = e4.length, s3 = t4.length - n4 + 1;
            e:
              for (let o3 = 0; o3 < s3; o3++)
                for (; o3 < s3; o3++) {
                  for (let s4 = 0; s4 < n4; s4++)
                    if (t4[o3 + s4] !== e4[s4])
                      continue e;
                  return o3;
                }
            return -1;
          }(e3, t3);
          if (n3 < 0) {
            n3 = t3.length;
            let s3 = 0;
            const o3 = e3.length;
            for (; s3 < o3; ++s3)
              t3.push(e3[s3]);
          }
          return n3;
        }
        const Ve = { parse: function(e3, t3, n3) {
          const s3 = {}, o3 = new z.Parser(e3, t3), r3 = o3.parseUShort(), a3 = o3.parseUShort(), i3 = o3.offset + o3.parseUShort();
          for (let t4 = 0; t4 < a3; t4++) {
            const t5 = o3.parseUShort(), r4 = o3.parseUShort(), a4 = o3.parseUShort(), l3 = o3.parseUShort(), u2 = Ae[l3] || l3, c2 = o3.parseUShort(), p2 = o3.parseUShort(), f2 = Fe(t5, a4, n3), h2 = We(t5, r4, a4);
            if (void 0 !== h2 && void 0 !== f2) {
              let t6;
              if (t6 = h2 === _e ? d.UTF16(e3, i3 + p2, c2) : d.MACSTRING(e3, i3 + p2, c2, h2), t6) {
                let e4 = s3[u2];
                void 0 === e4 && (e4 = s3[u2] = {}), e4[f2] = t6;
              }
            }
          }
          let l2 = 0;
          return 1 === r3 && o3.parseUShort(), s3;
        }, make: function(e3, t3) {
          let n3;
          const s3 = [], o3 = {}, r3 = qe(Ae);
          for (let t4 in e3) {
            let a4 = r3[t4];
            if (void 0 === a4 && (a4 = t4), n3 = parseInt(a4), isNaN(n3))
              throw new Error('Name table entry "' + t4 + '" does not exist, see nameTableNames for complete list.');
            o3[n3] = e3[t4], s3.push(n3);
          }
          const a3 = qe(Pe), i3 = qe(Ne), l2 = [], u2 = [];
          for (let e4 = 0; e4 < s3.length; e4++) {
            n3 = s3[e4];
            const r4 = o3[n3];
            for (let e5 in r4) {
              const s4 = r4[e5];
              let o4 = 1, c3 = a3[e5], p2 = Ge[c3];
              const f2 = We(o4, p2, c3);
              let h2 = g.MACSTRING(s4, f2);
              void 0 === h2 && (o4 = 0, c3 = t3.indexOf(e5), c3 < 0 && (c3 = t3.length, t3.push(e5)), p2 = 4, h2 = g.UTF16(s4));
              const d2 = Xe(h2, u2);
              l2.push(je(o4, p2, c3, n3, h2.length, d2));
              const m2 = i3[e5];
              if (void 0 !== m2) {
                const e6 = g.UTF16(s4), t4 = Xe(e6, u2);
                l2.push(je(3, 1, m2, n3, e6.length, t4));
              }
            }
          }
          l2.sort(function(e4, t4) {
            return e4.platformID - t4.platformID || e4.encodingID - t4.encodingID || e4.languageID - t4.languageID || e4.nameID - t4.nameID;
          });
          const c2 = new M.Table("name", [{ name: "format", type: "USHORT", value: 0 }, { name: "count", type: "USHORT", value: l2.length }, { name: "stringOffset", type: "USHORT", value: 6 + 12 * l2.length }]);
          for (let e4 = 0; e4 < l2.length; e4++)
            c2.fields.push({ name: "record_" + e4, type: "RECORD", value: l2[e4] });
          return c2.fields.push({ name: "strings", type: "LITERAL", value: u2 }), c2;
        } }, Ye = [{ begin: 0, end: 127 }, { begin: 128, end: 255 }, { begin: 256, end: 383 }, { begin: 384, end: 591 }, { begin: 592, end: 687 }, { begin: 688, end: 767 }, { begin: 768, end: 879 }, { begin: 880, end: 1023 }, { begin: 11392, end: 11519 }, { begin: 1024, end: 1279 }, { begin: 1328, end: 1423 }, { begin: 1424, end: 1535 }, { begin: 42240, end: 42559 }, { begin: 1536, end: 1791 }, { begin: 1984, end: 2047 }, { begin: 2304, end: 2431 }, { begin: 2432, end: 2559 }, { begin: 2560, end: 2687 }, { begin: 2688, end: 2815 }, { begin: 2816, end: 2943 }, { begin: 2944, end: 3071 }, { begin: 3072, end: 3199 }, { begin: 3200, end: 3327 }, { begin: 3328, end: 3455 }, { begin: 3584, end: 3711 }, { begin: 3712, end: 3839 }, { begin: 4256, end: 4351 }, { begin: 6912, end: 7039 }, { begin: 4352, end: 4607 }, { begin: 7680, end: 7935 }, { begin: 7936, end: 8191 }, { begin: 8192, end: 8303 }, { begin: 8304, end: 8351 }, { begin: 8352, end: 8399 }, { begin: 8400, end: 8447 }, { begin: 8448, end: 8527 }, { begin: 8528, end: 8591 }, { begin: 8592, end: 8703 }, { begin: 8704, end: 8959 }, { begin: 8960, end: 9215 }, { begin: 9216, end: 9279 }, { begin: 9280, end: 9311 }, { begin: 9312, end: 9471 }, { begin: 9472, end: 9599 }, { begin: 9600, end: 9631 }, { begin: 9632, end: 9727 }, { begin: 9728, end: 9983 }, { begin: 9984, end: 10175 }, { begin: 12288, end: 12351 }, { begin: 12352, end: 12447 }, { begin: 12448, end: 12543 }, { begin: 12544, end: 12591 }, { begin: 12592, end: 12687 }, { begin: 43072, end: 43135 }, { begin: 12800, end: 13055 }, { begin: 13056, end: 13311 }, { begin: 44032, end: 55215 }, { begin: 55296, end: 57343 }, { begin: 67840, end: 67871 }, { begin: 19968, end: 40959 }, { begin: 57344, end: 63743 }, { begin: 12736, end: 12783 }, { begin: 64256, end: 64335 }, { begin: 64336, end: 65023 }, { begin: 65056, end: 65071 }, { begin: 65040, end: 65055 }, { begin: 65104, end: 65135 }, { begin: 65136, end: 65279 }, { begin: 65280, end: 65519 }, { begin: 65520, end: 65535 }, { begin: 3840, end: 4095 }, { begin: 1792, end: 1871 }, { begin: 1920, end: 1983 }, { begin: 3456, end: 3583 }, { begin: 4096, end: 4255 }, { begin: 4608, end: 4991 }, { begin: 5024, end: 5119 }, { begin: 5120, end: 5759 }, { begin: 5760, end: 5791 }, { begin: 5792, end: 5887 }, { begin: 6016, end: 6143 }, { begin: 6144, end: 6319 }, { begin: 10240, end: 10495 }, { begin: 40960, end: 42127 }, { begin: 5888, end: 5919 }, { begin: 66304, end: 66351 }, { begin: 66352, end: 66383 }, { begin: 66560, end: 66639 }, { begin: 118784, end: 119039 }, { begin: 119808, end: 120831 }, { begin: 1044480, end: 1048573 }, { begin: 65024, end: 65039 }, { begin: 917504, end: 917631 }, { begin: 6400, end: 6479 }, { begin: 6480, end: 6527 }, { begin: 6528, end: 6623 }, { begin: 6656, end: 6687 }, { begin: 11264, end: 11359 }, { begin: 11568, end: 11647 }, { begin: 19904, end: 19967 }, { begin: 43008, end: 43055 }, { begin: 65536, end: 65663 }, { begin: 65856, end: 65935 }, { begin: 66432, end: 66463 }, { begin: 66464, end: 66527 }, { begin: 66640, end: 66687 }, { begin: 66688, end: 66735 }, { begin: 67584, end: 67647 }, { begin: 68096, end: 68191 }, { begin: 119552, end: 119647 }, { begin: 73728, end: 74751 }, { begin: 119648, end: 119679 }, { begin: 7040, end: 7103 }, { begin: 7168, end: 7247 }, { begin: 7248, end: 7295 }, { begin: 43136, end: 43231 }, { begin: 43264, end: 43311 }, { begin: 43312, end: 43359 }, { begin: 43520, end: 43615 }, { begin: 65936, end: 65999 }, { begin: 66e3, end: 66047 }, { begin: 66208, end: 66271 }, { begin: 127024, end: 127135 }], Ze = { parse: function(e3, t3) {
          const n3 = {}, s3 = new z.Parser(e3, t3);
          n3.version = s3.parseUShort(), n3.xAvgCharWidth = s3.parseShort(), n3.usWeightClass = s3.parseUShort(), n3.usWidthClass = s3.parseUShort(), n3.fsType = s3.parseUShort(), n3.ySubscriptXSize = s3.parseShort(), n3.ySubscriptYSize = s3.parseShort(), n3.ySubscriptXOffset = s3.parseShort(), n3.ySubscriptYOffset = s3.parseShort(), n3.ySuperscriptXSize = s3.parseShort(), n3.ySuperscriptYSize = s3.parseShort(), n3.ySuperscriptXOffset = s3.parseShort(), n3.ySuperscriptYOffset = s3.parseShort(), n3.yStrikeoutSize = s3.parseShort(), n3.yStrikeoutPosition = s3.parseShort(), n3.sFamilyClass = s3.parseShort(), n3.panose = [];
          for (let e4 = 0; e4 < 10; e4++)
            n3.panose[e4] = s3.parseByte();
          return n3.ulUnicodeRange1 = s3.parseULong(), n3.ulUnicodeRange2 = s3.parseULong(), n3.ulUnicodeRange3 = s3.parseULong(), n3.ulUnicodeRange4 = s3.parseULong(), n3.achVendID = String.fromCharCode(s3.parseByte(), s3.parseByte(), s3.parseByte(), s3.parseByte()), n3.fsSelection = s3.parseUShort(), n3.usFirstCharIndex = s3.parseUShort(), n3.usLastCharIndex = s3.parseUShort(), n3.sTypoAscender = s3.parseShort(), n3.sTypoDescender = s3.parseShort(), n3.sTypoLineGap = s3.parseShort(), n3.usWinAscent = s3.parseUShort(), n3.usWinDescent = s3.parseUShort(), n3.version >= 1 && (n3.ulCodePageRange1 = s3.parseULong(), n3.ulCodePageRange2 = s3.parseULong()), n3.version >= 2 && (n3.sxHeight = s3.parseShort(), n3.sCapHeight = s3.parseShort(), n3.usDefaultChar = s3.parseUShort(), n3.usBreakChar = s3.parseUShort(), n3.usMaxContent = s3.parseUShort()), n3;
        }, make: function(e3) {
          return new M.Table("OS/2", [{ name: "version", type: "USHORT", value: 3 }, { name: "xAvgCharWidth", type: "SHORT", value: 0 }, { name: "usWeightClass", type: "USHORT", value: 0 }, { name: "usWidthClass", type: "USHORT", value: 0 }, { name: "fsType", type: "USHORT", value: 0 }, { name: "ySubscriptXSize", type: "SHORT", value: 650 }, { name: "ySubscriptYSize", type: "SHORT", value: 699 }, { name: "ySubscriptXOffset", type: "SHORT", value: 0 }, { name: "ySubscriptYOffset", type: "SHORT", value: 140 }, { name: "ySuperscriptXSize", type: "SHORT", value: 650 }, { name: "ySuperscriptYSize", type: "SHORT", value: 699 }, { name: "ySuperscriptXOffset", type: "SHORT", value: 0 }, { name: "ySuperscriptYOffset", type: "SHORT", value: 479 }, { name: "yStrikeoutSize", type: "SHORT", value: 49 }, { name: "yStrikeoutPosition", type: "SHORT", value: 258 }, { name: "sFamilyClass", type: "SHORT", value: 0 }, { name: "bFamilyType", type: "BYTE", value: 0 }, { name: "bSerifStyle", type: "BYTE", value: 0 }, { name: "bWeight", type: "BYTE", value: 0 }, { name: "bProportion", type: "BYTE", value: 0 }, { name: "bContrast", type: "BYTE", value: 0 }, { name: "bStrokeVariation", type: "BYTE", value: 0 }, { name: "bArmStyle", type: "BYTE", value: 0 }, { name: "bLetterform", type: "BYTE", value: 0 }, { name: "bMidline", type: "BYTE", value: 0 }, { name: "bXHeight", type: "BYTE", value: 0 }, { name: "ulUnicodeRange1", type: "ULONG", value: 0 }, { name: "ulUnicodeRange2", type: "ULONG", value: 0 }, { name: "ulUnicodeRange3", type: "ULONG", value: 0 }, { name: "ulUnicodeRange4", type: "ULONG", value: 0 }, { name: "achVendID", type: "CHARARRAY", value: "XXXX" }, { name: "fsSelection", type: "USHORT", value: 0 }, { name: "usFirstCharIndex", type: "USHORT", value: 0 }, { name: "usLastCharIndex", type: "USHORT", value: 0 }, { name: "sTypoAscender", type: "SHORT", value: 0 }, { name: "sTypoDescender", type: "SHORT", value: 0 }, { name: "sTypoLineGap", type: "SHORT", value: 0 }, { name: "usWinAscent", type: "USHORT", value: 0 }, { name: "usWinDescent", type: "USHORT", value: 0 }, { name: "ulCodePageRange1", type: "ULONG", value: 0 }, { name: "ulCodePageRange2", type: "ULONG", value: 0 }, { name: "sxHeight", type: "SHORT", value: 0 }, { name: "sCapHeight", type: "SHORT", value: 0 }, { name: "usDefaultChar", type: "USHORT", value: 0 }, { name: "usBreakChar", type: "USHORT", value: 0 }, { name: "usMaxContext", type: "USHORT", value: 0 }], e3);
        }, unicodeRanges: Ye, getUnicodeRange: function(e3) {
          for (let t3 = 0; t3 < Ye.length; t3 += 1) {
            const n3 = Ye[t3];
            if (e3 >= n3.begin && e3 < n3.end)
              return t3;
          }
          return -1;
        } }, Qe = { parse: function(e3, t3) {
          const n3 = {}, s3 = new z.Parser(e3, t3);
          switch (n3.version = s3.parseVersion(), n3.italicAngle = s3.parseFixed(), n3.underlinePosition = s3.parseShort(), n3.underlineThickness = s3.parseShort(), n3.isFixedPitch = s3.parseULong(), n3.minMemType42 = s3.parseULong(), n3.maxMemType42 = s3.parseULong(), n3.minMemType1 = s3.parseULong(), n3.maxMemType1 = s3.parseULong(), n3.version) {
            case 1:
              n3.names = Y.slice();
              break;
            case 2:
              n3.numberOfGlyphs = s3.parseUShort(), n3.glyphNameIndex = new Array(n3.numberOfGlyphs);
              for (let e4 = 0; e4 < n3.numberOfGlyphs; e4++)
                n3.glyphNameIndex[e4] = s3.parseUShort();
              n3.names = [];
              for (let e4 = 0; e4 < n3.numberOfGlyphs; e4++)
                if (n3.glyphNameIndex[e4] >= Y.length) {
                  const e5 = s3.parseChar();
                  n3.names.push(s3.parseString(e5));
                }
              break;
            case 2.5:
              n3.numberOfGlyphs = s3.parseUShort(), n3.offset = new Array(n3.numberOfGlyphs);
              for (let e4 = 0; e4 < n3.numberOfGlyphs; e4++)
                n3.offset[e4] = s3.parseChar();
          }
          return n3;
        }, make: function() {
          return new M.Table("post", [{ name: "version", type: "FIXED", value: 196608 }, { name: "italicAngle", type: "FIXED", value: 0 }, { name: "underlinePosition", type: "FWORD", value: 0 }, { name: "underlineThickness", type: "FWORD", value: 0 }, { name: "isFixedPitch", type: "ULONG", value: 0 }, { name: "minMemType42", type: "ULONG", value: 0 }, { name: "maxMemType42", type: "ULONG", value: 0 }, { name: "minMemType1", type: "ULONG", value: 0 }, { name: "maxMemType1", type: "ULONG", value: 0 }]);
        } }, Je = new Array(9);
        Je[1] = function() {
          const e3 = this.offset + this.relativeOffset, t3 = this.parseUShort();
          return 1 === t3 ? { substFormat: 1, coverage: this.parsePointer(_.coverage), deltaGlyphId: this.parseUShort() } : 2 === t3 ? { substFormat: 2, coverage: this.parsePointer(_.coverage), substitute: this.parseOffset16List() } : void f.assert(false, "0x" + e3.toString(16) + ": lookup type 1 format must be 1 or 2.");
        }, Je[2] = function() {
          const e3 = this.parseUShort();
          return f.argument(1 === e3, "GSUB Multiple Substitution Subtable identifier-format must be 1"), { substFormat: e3, coverage: this.parsePointer(_.coverage), sequences: this.parseListOfLists() };
        }, Je[3] = function() {
          const e3 = this.parseUShort();
          return f.argument(1 === e3, "GSUB Alternate Substitution Subtable identifier-format must be 1"), { substFormat: e3, coverage: this.parsePointer(_.coverage), alternateSets: this.parseListOfLists() };
        }, Je[4] = function() {
          const e3 = this.parseUShort();
          return f.argument(1 === e3, "GSUB ligature table identifier-format must be 1"), { substFormat: e3, coverage: this.parsePointer(_.coverage), ligatureSets: this.parseListOfLists(function() {
            return { ligGlyph: this.parseUShort(), components: this.parseUShortList(this.parseUShort() - 1) };
          }) };
        };
        const Ke = { sequenceIndex: _.uShort, lookupListIndex: _.uShort };
        Je[5] = function() {
          const e3 = this.offset + this.relativeOffset, t3 = this.parseUShort();
          if (1 === t3)
            return { substFormat: t3, coverage: this.parsePointer(_.coverage), ruleSets: this.parseListOfLists(function() {
              const e4 = this.parseUShort(), t4 = this.parseUShort();
              return { input: this.parseUShortList(e4 - 1), lookupRecords: this.parseRecordList(t4, Ke) };
            }) };
          if (2 === t3)
            return { substFormat: t3, coverage: this.parsePointer(_.coverage), classDef: this.parsePointer(_.classDef), classSets: this.parseListOfLists(function() {
              const e4 = this.parseUShort(), t4 = this.parseUShort();
              return { classes: this.parseUShortList(e4 - 1), lookupRecords: this.parseRecordList(t4, Ke) };
            }) };
          if (3 === t3) {
            const e4 = this.parseUShort(), n3 = this.parseUShort();
            return { substFormat: t3, coverages: this.parseList(e4, _.pointer(_.coverage)), lookupRecords: this.parseRecordList(n3, Ke) };
          }
          f.assert(false, "0x" + e3.toString(16) + ": lookup type 5 format must be 1, 2 or 3.");
        }, Je[6] = function() {
          const e3 = this.offset + this.relativeOffset, t3 = this.parseUShort();
          return 1 === t3 ? { substFormat: 1, coverage: this.parsePointer(_.coverage), chainRuleSets: this.parseListOfLists(function() {
            return { backtrack: this.parseUShortList(), input: this.parseUShortList(this.parseShort() - 1), lookahead: this.parseUShortList(), lookupRecords: this.parseRecordList(Ke) };
          }) } : 2 === t3 ? { substFormat: 2, coverage: this.parsePointer(_.coverage), backtrackClassDef: this.parsePointer(_.classDef), inputClassDef: this.parsePointer(_.classDef), lookaheadClassDef: this.parsePointer(_.classDef), chainClassSet: this.parseListOfLists(function() {
            return { backtrack: this.parseUShortList(), input: this.parseUShortList(this.parseShort() - 1), lookahead: this.parseUShortList(), lookupRecords: this.parseRecordList(Ke) };
          }) } : 3 === t3 ? { substFormat: 3, backtrackCoverage: this.parseList(_.pointer(_.coverage)), inputCoverage: this.parseList(_.pointer(_.coverage)), lookaheadCoverage: this.parseList(_.pointer(_.coverage)), lookupRecords: this.parseRecordList(Ke) } : void f.assert(false, "0x" + e3.toString(16) + ": lookup type 6 format must be 1, 2 or 3.");
        }, Je[7] = function() {
          const e3 = this.parseUShort();
          f.argument(1 === e3, "GSUB Extension Substitution subtable identifier-format must be 1");
          const t3 = this.parseUShort(), n3 = new _(this.data, this.offset + this.parseULong());
          return { substFormat: 1, lookupType: t3, extension: Je[t3].call(n3) };
        }, Je[8] = function() {
          const e3 = this.parseUShort();
          return f.argument(1 === e3, "GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1"), { substFormat: e3, coverage: this.parsePointer(_.coverage), backtrackCoverage: this.parseList(_.pointer(_.coverage)), lookaheadCoverage: this.parseList(_.pointer(_.coverage)), substitutes: this.parseUShortList() };
        };
        const $e = new Array(9);
        $e[1] = function(e3) {
          return 1 === e3.substFormat ? new M.Table("substitutionTable", [{ name: "substFormat", type: "USHORT", value: 1 }, { name: "coverage", type: "TABLE", value: new M.Coverage(e3.coverage) }, { name: "deltaGlyphID", type: "USHORT", value: e3.deltaGlyphId }]) : new M.Table("substitutionTable", [{ name: "substFormat", type: "USHORT", value: 2 }, { name: "coverage", type: "TABLE", value: new M.Coverage(e3.coverage) }].concat(M.ushortList("substitute", e3.substitute)));
        }, $e[3] = function(e3) {
          return f.assert(1 === e3.substFormat, "Lookup type 3 substFormat must be 1."), new M.Table("substitutionTable", [{ name: "substFormat", type: "USHORT", value: 1 }, { name: "coverage", type: "TABLE", value: new M.Coverage(e3.coverage) }].concat(M.tableList("altSet", e3.alternateSets, function(e4) {
            return new M.Table("alternateSetTable", M.ushortList("alternate", e4));
          })));
        }, $e[4] = function(e3) {
          return f.assert(1 === e3.substFormat, "Lookup type 4 substFormat must be 1."), new M.Table("substitutionTable", [{ name: "substFormat", type: "USHORT", value: 1 }, { name: "coverage", type: "TABLE", value: new M.Coverage(e3.coverage) }].concat(M.tableList("ligSet", e3.ligatureSets, function(e4) {
            return new M.Table("ligatureSetTable", M.tableList("ligature", e4, function(e5) {
              return new M.Table("ligatureTable", [{ name: "ligGlyph", type: "USHORT", value: e5.ligGlyph }].concat(M.ushortList("component", e5.components, e5.components.length + 1)));
            }));
          })));
        };
        const et = { parse: function(e3, t3) {
          const n3 = new _(e3, t3 = t3 || 0), s3 = n3.parseVersion(1);
          return f.argument(1 === s3 || 1.1 === s3, "Unsupported GSUB table version."), 1 === s3 ? { version: s3, scripts: n3.parseScriptList(), features: n3.parseFeatureList(), lookups: n3.parseLookupList(Je) } : { version: s3, scripts: n3.parseScriptList(), features: n3.parseFeatureList(), lookups: n3.parseLookupList(Je), variations: n3.parseFeatureVariationsList() };
        }, make: function(e3) {
          return new M.Table("GSUB", [{ name: "version", type: "ULONG", value: 65536 }, { name: "scripts", type: "TABLE", value: new M.ScriptList(e3.scripts) }, { name: "features", type: "TABLE", value: new M.FeatureList(e3.features) }, { name: "lookups", type: "TABLE", value: new M.LookupList(e3.lookups, $e) }]);
        } }, tt = { parse: function(e3, t3) {
          const n3 = new z.Parser(e3, t3), s3 = n3.parseULong();
          f.argument(1 === s3, "Unsupported META table version."), n3.parseULong(), n3.parseULong();
          const o3 = n3.parseULong(), r3 = {};
          for (let s4 = 0; s4 < o3; s4++) {
            const s5 = n3.parseTag(), o4 = n3.parseULong(), a3 = n3.parseULong(), i3 = d.UTF8(e3, t3 + o4, a3);
            r3[s5] = i3;
          }
          return r3;
        }, make: function(e3) {
          const t3 = Object.keys(e3).length;
          let n3 = "";
          const s3 = 16 + 12 * t3, o3 = new M.Table("meta", [{ name: "version", type: "ULONG", value: 1 }, { name: "flags", type: "ULONG", value: 0 }, { name: "offset", type: "ULONG", value: s3 }, { name: "numTags", type: "ULONG", value: t3 }]);
          for (let t4 in e3) {
            const r3 = n3.length;
            n3 += e3[t4], o3.fields.push({ name: "tag " + t4, type: "TAG", value: t4 }), o3.fields.push({ name: "offset " + t4, type: "ULONG", value: s3 + r3 }), o3.fields.push({ name: "length " + t4, type: "ULONG", value: e3[t4].length });
          }
          return o3.fields.push({ name: "stringPool", type: "CHARARRAY", value: n3 }), o3;
        } };
        function nt(e3) {
          return Math.log(e3) / Math.log(2) | 0;
        }
        function st(e3) {
          for (; e3.length % 4 != 0; )
            e3.push(0);
          let t3 = 0;
          for (let n3 = 0; n3 < e3.length; n3 += 4)
            t3 += (e3[n3] << 24) + (e3[n3 + 1] << 16) + (e3[n3 + 2] << 8) + e3[n3 + 3];
          return t3 %= Math.pow(2, 32), t3;
        }
        function ot(e3, t3, n3, s3) {
          return new M.Record("Table Record", [{ name: "tag", type: "TAG", value: void 0 !== e3 ? e3 : "" }, { name: "checkSum", type: "ULONG", value: void 0 !== t3 ? t3 : 0 }, { name: "offset", type: "ULONG", value: void 0 !== n3 ? n3 : 0 }, { name: "length", type: "ULONG", value: void 0 !== s3 ? s3 : 0 }]);
        }
        function rt(e3) {
          const t3 = new M.Table("sfnt", [{ name: "version", type: "TAG", value: "OTTO" }, { name: "numTables", type: "USHORT", value: 0 }, { name: "searchRange", type: "USHORT", value: 0 }, { name: "entrySelector", type: "USHORT", value: 0 }, { name: "rangeShift", type: "USHORT", value: 0 }]);
          t3.tables = e3, t3.numTables = e3.length;
          const n3 = Math.pow(2, nt(t3.numTables));
          t3.searchRange = 16 * n3, t3.entrySelector = nt(n3), t3.rangeShift = 16 * t3.numTables - t3.searchRange;
          const s3 = [], o3 = [];
          let r3 = t3.sizeOf() + ot().sizeOf() * t3.numTables;
          for (; r3 % 4 != 0; )
            r3 += 1, o3.push({ name: "padding", type: "BYTE", value: 0 });
          for (let t4 = 0; t4 < e3.length; t4 += 1) {
            const n4 = e3[t4];
            f.argument(4 === n4.tableName.length, "Table name" + n4.tableName + " is invalid.");
            const a3 = n4.sizeOf(), i3 = ot(n4.tableName, st(n4.encode()), r3, a3);
            for (s3.push({ name: i3.tag + " Table Record", type: "RECORD", value: i3 }), o3.push({ name: n4.tableName + " table", type: "RECORD", value: n4 }), r3 += a3, f.argument(!isNaN(r3), "Something went wrong calculating the offset."); r3 % 4 != 0; )
              r3 += 1, o3.push({ name: "padding", type: "BYTE", value: 0 });
          }
          return s3.sort(function(e4, t4) {
            return e4.value.tag > t4.value.tag ? 1 : -1;
          }), t3.fields = t3.fields.concat(s3), t3.fields = t3.fields.concat(o3), t3;
        }
        function at(e3, t3, n3) {
          for (let n4 = 0; n4 < t3.length; n4 += 1) {
            const s3 = e3.charToGlyphIndex(t3[n4]);
            if (s3 > 0)
              return e3.glyphs.get(s3).getMetrics();
          }
          return n3;
        }
        function it(e3) {
          let t3 = 0;
          for (let n3 = 0; n3 < e3.length; n3 += 1)
            t3 += e3[n3];
          return t3 / e3.length;
        }
        const lt = function(e3) {
          const t3 = [], n3 = [], s3 = [], o3 = [], r3 = [], a3 = [], i3 = [];
          let l2, u2 = 0, c2 = 0, p2 = 0, f2 = 0, h2 = 0;
          for (let d3 = 0; d3 < e3.glyphs.length; d3 += 1) {
            const g3 = e3.glyphs.get(d3), m3 = 0 | g3.unicode;
            if (isNaN(g3.advanceWidth))
              throw new Error("Glyph " + g3.name + " (" + d3 + "): advanceWidth is not a number.");
            (l2 > m3 || void 0 === l2) && m3 > 0 && (l2 = m3), u2 < m3 && (u2 = m3);
            const y3 = Ze.getUnicodeRange(m3);
            if (y3 < 32)
              c2 |= 1 << y3;
            else if (y3 < 64)
              p2 |= 1 << y3 - 32;
            else if (y3 < 96)
              f2 |= 1 << y3 - 64;
            else {
              if (!(y3 < 123))
                throw new Error("Unicode ranges bits > 123 are reserved for internal usage");
              h2 |= 1 << y3 - 96;
            }
            if (".notdef" === g3.name)
              continue;
            const v3 = g3.getMetrics();
            t3.push(v3.xMin), n3.push(v3.yMin), s3.push(v3.xMax), o3.push(v3.yMax), a3.push(v3.leftSideBearing), i3.push(v3.rightSideBearing), r3.push(g3.advanceWidth);
          }
          const d2 = { xMin: Math.min.apply(null, t3), yMin: Math.min.apply(null, n3), xMax: Math.max.apply(null, s3), yMax: Math.max.apply(null, o3), advanceWidthMax: Math.max.apply(null, r3), advanceWidthAvg: it(r3), minLeftSideBearing: Math.min.apply(null, a3), maxLeftSideBearing: Math.max.apply(null, a3), minRightSideBearing: Math.min.apply(null, i3) };
          d2.ascender = e3.ascender, d2.descender = e3.descender;
          const g2 = Le.make({ flags: 3, unitsPerEm: e3.unitsPerEm, xMin: d2.xMin, yMin: d2.yMin, xMax: d2.xMax, yMax: d2.yMax, lowestRecPPEM: 3, createdTimestamp: e3.createdTimestamp }), m2 = Be.make({ ascender: d2.ascender, descender: d2.descender, advanceWidthMax: d2.advanceWidthMax, minLeftSideBearing: d2.minLeftSideBearing, minRightSideBearing: d2.minRightSideBearing, xMaxExtent: d2.maxLeftSideBearing + (d2.xMax - d2.xMin), numberOfHMetrics: e3.glyphs.length }), y2 = Me.make(e3.glyphs.length), v2 = Ze.make({ xAvgCharWidth: Math.round(d2.advanceWidthAvg), usWeightClass: e3.tables.os2.usWeightClass, usWidthClass: e3.tables.os2.usWidthClass, usFirstCharIndex: l2, usLastCharIndex: u2, ulUnicodeRange1: c2, ulUnicodeRange2: p2, ulUnicodeRange3: f2, ulUnicodeRange4: h2, fsSelection: e3.tables.os2.fsSelection, sTypoAscender: d2.ascender, sTypoDescender: d2.descender, sTypoLineGap: 0, usWinAscent: d2.yMax, usWinDescent: Math.abs(d2.yMin), ulCodePageRange1: 1, sxHeight: at(e3, "xyvw", { yMax: Math.round(d2.ascender / 2) }).yMax, sCapHeight: at(e3, "HIKLEFJMNTZBDPRAGOQSUVWXY", d2).yMax, usDefaultChar: e3.hasChar(" ") ? 32 : 0, usBreakChar: e3.hasChar(" ") ? 32 : 0 }), b2 = Ce.make(e3.glyphs), x2 = q.make(e3.glyphs), S2 = e3.getEnglishName("fontFamily"), U2 = e3.getEnglishName("fontSubfamily"), k2 = S2 + " " + U2;
          let T2 = e3.getEnglishName("postScriptName");
          T2 || (T2 = S2.replace(/\s/g, "") + "-" + U2);
          const E2 = {};
          for (let t4 in e3.names)
            E2[t4] = e3.names[t4];
          E2.uniqueID || (E2.uniqueID = { en: e3.getEnglishName("manufacturer") + ":" + k2 }), E2.postScriptName || (E2.postScriptName = { en: T2 }), E2.preferredFamily || (E2.preferredFamily = e3.names.fontFamily), E2.preferredSubfamily || (E2.preferredSubfamily = e3.names.fontSubfamily);
          const w2 = [], O2 = Ve.make(E2, w2), I2 = w2.length > 0 ? De.make(w2) : void 0, R2 = Qe.make(), L2 = Re.make(e3.glyphs, { version: e3.getEnglishName("version"), fullName: k2, familyName: S2, weightName: U2, postScriptName: T2, unitsPerEm: e3.unitsPerEm, fontBBox: [0, d2.yMin, d2.ascender, d2.advanceWidthMax] }), B2 = e3.metas && Object.keys(e3.metas).length > 0 ? tt.make(e3.metas) : void 0, C2 = [g2, m2, y2, v2, O2, x2, R2, L2, b2];
          I2 && C2.push(I2), e3.tables.gsub && C2.push(et.make(e3.tables.gsub)), B2 && C2.push(B2);
          const D2 = rt(C2), M2 = st(D2.encode()), A2 = D2.fields;
          let P2 = false;
          for (let e4 = 0; e4 < A2.length; e4 += 1)
            if ("head table" === A2[e4].name) {
              A2[e4].value.checkSumAdjustment = 2981146554 - M2, P2 = true;
              break;
            }
          if (!P2)
            throw new Error("Could not find head table with checkSum to adjust.");
          return D2;
        };
        function ut(e3, t3) {
          let n3 = 0, s3 = e3.length - 1;
          for (; n3 <= s3; ) {
            const o3 = n3 + s3 >>> 1, r3 = e3[o3].tag;
            if (r3 === t3)
              return o3;
            r3 < t3 ? n3 = o3 + 1 : s3 = o3 - 1;
          }
          return -n3 - 1;
        }
        function ct(e3, t3) {
          let n3 = 0, s3 = e3.length - 1;
          for (; n3 <= s3; ) {
            const o3 = n3 + s3 >>> 1, r3 = e3[o3];
            if (r3 === t3)
              return o3;
            r3 < t3 ? n3 = o3 + 1 : s3 = o3 - 1;
          }
          return -n3 - 1;
        }
        function pt(e3, t3) {
          let n3, s3 = 0, o3 = e3.length - 1;
          for (; s3 <= o3; ) {
            const r3 = s3 + o3 >>> 1;
            n3 = e3[r3];
            const a3 = n3.start;
            if (a3 === t3)
              return n3;
            a3 < t3 ? s3 = r3 + 1 : o3 = r3 - 1;
          }
          if (s3 > 0)
            return n3 = e3[s3 - 1], t3 > n3.end ? 0 : n3;
        }
        function ft(e3, t3) {
          this.font = e3, this.tableName = t3;
        }
        ft.prototype = { searchTag: ut, binSearch: ct, getTable: function(e3) {
          let t3 = this.font.tables[this.tableName];
          return !t3 && e3 && (t3 = this.font.tables[this.tableName] = this.createDefaultTable()), t3;
        }, getScriptNames: function() {
          let e3 = this.getTable();
          return e3 ? e3.scripts.map(function(e4) {
            return e4.tag;
          }) : [];
        }, getDefaultScriptName: function() {
          let e3 = this.getTable();
          if (!e3)
            return;
          let t3 = false;
          for (let n3 = 0; n3 < e3.scripts.length; n3++) {
            const s3 = e3.scripts[n3].tag;
            if ("DFLT" === s3)
              return s3;
            "latn" === s3 && (t3 = true);
          }
          return t3 ? "latn" : void 0;
        }, getScriptTable: function(e3, t3) {
          const n3 = this.getTable(t3);
          if (n3) {
            e3 = e3 || "DFLT";
            const s3 = n3.scripts, o3 = ut(n3.scripts, e3);
            if (o3 >= 0)
              return s3[o3].script;
            if (t3) {
              const t4 = { tag: e3, script: { defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] }, langSysRecords: [] } };
              return s3.splice(-1 - o3, 0, t4), t4.script;
            }
          }
        }, getLangSysTable: function(e3, t3, n3) {
          const s3 = this.getScriptTable(e3, n3);
          if (s3) {
            if (!t3 || "dflt" === t3 || "DFLT" === t3)
              return s3.defaultLangSys;
            const e4 = ut(s3.langSysRecords, t3);
            if (e4 >= 0)
              return s3.langSysRecords[e4].langSys;
            if (n3) {
              const n4 = { tag: t3, langSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] } };
              return s3.langSysRecords.splice(-1 - e4, 0, n4), n4.langSys;
            }
          }
        }, getFeatureTable: function(e3, t3, n3, s3) {
          const o3 = this.getLangSysTable(e3, t3, s3);
          if (o3) {
            let e4;
            const t4 = o3.featureIndexes, r3 = this.font.tables[this.tableName].features;
            for (let s4 = 0; s4 < t4.length; s4++)
              if (e4 = r3[t4[s4]], e4.tag === n3)
                return e4.feature;
            if (s3) {
              const s4 = r3.length;
              return f.assert(0 === s4 || n3 >= r3[s4 - 1].tag, "Features must be added in alphabetical order."), e4 = { tag: n3, feature: { params: 0, lookupListIndexes: [] } }, r3.push(e4), t4.push(s4), e4.feature;
            }
          }
        }, getLookupTables: function(e3, t3, n3, s3, o3) {
          const r3 = this.getFeatureTable(e3, t3, n3, o3), a3 = [];
          if (r3) {
            let e4;
            const t4 = r3.lookupListIndexes, n4 = this.font.tables[this.tableName].lookups;
            for (let o4 = 0; o4 < t4.length; o4++)
              e4 = n4[t4[o4]], e4.lookupType === s3 && a3.push(e4);
            if (0 === a3.length && o3) {
              e4 = { lookupType: s3, lookupFlag: 0, subtables: [], markFilteringSet: void 0 };
              const o4 = n4.length;
              return n4.push(e4), t4.push(o4), [e4];
            }
          }
          return a3;
        }, getGlyphClass: function(e3, t3) {
          switch (e3.format) {
            case 1:
              return e3.startGlyph <= t3 && t3 < e3.startGlyph + e3.classes.length ? e3.classes[t3 - e3.startGlyph] : 0;
            case 2:
              const n3 = pt(e3.ranges, t3);
              return n3 ? n3.classId : 0;
          }
        }, getCoverageIndex: function(e3, t3) {
          switch (e3.format) {
            case 1:
              const n3 = ct(e3.glyphs, t3);
              return n3 >= 0 ? n3 : -1;
            case 2:
              const s3 = pt(e3.ranges, t3);
              return s3 ? s3.index + t3 - s3.start : -1;
          }
        }, expandCoverage: function(e3) {
          if (1 === e3.format)
            return e3.glyphs;
          {
            const t3 = [], n3 = e3.ranges;
            for (let e4 = 0; e4 < n3.length; e4++) {
              const s3 = n3[e4], o3 = s3.start, r3 = s3.end;
              for (let e5 = o3; e5 <= r3; e5++)
                t3.push(e5);
            }
            return t3;
          }
        } };
        const ht = ft;
        function dt(e3) {
          ht.call(this, e3, "gpos");
        }
        dt.prototype = ht.prototype, dt.prototype.getKerningValue = function(e3, t3, n3) {
          for (let s3 = 0; s3 < e3.length; s3++) {
            const o3 = e3[s3].subtables;
            for (let e4 = 0; e4 < o3.length; e4++) {
              const s4 = o3[e4], r3 = this.getCoverageIndex(s4.coverage, t3);
              if (!(r3 < 0))
                switch (s4.posFormat) {
                  case 1:
                    let e5 = s4.pairSets[r3];
                    for (let t4 = 0; t4 < e5.length; t4++) {
                      let s5 = e5[t4];
                      if (s5.secondGlyph === n3)
                        return s5.value1 && s5.value1.xAdvance || 0;
                    }
                    break;
                  case 2:
                    const o4 = this.getGlyphClass(s4.classDef1, t3), a3 = this.getGlyphClass(s4.classDef2, n3), i3 = s4.classRecords[o4][a3];
                    return i3.value1 && i3.value1.xAdvance || 0;
                }
            }
          }
          return 0;
        }, dt.prototype.getKerningTables = function(e3, t3) {
          if (this.font.tables.gpos)
            return this.getLookupTables(e3, t3, "kern", 2);
        };
        const gt = dt;
        function mt(e3) {
          ht.call(this, e3, "gsub");
        }
        function yt(e3, t3) {
          const n3 = e3.length;
          if (n3 !== t3.length)
            return false;
          for (let s3 = 0; s3 < n3; s3++)
            if (e3[s3] !== t3[s3])
              return false;
          return true;
        }
        function vt(e3, t3, n3) {
          const s3 = e3.subtables;
          for (let e4 = 0; e4 < s3.length; e4++) {
            const n4 = s3[e4];
            if (n4.substFormat === t3)
              return n4;
          }
          if (n3)
            return s3.push(n3), n3;
        }
        mt.prototype = ht.prototype, mt.prototype.createDefaultTable = function() {
          return { version: 1, scripts: [{ tag: "DFLT", script: { defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] }, langSysRecords: [] } }], features: [], lookups: [] };
        }, mt.prototype.getSingle = function(e3, t3, n3) {
          const s3 = [], o3 = this.getLookupTables(t3, n3, e3, 1);
          for (let e4 = 0; e4 < o3.length; e4++) {
            const t4 = o3[e4].subtables;
            for (let e5 = 0; e5 < t4.length; e5++) {
              const n4 = t4[e5], o4 = this.expandCoverage(n4.coverage);
              let r3;
              if (1 === n4.substFormat) {
                const e6 = n4.deltaGlyphId;
                for (r3 = 0; r3 < o4.length; r3++) {
                  const t5 = o4[r3];
                  s3.push({ sub: t5, by: t5 + e6 });
                }
              } else {
                const e6 = n4.substitute;
                for (r3 = 0; r3 < o4.length; r3++)
                  s3.push({ sub: o4[r3], by: e6[r3] });
              }
            }
          }
          return s3;
        }, mt.prototype.getAlternates = function(e3, t3, n3) {
          const s3 = [], o3 = this.getLookupTables(t3, n3, e3, 3);
          for (let e4 = 0; e4 < o3.length; e4++) {
            const t4 = o3[e4].subtables;
            for (let e5 = 0; e5 < t4.length; e5++) {
              const n4 = t4[e5], o4 = this.expandCoverage(n4.coverage), r3 = n4.alternateSets;
              for (let e6 = 0; e6 < o4.length; e6++)
                s3.push({ sub: o4[e6], by: r3[e6] });
            }
          }
          return s3;
        }, mt.prototype.getLigatures = function(e3, t3, n3) {
          const s3 = [], o3 = this.getLookupTables(t3, n3, e3, 4);
          for (let e4 = 0; e4 < o3.length; e4++) {
            const t4 = o3[e4].subtables;
            for (let e5 = 0; e5 < t4.length; e5++) {
              const n4 = t4[e5], o4 = this.expandCoverage(n4.coverage), r3 = n4.ligatureSets;
              for (let e6 = 0; e6 < o4.length; e6++) {
                const t5 = o4[e6], n5 = r3[e6];
                for (let e7 = 0; e7 < n5.length; e7++) {
                  const o5 = n5[e7];
                  s3.push({ sub: [t5].concat(o5.components), by: o5.ligGlyph });
                }
              }
            }
          }
          return s3;
        }, mt.prototype.addSingle = function(e3, t3, n3, s3) {
          const o3 = vt(this.getLookupTables(n3, s3, e3, 1, true)[0], 2, { substFormat: 2, coverage: { format: 1, glyphs: [] }, substitute: [] });
          f.assert(1 === o3.coverage.format, "Ligature: unable to modify coverage table format " + o3.coverage.format);
          const r3 = t3.sub;
          let a3 = this.binSearch(o3.coverage.glyphs, r3);
          a3 < 0 && (a3 = -1 - a3, o3.coverage.glyphs.splice(a3, 0, r3), o3.substitute.splice(a3, 0, 0)), o3.substitute[a3] = t3.by;
        }, mt.prototype.addAlternate = function(e3, t3, n3, s3) {
          const o3 = vt(this.getLookupTables(n3, s3, e3, 3, true)[0], 1, { substFormat: 1, coverage: { format: 1, glyphs: [] }, alternateSets: [] });
          f.assert(1 === o3.coverage.format, "Ligature: unable to modify coverage table format " + o3.coverage.format);
          const r3 = t3.sub;
          let a3 = this.binSearch(o3.coverage.glyphs, r3);
          a3 < 0 && (a3 = -1 - a3, o3.coverage.glyphs.splice(a3, 0, r3), o3.alternateSets.splice(a3, 0, 0)), o3.alternateSets[a3] = t3.by;
        }, mt.prototype.addLigature = function(e3, t3, n3, s3) {
          const o3 = this.getLookupTables(n3, s3, e3, 4, true)[0];
          let r3 = o3.subtables[0];
          r3 || (r3 = { substFormat: 1, coverage: { format: 1, glyphs: [] }, ligatureSets: [] }, o3.subtables[0] = r3), f.assert(1 === r3.coverage.format, "Ligature: unable to modify coverage table format " + r3.coverage.format);
          const a3 = t3.sub[0], i3 = t3.sub.slice(1), l2 = { ligGlyph: t3.by, components: i3 };
          let u2 = this.binSearch(r3.coverage.glyphs, a3);
          if (u2 >= 0) {
            const e4 = r3.ligatureSets[u2];
            for (let t4 = 0; t4 < e4.length; t4++)
              if (yt(e4[t4].components, i3))
                return;
            e4.push(l2);
          } else
            u2 = -1 - u2, r3.coverage.glyphs.splice(u2, 0, a3), r3.ligatureSets.splice(u2, 0, [l2]);
        }, mt.prototype.getFeature = function(e3, t3, n3) {
          if (/ss\d\d/.test(e3))
            return this.getSingle(e3, t3, n3);
          switch (e3) {
            case "aalt":
            case "salt":
              return this.getSingle(e3, t3, n3).concat(this.getAlternates(e3, t3, n3));
            case "dlig":
            case "liga":
            case "rlig":
              return this.getLigatures(e3, t3, n3);
          }
        }, mt.prototype.add = function(e3, t3, n3, s3) {
          if (/ss\d\d/.test(e3))
            return this.addSingle(e3, t3, n3, s3);
          switch (e3) {
            case "aalt":
            case "salt":
              return "number" == typeof t3.by ? this.addSingle(e3, t3, n3, s3) : this.addAlternate(e3, t3, n3, s3);
            case "dlig":
            case "liga":
            case "rlig":
              return this.addLigature(e3, t3, n3, s3);
          }
        };
        const bt = mt;
        function xt(e3) {
          const t3 = new ArrayBuffer(e3.length), n3 = new Uint8Array(t3);
          for (let t4 = 0; t4 < e3.length; ++t4)
            n3[t4] = e3[t4];
          return t3;
        }
        function St(e3, t3) {
          if (!e3)
            throw t3;
        }
        let Ut, kt, Tt, Et;
        function wt(e3) {
          this.font = e3, this._fpgmState = this._prepState = void 0, this._errorState = 0;
        }
        function Ot(e3) {
          return e3;
        }
        function It(e3) {
          return Math.sign(e3) * Math.round(Math.abs(e3));
        }
        function Rt(e3) {
          return Math.sign(e3) * Math.round(Math.abs(2 * e3)) / 2;
        }
        function Lt(e3) {
          return Math.sign(e3) * (Math.round(Math.abs(e3) + 0.5) - 0.5);
        }
        function Bt(e3) {
          return Math.sign(e3) * Math.ceil(Math.abs(e3));
        }
        function Ct(e3) {
          return Math.sign(e3) * Math.floor(Math.abs(e3));
        }
        const Dt = function(e3) {
          const t3 = this.srPeriod;
          let n3 = this.srPhase, s3 = 1;
          return e3 < 0 && (e3 = -e3, s3 = -1), e3 += this.srThreshold - n3, e3 = Math.trunc(e3 / t3) * t3, (e3 += n3) < 0 ? n3 * s3 : e3 * s3;
        }, Mt = { x: 1, y: 0, axis: "x", distance: function(e3, t3, n3, s3) {
          return (n3 ? e3.xo : e3.x) - (s3 ? t3.xo : t3.x);
        }, interpolate: function(e3, t3, n3, s3) {
          let o3, r3, a3, i3, l2, u2, c2;
          if (!s3 || s3 === this)
            return o3 = e3.xo - t3.xo, r3 = e3.xo - n3.xo, l2 = t3.x - t3.xo, u2 = n3.x - n3.xo, a3 = Math.abs(o3), i3 = Math.abs(r3), c2 = a3 + i3, 0 === c2 ? void (e3.x = e3.xo + (l2 + u2) / 2) : void (e3.x = e3.xo + (l2 * i3 + u2 * a3) / c2);
          o3 = s3.distance(e3, t3, true, true), r3 = s3.distance(e3, n3, true, true), l2 = s3.distance(t3, t3, false, true), u2 = s3.distance(n3, n3, false, true), a3 = Math.abs(o3), i3 = Math.abs(r3), c2 = a3 + i3, 0 !== c2 ? Mt.setRelative(e3, e3, (l2 * i3 + u2 * a3) / c2, s3, true) : Mt.setRelative(e3, e3, (l2 + u2) / 2, s3, true);
        }, normalSlope: Number.NEGATIVE_INFINITY, setRelative: function(e3, t3, n3, s3, o3) {
          if (!s3 || s3 === this)
            return void (e3.x = (o3 ? t3.xo : t3.x) + n3);
          const r3 = o3 ? t3.xo : t3.x, a3 = o3 ? t3.yo : t3.y, i3 = r3 + n3 * s3.x, l2 = a3 + n3 * s3.y;
          e3.x = i3 + (e3.y - l2) / s3.normalSlope;
        }, slope: 0, touch: function(e3) {
          e3.xTouched = true;
        }, touched: function(e3) {
          return e3.xTouched;
        }, untouch: function(e3) {
          e3.xTouched = false;
        } }, At = { x: 0, y: 1, axis: "y", distance: function(e3, t3, n3, s3) {
          return (n3 ? e3.yo : e3.y) - (s3 ? t3.yo : t3.y);
        }, interpolate: function(e3, t3, n3, s3) {
          let o3, r3, a3, i3, l2, u2, c2;
          if (!s3 || s3 === this)
            return o3 = e3.yo - t3.yo, r3 = e3.yo - n3.yo, l2 = t3.y - t3.yo, u2 = n3.y - n3.yo, a3 = Math.abs(o3), i3 = Math.abs(r3), c2 = a3 + i3, 0 === c2 ? void (e3.y = e3.yo + (l2 + u2) / 2) : void (e3.y = e3.yo + (l2 * i3 + u2 * a3) / c2);
          o3 = s3.distance(e3, t3, true, true), r3 = s3.distance(e3, n3, true, true), l2 = s3.distance(t3, t3, false, true), u2 = s3.distance(n3, n3, false, true), a3 = Math.abs(o3), i3 = Math.abs(r3), c2 = a3 + i3, 0 !== c2 ? At.setRelative(e3, e3, (l2 * i3 + u2 * a3) / c2, s3, true) : At.setRelative(e3, e3, (l2 + u2) / 2, s3, true);
        }, normalSlope: 0, setRelative: function(e3, t3, n3, s3, o3) {
          if (!s3 || s3 === this)
            return void (e3.y = (o3 ? t3.yo : t3.y) + n3);
          const r3 = o3 ? t3.xo : t3.x, a3 = o3 ? t3.yo : t3.y, i3 = r3 + n3 * s3.x, l2 = a3 + n3 * s3.y;
          e3.y = l2 + s3.normalSlope * (e3.x - i3);
        }, slope: Number.POSITIVE_INFINITY, touch: function(e3) {
          e3.yTouched = true;
        }, touched: function(e3) {
          return e3.yTouched;
        }, untouch: function(e3) {
          e3.yTouched = false;
        } };
        function Pt(e3, t3) {
          this.x = e3, this.y = t3, this.axis = void 0, this.slope = t3 / e3, this.normalSlope = -e3 / t3, Object.freeze(this);
        }
        function Gt(e3, t3) {
          const n3 = Math.sqrt(e3 * e3 + t3 * t3);
          return t3 /= n3, 1 == (e3 /= n3) && 0 === t3 ? Mt : 0 === e3 && 1 === t3 ? At : new Pt(e3, t3);
        }
        function Nt(e3, t3, n3, s3) {
          this.x = this.xo = Math.round(64 * e3) / 64, this.y = this.yo = Math.round(64 * t3) / 64, this.lastPointOfContour = n3, this.onCurve = s3, this.prevPointOnContour = void 0, this.nextPointOnContour = void 0, this.xTouched = false, this.yTouched = false, Object.preventExtensions(this);
        }
        Object.freeze(Mt), Object.freeze(At), Pt.prototype.distance = function(e3, t3, n3, s3) {
          return this.x * Mt.distance(e3, t3, n3, s3) + this.y * At.distance(e3, t3, n3, s3);
        }, Pt.prototype.interpolate = function(e3, t3, n3, s3) {
          let o3, r3, a3, i3, l2, u2, c2;
          a3 = s3.distance(e3, t3, true, true), i3 = s3.distance(e3, n3, true, true), o3 = s3.distance(t3, t3, false, true), r3 = s3.distance(n3, n3, false, true), l2 = Math.abs(a3), u2 = Math.abs(i3), c2 = l2 + u2, 0 !== c2 ? this.setRelative(e3, e3, (o3 * u2 + r3 * l2) / c2, s3, true) : this.setRelative(e3, e3, (o3 + r3) / 2, s3, true);
        }, Pt.prototype.setRelative = function(e3, t3, n3, s3, o3) {
          s3 = s3 || this;
          const r3 = o3 ? t3.xo : t3.x, a3 = o3 ? t3.yo : t3.y, i3 = r3 + n3 * s3.x, l2 = a3 + n3 * s3.y, u2 = s3.normalSlope, c2 = this.slope, p2 = e3.x, f2 = e3.y;
          e3.x = (c2 * p2 - u2 * i3 + l2 - f2) / (c2 - u2), e3.y = c2 * (e3.x - p2) + f2;
        }, Pt.prototype.touch = function(e3) {
          e3.xTouched = true, e3.yTouched = true;
        }, Nt.prototype.nextTouched = function(e3) {
          let t3 = this.nextPointOnContour;
          for (; !e3.touched(t3) && t3 !== this; )
            t3 = t3.nextPointOnContour;
          return t3;
        }, Nt.prototype.prevTouched = function(e3) {
          let t3 = this.prevPointOnContour;
          for (; !e3.touched(t3) && t3 !== this; )
            t3 = t3.prevPointOnContour;
          return t3;
        };
        const Ft = Object.freeze(new Nt(0, 0)), _t = { cvCutIn: 17 / 16, deltaBase: 9, deltaShift: 0.125, loop: 1, minDis: 1, autoFlip: true };
        function Ht(e3, t3) {
          switch (this.env = e3, this.stack = [], this.prog = t3, e3) {
            case "glyf":
              this.zp0 = this.zp1 = this.zp2 = 1, this.rp0 = this.rp1 = this.rp2 = 0;
            case "prep":
              this.fv = this.pv = this.dpv = Mt, this.round = It;
          }
        }
        function zt(e3) {
          const t3 = e3.tZone = new Array(e3.gZone.length);
          for (let e4 = 0; e4 < t3.length; e4++)
            t3[e4] = new Nt(0, 0);
        }
        function Wt(e3, t3) {
          const n3 = e3.prog;
          let s3, o3 = e3.ip, r3 = 1;
          do {
            if (s3 = n3[++o3], 88 === s3)
              r3++;
            else if (89 === s3)
              r3--;
            else if (64 === s3)
              o3 += n3[o3 + 1] + 1;
            else if (65 === s3)
              o3 += 2 * n3[o3 + 1] + 1;
            else if (s3 >= 176 && s3 <= 183)
              o3 += s3 - 176 + 1;
            else if (s3 >= 184 && s3 <= 191)
              o3 += 2 * (s3 - 184 + 1);
            else if (t3 && 1 === r3 && 27 === s3)
              break;
          } while (r3 > 0);
          e3.ip = o3;
        }
        function qt(e3, t3) {
          exports.DEBUG && console.log(t3.step, "SVTCA[" + e3.axis + "]"), t3.fv = t3.pv = t3.dpv = e3;
        }
        function jt(e3, t3) {
          exports.DEBUG && console.log(t3.step, "SPVTCA[" + e3.axis + "]"), t3.pv = t3.dpv = e3;
        }
        function Xt(e3, t3) {
          exports.DEBUG && console.log(t3.step, "SFVTCA[" + e3.axis + "]"), t3.fv = e3;
        }
        function Vt(e3, t3) {
          const n3 = t3.stack, s3 = n3.pop(), o3 = n3.pop(), r3 = t3.z2[s3], a3 = t3.z1[o3];
          let i3, l2;
          exports.DEBUG && console.log("SPVTL[" + e3 + "]", s3, o3), e3 ? (i3 = r3.y - a3.y, l2 = a3.x - r3.x) : (i3 = a3.x - r3.x, l2 = a3.y - r3.y), t3.pv = t3.dpv = Gt(i3, l2);
        }
        function Yt(e3, t3) {
          const n3 = t3.stack, s3 = n3.pop(), o3 = n3.pop(), r3 = t3.z2[s3], a3 = t3.z1[o3];
          let i3, l2;
          exports.DEBUG && console.log("SFVTL[" + e3 + "]", s3, o3), e3 ? (i3 = r3.y - a3.y, l2 = a3.x - r3.x) : (i3 = a3.x - r3.x, l2 = a3.y - r3.y), t3.fv = Gt(i3, l2);
        }
        function Zt(e3) {
          exports.DEBUG && console.log(e3.step, "POP[]"), e3.stack.pop();
        }
        function Qt(e3, t3) {
          const n3 = t3.stack.pop(), s3 = t3.z0[n3], o3 = t3.fv, r3 = t3.pv;
          exports.DEBUG && console.log(t3.step, "MDAP[" + e3 + "]", n3);
          let a3 = r3.distance(s3, Ft);
          e3 && (a3 = t3.round(a3)), o3.setRelative(s3, Ft, a3, r3), o3.touch(s3), t3.rp0 = t3.rp1 = n3;
        }
        function Jt(e3, t3) {
          const n3 = t3.z2, s3 = n3.length - 2;
          let o3, r3, a3;
          exports.DEBUG && console.log(t3.step, "IUP[" + e3.axis + "]");
          for (let t4 = 0; t4 < s3; t4++)
            o3 = n3[t4], e3.touched(o3) || (r3 = o3.prevTouched(e3), r3 !== o3 && (a3 = o3.nextTouched(e3), r3 === a3 && e3.setRelative(o3, o3, e3.distance(r3, r3, false, true), e3, true), e3.interpolate(o3, r3, a3, e3)));
        }
        function Kt(e3, t3) {
          const n3 = t3.stack, s3 = e3 ? t3.rp1 : t3.rp2, o3 = (e3 ? t3.z0 : t3.z1)[s3], r3 = t3.fv, a3 = t3.pv;
          let i3 = t3.loop;
          const l2 = t3.z2;
          for (; i3--; ) {
            const s4 = n3.pop(), u2 = l2[s4], c2 = a3.distance(o3, o3, false, true);
            r3.setRelative(u2, u2, c2, a3), r3.touch(u2), exports.DEBUG && console.log(t3.step, (t3.loop > 1 ? "loop " + (t3.loop - i3) + ": " : "") + "SHP[" + (e3 ? "rp1" : "rp2") + "]", s4);
          }
          t3.loop = 1;
        }
        function $t(e3, t3) {
          const n3 = t3.stack, s3 = e3 ? t3.rp1 : t3.rp2, o3 = (e3 ? t3.z0 : t3.z1)[s3], r3 = t3.fv, a3 = t3.pv, i3 = n3.pop(), l2 = t3.z2[t3.contours[i3]];
          let u2 = l2;
          exports.DEBUG && console.log(t3.step, "SHC[" + e3 + "]", i3);
          const c2 = a3.distance(o3, o3, false, true);
          do {
            u2 !== o3 && r3.setRelative(u2, u2, c2, a3), u2 = u2.nextPointOnContour;
          } while (u2 !== l2);
        }
        function en(e3, t3) {
          const n3 = t3.stack, s3 = e3 ? t3.rp1 : t3.rp2, o3 = (e3 ? t3.z0 : t3.z1)[s3], r3 = t3.fv, a3 = t3.pv, i3 = n3.pop();
          let l2, u2;
          switch (exports.DEBUG && console.log(t3.step, "SHZ[" + e3 + "]", i3), i3) {
            case 0:
              l2 = t3.tZone;
              break;
            case 1:
              l2 = t3.gZone;
              break;
            default:
              throw new Error("Invalid zone");
          }
          const c2 = a3.distance(o3, o3, false, true), p2 = l2.length - 2;
          for (let e4 = 0; e4 < p2; e4++)
            u2 = l2[e4], r3.setRelative(u2, u2, c2, a3);
        }
        function tn(e3, t3) {
          const n3 = t3.stack, s3 = n3.pop() / 64, o3 = n3.pop(), r3 = t3.z1[o3], a3 = t3.z0[t3.rp0], i3 = t3.fv, l2 = t3.pv;
          i3.setRelative(r3, a3, s3, l2), i3.touch(r3), exports.DEBUG && console.log(t3.step, "MSIRP[" + e3 + "]", s3, o3), t3.rp1 = t3.rp0, t3.rp2 = o3, e3 && (t3.rp0 = o3);
        }
        function nn(e3, t3) {
          const n3 = t3.stack, s3 = n3.pop(), o3 = n3.pop(), r3 = t3.z0[o3], a3 = t3.fv, i3 = t3.pv;
          let l2 = t3.cvt[s3];
          exports.DEBUG && console.log(t3.step, "MIAP[" + e3 + "]", s3, "(", l2, ")", o3);
          let u2 = i3.distance(r3, Ft);
          e3 && (Math.abs(u2 - l2) < t3.cvCutIn && (u2 = l2), u2 = t3.round(u2)), a3.setRelative(r3, Ft, u2, i3), 0 === t3.zp0 && (r3.xo = r3.x, r3.yo = r3.y), a3.touch(r3), t3.rp0 = t3.rp1 = o3;
        }
        function sn(e3, t3) {
          const n3 = t3.stack, s3 = n3.pop(), o3 = t3.z2[s3];
          exports.DEBUG && console.log(t3.step, "GC[" + e3 + "]", s3), n3.push(64 * t3.dpv.distance(o3, Ft, e3, false));
        }
        function on(e3, t3) {
          const n3 = t3.stack, s3 = n3.pop(), o3 = n3.pop(), r3 = t3.z1[s3], a3 = t3.z0[o3], i3 = t3.dpv.distance(a3, r3, e3, e3);
          exports.DEBUG && console.log(t3.step, "MD[" + e3 + "]", s3, o3, "->", i3), t3.stack.push(Math.round(64 * i3));
        }
        function rn(e3, t3) {
          const n3 = t3.stack, s3 = n3.pop(), o3 = t3.fv, r3 = t3.pv, a3 = t3.ppem, i3 = t3.deltaBase + 16 * (e3 - 1), l2 = t3.deltaShift, u2 = t3.z0;
          exports.DEBUG && console.log(t3.step, "DELTAP[" + e3 + "]", s3, n3);
          for (let e4 = 0; e4 < s3; e4++) {
            const e5 = n3.pop(), s4 = n3.pop();
            if (i3 + ((240 & s4) >> 4) !== a3)
              continue;
            let c2 = (15 & s4) - 8;
            c2 >= 0 && c2++, exports.DEBUG && console.log(t3.step, "DELTAPFIX", e5, "by", c2 * l2);
            const p2 = u2[e5];
            o3.setRelative(p2, p2, c2 * l2, r3);
          }
        }
        function an(e3, t3) {
          const n3 = t3.stack, s3 = n3.pop();
          exports.DEBUG && console.log(t3.step, "ROUND[]"), n3.push(64 * t3.round(s3 / 64));
        }
        function ln(e3, t3) {
          const n3 = t3.stack, s3 = n3.pop(), o3 = t3.ppem, r3 = t3.deltaBase + 16 * (e3 - 1), a3 = t3.deltaShift;
          exports.DEBUG && console.log(t3.step, "DELTAC[" + e3 + "]", s3, n3);
          for (let e4 = 0; e4 < s3; e4++) {
            const e5 = n3.pop(), s4 = n3.pop();
            if (r3 + ((240 & s4) >> 4) !== o3)
              continue;
            let i3 = (15 & s4) - 8;
            i3 >= 0 && i3++;
            const l2 = i3 * a3;
            exports.DEBUG && console.log(t3.step, "DELTACFIX", e5, "by", l2), t3.cvt[e5] += l2;
          }
        }
        function un(e3, t3) {
          const n3 = t3.stack, s3 = n3.pop(), o3 = n3.pop(), r3 = t3.z2[s3], a3 = t3.z1[o3];
          let i3, l2;
          exports.DEBUG && console.log(t3.step, "SDPVTL[" + e3 + "]", s3, o3), e3 ? (i3 = r3.y - a3.y, l2 = a3.x - r3.x) : (i3 = a3.x - r3.x, l2 = a3.y - r3.y), t3.dpv = Gt(i3, l2);
        }
        function cn(e3, t3) {
          const n3 = t3.stack, s3 = t3.prog;
          let o3 = t3.ip;
          exports.DEBUG && console.log(t3.step, "PUSHB[" + e3 + "]");
          for (let t4 = 0; t4 < e3; t4++)
            n3.push(s3[++o3]);
          t3.ip = o3;
        }
        function pn(e3, t3) {
          let n3 = t3.ip;
          const s3 = t3.prog, o3 = t3.stack;
          exports.DEBUG && console.log(t3.ip, "PUSHW[" + e3 + "]");
          for (let t4 = 0; t4 < e3; t4++) {
            let e4 = s3[++n3] << 8 | s3[++n3];
            32768 & e4 && (e4 = -(1 + (65535 ^ e4))), o3.push(e4);
          }
          t3.ip = n3;
        }
        function fn(e3, t3, n3, s3, o3, r3) {
          const a3 = r3.stack, i3 = e3 && a3.pop(), l2 = a3.pop(), u2 = r3.rp0, c2 = r3.z0[u2], p2 = r3.z1[l2], f2 = r3.minDis, h2 = r3.fv, d2 = r3.dpv;
          let g2, m2, y2, v2;
          m2 = g2 = d2.distance(p2, c2, true, true), y2 = m2 >= 0 ? 1 : -1, m2 = Math.abs(m2), e3 && (v2 = r3.cvt[i3], s3 && Math.abs(m2 - v2) < r3.cvCutIn && (m2 = v2)), n3 && m2 < f2 && (m2 = f2), s3 && (m2 = r3.round(m2)), h2.setRelative(p2, c2, y2 * m2, d2), h2.touch(p2), exports.DEBUG && console.log(r3.step, (e3 ? "MIRP[" : "MDRP[") + (t3 ? "M" : "m") + (n3 ? ">" : "_") + (s3 ? "R" : "_") + (0 === o3 ? "Gr" : 1 === o3 ? "Bl" : 2 === o3 ? "Wh" : "") + "]", e3 ? i3 + "(" + r3.cvt[i3] + "," + v2 + ")" : "", l2, "(d =", g2, "->", y2 * m2, ")"), r3.rp1 = r3.rp0, r3.rp2 = l2, t3 && (r3.rp0 = l2);
        }
        wt.prototype.exec = function(e3, t3) {
          if ("number" != typeof t3)
            throw new Error("Point size is not a number!");
          if (this._errorState > 2)
            return;
          const n3 = this.font;
          let s3 = this._prepState;
          if (!s3 || s3.ppem !== t3) {
            let e4 = this._fpgmState;
            if (!e4) {
              Ht.prototype = _t, e4 = this._fpgmState = new Ht("fpgm", n3.tables.fpgm), e4.funcs = [], e4.font = n3, exports.DEBUG && (console.log("---EXEC FPGM---"), e4.step = -1);
              try {
                kt(e4);
              } catch (e5) {
                return console.log("Hinting error in FPGM:" + e5), void (this._errorState = 3);
              }
            }
            Ht.prototype = e4, s3 = this._prepState = new Ht("prep", n3.tables.prep), s3.ppem = t3;
            const o3 = n3.tables.cvt;
            if (o3) {
              const e5 = s3.cvt = new Array(o3.length), r3 = t3 / n3.unitsPerEm;
              for (let t4 = 0; t4 < o3.length; t4++)
                e5[t4] = o3[t4] * r3;
            } else
              s3.cvt = [];
            exports.DEBUG && (console.log("---EXEC PREP---"), s3.step = -1);
            try {
              kt(s3);
            } catch (e5) {
              this._errorState < 2 && console.log("Hinting error in PREP:" + e5), this._errorState = 2;
            }
          }
          if (!(this._errorState > 1))
            try {
              return Tt(e3, s3);
            } catch (e4) {
              return this._errorState < 1 && (console.log("Hinting error:" + e4), console.log("Note: further hinting errors are silenced")), void (this._errorState = 1);
            }
        }, Tt = function(e3, t3) {
          const n3 = t3.ppem / t3.font.unitsPerEm, s3 = n3;
          let o3, r3, a3, i3 = e3.components;
          if (Ht.prototype = t3, i3) {
            const l2 = t3.font;
            r3 = [], o3 = [];
            for (let e4 = 0; e4 < i3.length; e4++) {
              const t4 = i3[e4], u2 = l2.glyphs.get(t4.glyphIndex);
              a3 = new Ht("glyf", u2.instructions), exports.DEBUG && (console.log("---EXEC COMP " + e4 + "---"), a3.step = -1), Et(u2, a3, n3, s3);
              const c2 = Math.round(t4.dx * n3), p2 = Math.round(t4.dy * s3), f2 = a3.gZone, h2 = a3.contours;
              for (let e5 = 0; e5 < f2.length; e5++) {
                const t5 = f2[e5];
                t5.xTouched = t5.yTouched = false, t5.xo = t5.x = t5.x + c2, t5.yo = t5.y = t5.y + p2;
              }
              const d2 = r3.length;
              r3.push.apply(r3, f2);
              for (let e5 = 0; e5 < h2.length; e5++)
                o3.push(h2[e5] + d2);
            }
            e3.instructions && !a3.inhibitGridFit && (a3 = new Ht("glyf", e3.instructions), a3.gZone = a3.z0 = a3.z1 = a3.z2 = r3, a3.contours = o3, r3.push(new Nt(0, 0), new Nt(Math.round(e3.advanceWidth * n3), 0)), exports.DEBUG && (console.log("---EXEC COMPOSITE---"), a3.step = -1), kt(a3), r3.length -= 2);
          } else
            a3 = new Ht("glyf", e3.instructions), exports.DEBUG && (console.log("---EXEC GLYPH---"), a3.step = -1), Et(e3, a3, n3, s3), r3 = a3.gZone;
          return r3;
        }, Et = function(e3, t3, n3, s3) {
          const o3 = e3.points || [], r3 = o3.length, a3 = t3.gZone = t3.z0 = t3.z1 = t3.z2 = [], i3 = t3.contours = [];
          let l2, u2, c2;
          for (let e4 = 0; e4 < r3; e4++)
            l2 = o3[e4], a3[e4] = new Nt(l2.x * n3, l2.y * s3, l2.lastPointOfContour, l2.onCurve);
          for (let e4 = 0; e4 < r3; e4++)
            l2 = a3[e4], u2 || (u2 = l2, i3.push(e4)), l2.lastPointOfContour ? (l2.nextPointOnContour = u2, u2.prevPointOnContour = l2, u2 = void 0) : (c2 = a3[e4 + 1], l2.nextPointOnContour = c2, c2.prevPointOnContour = l2);
          if (!t3.inhibitGridFit) {
            if (exports.DEBUG) {
              console.log("PROCESSING GLYPH", t3.stack);
              for (let e4 = 0; e4 < r3; e4++)
                console.log(e4, a3[e4].x, a3[e4].y);
            }
            if (a3.push(new Nt(0, 0), new Nt(Math.round(e3.advanceWidth * n3), 0)), kt(t3), a3.length -= 2, exports.DEBUG) {
              console.log("FINISHED GLYPH", t3.stack);
              for (let e4 = 0; e4 < r3; e4++)
                console.log(e4, a3[e4].x, a3[e4].y);
            }
          }
        }, kt = function(e3) {
          let t3 = e3.prog;
          if (!t3)
            return;
          const n3 = t3.length;
          let s3;
          for (e3.ip = 0; e3.ip < n3; e3.ip++) {
            if (exports.DEBUG && e3.step++, s3 = Ut[t3[e3.ip]], !s3)
              throw new Error("unknown instruction: 0x" + Number(t3[e3.ip]).toString(16));
            s3(e3);
          }
        }, Ut = [qt.bind(void 0, At), qt.bind(void 0, Mt), jt.bind(void 0, At), jt.bind(void 0, Mt), Xt.bind(void 0, At), Xt.bind(void 0, Mt), Vt.bind(void 0, 0), Vt.bind(void 0, 1), Yt.bind(void 0, 0), Yt.bind(void 0, 1), function(e3) {
          const t3 = e3.stack, n3 = t3.pop(), s3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "SPVFS[]", n3, s3), e3.pv = e3.dpv = Gt(s3, n3);
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop(), s3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "SPVFS[]", n3, s3), e3.fv = Gt(s3, n3);
        }, function(e3) {
          const t3 = e3.stack, n3 = e3.pv;
          exports.DEBUG && console.log(e3.step, "GPV[]"), t3.push(16384 * n3.x), t3.push(16384 * n3.y);
        }, function(e3) {
          const t3 = e3.stack, n3 = e3.fv;
          exports.DEBUG && console.log(e3.step, "GFV[]"), t3.push(16384 * n3.x), t3.push(16384 * n3.y);
        }, function(e3) {
          e3.fv = e3.pv, exports.DEBUG && console.log(e3.step, "SFVTPV[]");
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop(), s3 = t3.pop(), o3 = t3.pop(), r3 = t3.pop(), a3 = t3.pop(), i3 = e3.z0, l2 = e3.z1, u2 = i3[n3], c2 = i3[s3], p2 = l2[o3], f2 = l2[r3], h2 = e3.z2[a3];
          exports.DEBUG && console.log("ISECT[], ", n3, s3, o3, r3, a3);
          const d2 = u2.x, g2 = u2.y, m2 = c2.x, y2 = c2.y, v2 = p2.x, b2 = p2.y, x2 = f2.x, S2 = f2.y, U2 = (d2 - m2) * (b2 - S2) - (g2 - y2) * (v2 - x2), k2 = d2 * y2 - g2 * m2, T2 = v2 * S2 - b2 * x2;
          h2.x = (k2 * (v2 - x2) - T2 * (d2 - m2)) / U2, h2.y = (k2 * (b2 - S2) - T2 * (g2 - y2)) / U2;
        }, function(e3) {
          e3.rp0 = e3.stack.pop(), exports.DEBUG && console.log(e3.step, "SRP0[]", e3.rp0);
        }, function(e3) {
          e3.rp1 = e3.stack.pop(), exports.DEBUG && console.log(e3.step, "SRP1[]", e3.rp1);
        }, function(e3) {
          e3.rp2 = e3.stack.pop(), exports.DEBUG && console.log(e3.step, "SRP2[]", e3.rp2);
        }, function(e3) {
          const t3 = e3.stack.pop();
          switch (exports.DEBUG && console.log(e3.step, "SZP0[]", t3), e3.zp0 = t3, t3) {
            case 0:
              e3.tZone || zt(e3), e3.z0 = e3.tZone;
              break;
            case 1:
              e3.z0 = e3.gZone;
              break;
            default:
              throw new Error("Invalid zone pointer");
          }
        }, function(e3) {
          const t3 = e3.stack.pop();
          switch (exports.DEBUG && console.log(e3.step, "SZP1[]", t3), e3.zp1 = t3, t3) {
            case 0:
              e3.tZone || zt(e3), e3.z1 = e3.tZone;
              break;
            case 1:
              e3.z1 = e3.gZone;
              break;
            default:
              throw new Error("Invalid zone pointer");
          }
        }, function(e3) {
          const t3 = e3.stack.pop();
          switch (exports.DEBUG && console.log(e3.step, "SZP2[]", t3), e3.zp2 = t3, t3) {
            case 0:
              e3.tZone || zt(e3), e3.z2 = e3.tZone;
              break;
            case 1:
              e3.z2 = e3.gZone;
              break;
            default:
              throw new Error("Invalid zone pointer");
          }
        }, function(e3) {
          const t3 = e3.stack.pop();
          switch (exports.DEBUG && console.log(e3.step, "SZPS[]", t3), e3.zp0 = e3.zp1 = e3.zp2 = t3, t3) {
            case 0:
              e3.tZone || zt(e3), e3.z0 = e3.z1 = e3.z2 = e3.tZone;
              break;
            case 1:
              e3.z0 = e3.z1 = e3.z2 = e3.gZone;
              break;
            default:
              throw new Error("Invalid zone pointer");
          }
        }, function(e3) {
          e3.loop = e3.stack.pop(), exports.DEBUG && console.log(e3.step, "SLOOP[]", e3.loop);
        }, function(e3) {
          exports.DEBUG && console.log(e3.step, "RTG[]"), e3.round = It;
        }, function(e3) {
          exports.DEBUG && console.log(e3.step, "RTHG[]"), e3.round = Lt;
        }, function(e3) {
          const t3 = e3.stack.pop();
          exports.DEBUG && console.log(e3.step, "SMD[]", t3), e3.minDis = t3 / 64;
        }, function(e3) {
          exports.DEBUG && console.log(e3.step, "ELSE[]"), Wt(e3, false);
        }, function(e3) {
          const t3 = e3.stack.pop();
          exports.DEBUG && console.log(e3.step, "JMPR[]", t3), e3.ip += t3 - 1;
        }, function(e3) {
          const t3 = e3.stack.pop();
          exports.DEBUG && console.log(e3.step, "SCVTCI[]", t3), e3.cvCutIn = t3 / 64;
        }, void 0, void 0, function(e3) {
          const t3 = e3.stack;
          exports.DEBUG && console.log(e3.step, "DUP[]"), t3.push(t3[t3.length - 1]);
        }, Zt, function(e3) {
          exports.DEBUG && console.log(e3.step, "CLEAR[]"), e3.stack.length = 0;
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop(), s3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "SWAP[]"), t3.push(n3), t3.push(s3);
        }, function(e3) {
          const t3 = e3.stack;
          exports.DEBUG && console.log(e3.step, "DEPTH[]"), t3.push(t3.length);
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "CINDEX[]", n3), t3.push(t3[t3.length - n3]);
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "MINDEX[]", n3), t3.push(t3.splice(t3.length - n3, 1)[0]);
        }, void 0, void 0, void 0, function(e3) {
          const t3 = e3.stack, n3 = t3.pop(), s3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "LOOPCALL[]", n3, s3);
          const o3 = e3.ip, r3 = e3.prog;
          e3.prog = e3.funcs[n3];
          for (let t4 = 0; t4 < s3; t4++)
            kt(e3), exports.DEBUG && console.log(++e3.step, t4 + 1 < s3 ? "next loopcall" : "done loopcall", t4);
          e3.ip = o3, e3.prog = r3;
        }, function(e3) {
          const t3 = e3.stack.pop();
          exports.DEBUG && console.log(e3.step, "CALL[]", t3);
          const n3 = e3.ip, s3 = e3.prog;
          e3.prog = e3.funcs[t3], kt(e3), e3.ip = n3, e3.prog = s3, exports.DEBUG && console.log(++e3.step, "returning from", t3);
        }, function(e3) {
          if ("fpgm" !== e3.env)
            throw new Error("FDEF not allowed here");
          const t3 = e3.stack, n3 = e3.prog;
          let s3 = e3.ip;
          const o3 = t3.pop(), r3 = s3;
          for (exports.DEBUG && console.log(e3.step, "FDEF[]", o3); 45 !== n3[++s3]; )
            ;
          e3.ip = s3, e3.funcs[o3] = n3.slice(r3 + 1, s3);
        }, void 0, Qt.bind(void 0, 0), Qt.bind(void 0, 1), Jt.bind(void 0, At), Jt.bind(void 0, Mt), Kt.bind(void 0, 0), Kt.bind(void 0, 1), $t.bind(void 0, 0), $t.bind(void 0, 1), en.bind(void 0, 0), en.bind(void 0, 1), function(e3) {
          const t3 = e3.stack;
          let n3 = e3.loop;
          const s3 = e3.fv, o3 = t3.pop() / 64, r3 = e3.z2;
          for (; n3--; ) {
            const a3 = t3.pop(), i3 = r3[a3];
            exports.DEBUG && console.log(e3.step, (e3.loop > 1 ? "loop " + (e3.loop - n3) + ": " : "") + "SHPIX[]", a3, o3), s3.setRelative(i3, i3, o3), s3.touch(i3);
          }
          e3.loop = 1;
        }, function(e3) {
          const t3 = e3.stack, n3 = e3.rp1, s3 = e3.rp2;
          let o3 = e3.loop;
          const r3 = e3.z0[n3], a3 = e3.z1[s3], i3 = e3.fv, l2 = e3.dpv, u2 = e3.z2;
          for (; o3--; ) {
            const c2 = t3.pop(), p2 = u2[c2];
            exports.DEBUG && console.log(e3.step, (e3.loop > 1 ? "loop " + (e3.loop - o3) + ": " : "") + "IP[]", c2, n3, "<->", s3), i3.interpolate(p2, r3, a3, l2), i3.touch(p2);
          }
          e3.loop = 1;
        }, tn.bind(void 0, 0), tn.bind(void 0, 1), function(e3) {
          const t3 = e3.stack, n3 = e3.rp0, s3 = e3.z0[n3];
          let o3 = e3.loop;
          const r3 = e3.fv, a3 = e3.pv, i3 = e3.z1;
          for (; o3--; ) {
            const n4 = t3.pop(), l2 = i3[n4];
            exports.DEBUG && console.log(e3.step, (e3.loop > 1 ? "loop " + (e3.loop - o3) + ": " : "") + "ALIGNRP[]", n4), r3.setRelative(l2, s3, 0, a3), r3.touch(l2);
          }
          e3.loop = 1;
        }, function(e3) {
          exports.DEBUG && console.log(e3.step, "RTDG[]"), e3.round = Rt;
        }, nn.bind(void 0, 0), nn.bind(void 0, 1), function(e3) {
          const t3 = e3.prog;
          let n3 = e3.ip;
          const s3 = e3.stack, o3 = t3[++n3];
          exports.DEBUG && console.log(e3.step, "NPUSHB[]", o3);
          for (let e4 = 0; e4 < o3; e4++)
            s3.push(t3[++n3]);
          e3.ip = n3;
        }, function(e3) {
          let t3 = e3.ip;
          const n3 = e3.prog, s3 = e3.stack, o3 = n3[++t3];
          exports.DEBUG && console.log(e3.step, "NPUSHW[]", o3);
          for (let e4 = 0; e4 < o3; e4++) {
            let e5 = n3[++t3] << 8 | n3[++t3];
            32768 & e5 && (e5 = -(1 + (65535 ^ e5))), s3.push(e5);
          }
          e3.ip = t3;
        }, function(e3) {
          const t3 = e3.stack;
          let n3 = e3.store;
          n3 || (n3 = e3.store = []);
          const s3 = t3.pop(), o3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "WS", s3, o3), n3[o3] = s3;
        }, function(e3) {
          const t3 = e3.stack, n3 = e3.store, s3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "RS", s3);
          const o3 = n3 && n3[s3] || 0;
          t3.push(o3);
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop(), s3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "WCVTP", n3, s3), e3.cvt[s3] = n3 / 64;
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "RCVT", n3), t3.push(64 * e3.cvt[n3]);
        }, sn.bind(void 0, 0), sn.bind(void 0, 1), void 0, on.bind(void 0, 0), on.bind(void 0, 1), function(e3) {
          exports.DEBUG && console.log(e3.step, "MPPEM[]"), e3.stack.push(e3.ppem);
        }, void 0, function(e3) {
          exports.DEBUG && console.log(e3.step, "FLIPON[]"), e3.autoFlip = true;
        }, void 0, void 0, function(e3) {
          const t3 = e3.stack, n3 = t3.pop(), s3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "LT[]", n3, s3), t3.push(s3 < n3 ? 1 : 0);
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop(), s3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "LTEQ[]", n3, s3), t3.push(s3 <= n3 ? 1 : 0);
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop(), s3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "GT[]", n3, s3), t3.push(s3 > n3 ? 1 : 0);
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop(), s3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "GTEQ[]", n3, s3), t3.push(s3 >= n3 ? 1 : 0);
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop(), s3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "EQ[]", n3, s3), t3.push(n3 === s3 ? 1 : 0);
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop(), s3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "NEQ[]", n3, s3), t3.push(n3 !== s3 ? 1 : 0);
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "ODD[]", n3), t3.push(Math.trunc(n3) % 2 ? 1 : 0);
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "EVEN[]", n3), t3.push(Math.trunc(n3) % 2 ? 0 : 1);
        }, function(e3) {
          let t3 = e3.stack.pop();
          exports.DEBUG && console.log(e3.step, "IF[]", t3), t3 || (Wt(e3, true), exports.DEBUG && console.log(e3.step, "EIF[]"));
        }, function(e3) {
          exports.DEBUG && console.log(e3.step, "EIF[]");
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop(), s3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "AND[]", n3, s3), t3.push(n3 && s3 ? 1 : 0);
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop(), s3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "OR[]", n3, s3), t3.push(n3 || s3 ? 1 : 0);
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "NOT[]", n3), t3.push(n3 ? 0 : 1);
        }, rn.bind(void 0, 1), function(e3) {
          const t3 = e3.stack.pop();
          exports.DEBUG && console.log(e3.step, "SDB[]", t3), e3.deltaBase = t3;
        }, function(e3) {
          const t3 = e3.stack.pop();
          exports.DEBUG && console.log(e3.step, "SDS[]", t3), e3.deltaShift = Math.pow(0.5, t3);
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop(), s3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "ADD[]", n3, s3), t3.push(s3 + n3);
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop(), s3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "SUB[]", n3, s3), t3.push(s3 - n3);
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop(), s3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "DIV[]", n3, s3), t3.push(64 * s3 / n3);
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop(), s3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "MUL[]", n3, s3), t3.push(s3 * n3 / 64);
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "ABS[]", n3), t3.push(Math.abs(n3));
        }, function(e3) {
          const t3 = e3.stack;
          let n3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "NEG[]", n3), t3.push(-n3);
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "FLOOR[]", n3), t3.push(64 * Math.floor(n3 / 64));
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "CEILING[]", n3), t3.push(64 * Math.ceil(n3 / 64));
        }, an.bind(void 0, 0), an.bind(void 0, 1), an.bind(void 0, 2), an.bind(void 0, 3), void 0, void 0, void 0, void 0, function(e3) {
          const t3 = e3.stack, n3 = t3.pop(), s3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "WCVTF[]", n3, s3), e3.cvt[s3] = n3 * e3.ppem / e3.font.unitsPerEm;
        }, rn.bind(void 0, 2), rn.bind(void 0, 3), ln.bind(void 0, 1), ln.bind(void 0, 2), ln.bind(void 0, 3), function(e3) {
          let t3, n3 = e3.stack.pop();
          switch (exports.DEBUG && console.log(e3.step, "SROUND[]", n3), e3.round = Dt, 192 & n3) {
            case 0:
              t3 = 0.5;
              break;
            case 64:
              t3 = 1;
              break;
            case 128:
              t3 = 2;
              break;
            default:
              throw new Error("invalid SROUND value");
          }
          switch (e3.srPeriod = t3, 48 & n3) {
            case 0:
              e3.srPhase = 0;
              break;
            case 16:
              e3.srPhase = 0.25 * t3;
              break;
            case 32:
              e3.srPhase = 0.5 * t3;
              break;
            case 48:
              e3.srPhase = 0.75 * t3;
              break;
            default:
              throw new Error("invalid SROUND value");
          }
          n3 &= 15, e3.srThreshold = 0 === n3 ? 0 : (n3 / 8 - 0.5) * t3;
        }, function(e3) {
          let t3, n3 = e3.stack.pop();
          switch (exports.DEBUG && console.log(e3.step, "S45ROUND[]", n3), e3.round = Dt, 192 & n3) {
            case 0:
              t3 = Math.sqrt(2) / 2;
              break;
            case 64:
              t3 = Math.sqrt(2);
              break;
            case 128:
              t3 = 2 * Math.sqrt(2);
              break;
            default:
              throw new Error("invalid S45ROUND value");
          }
          switch (e3.srPeriod = t3, 48 & n3) {
            case 0:
              e3.srPhase = 0;
              break;
            case 16:
              e3.srPhase = 0.25 * t3;
              break;
            case 32:
              e3.srPhase = 0.5 * t3;
              break;
            case 48:
              e3.srPhase = 0.75 * t3;
              break;
            default:
              throw new Error("invalid S45ROUND value");
          }
          n3 &= 15, e3.srThreshold = 0 === n3 ? 0 : (n3 / 8 - 0.5) * t3;
        }, void 0, void 0, function(e3) {
          exports.DEBUG && console.log(e3.step, "ROFF[]"), e3.round = Ot;
        }, void 0, function(e3) {
          exports.DEBUG && console.log(e3.step, "RUTG[]"), e3.round = Bt;
        }, function(e3) {
          exports.DEBUG && console.log(e3.step, "RDTG[]"), e3.round = Ct;
        }, Zt, Zt, void 0, void 0, void 0, void 0, void 0, function(e3) {
          const t3 = e3.stack.pop();
          exports.DEBUG && console.log(e3.step, "SCANCTRL[]", t3);
        }, un.bind(void 0, 0), un.bind(void 0, 1), function(e3) {
          const t3 = e3.stack, n3 = t3.pop();
          let s3 = 0;
          exports.DEBUG && console.log(e3.step, "GETINFO[]", n3), 1 & n3 && (s3 = 35), 32 & n3 && (s3 |= 4096), t3.push(s3);
        }, void 0, function(e3) {
          const t3 = e3.stack, n3 = t3.pop(), s3 = t3.pop(), o3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "ROLL[]"), t3.push(s3), t3.push(n3), t3.push(o3);
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop(), s3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "MAX[]", n3, s3), t3.push(Math.max(s3, n3));
        }, function(e3) {
          const t3 = e3.stack, n3 = t3.pop(), s3 = t3.pop();
          exports.DEBUG && console.log(e3.step, "MIN[]", n3, s3), t3.push(Math.min(s3, n3));
        }, function(e3) {
          const t3 = e3.stack.pop();
          exports.DEBUG && console.log(e3.step, "SCANTYPE[]", t3);
        }, function(e3) {
          const t3 = e3.stack.pop();
          let n3 = e3.stack.pop();
          switch (exports.DEBUG && console.log(e3.step, "INSTCTRL[]", t3, n3), t3) {
            case 1:
              return void (e3.inhibitGridFit = !!n3);
            case 2:
              return void (e3.ignoreCvt = !!n3);
            default:
              throw new Error("invalid INSTCTRL[] selector");
          }
        }, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, cn.bind(void 0, 1), cn.bind(void 0, 2), cn.bind(void 0, 3), cn.bind(void 0, 4), cn.bind(void 0, 5), cn.bind(void 0, 6), cn.bind(void 0, 7), cn.bind(void 0, 8), pn.bind(void 0, 1), pn.bind(void 0, 2), pn.bind(void 0, 3), pn.bind(void 0, 4), pn.bind(void 0, 5), pn.bind(void 0, 6), pn.bind(void 0, 7), pn.bind(void 0, 8), fn.bind(void 0, 0, 0, 0, 0, 0), fn.bind(void 0, 0, 0, 0, 0, 1), fn.bind(void 0, 0, 0, 0, 0, 2), fn.bind(void 0, 0, 0, 0, 0, 3), fn.bind(void 0, 0, 0, 0, 1, 0), fn.bind(void 0, 0, 0, 0, 1, 1), fn.bind(void 0, 0, 0, 0, 1, 2), fn.bind(void 0, 0, 0, 0, 1, 3), fn.bind(void 0, 0, 0, 1, 0, 0), fn.bind(void 0, 0, 0, 1, 0, 1), fn.bind(void 0, 0, 0, 1, 0, 2), fn.bind(void 0, 0, 0, 1, 0, 3), fn.bind(void 0, 0, 0, 1, 1, 0), fn.bind(void 0, 0, 0, 1, 1, 1), fn.bind(void 0, 0, 0, 1, 1, 2), fn.bind(void 0, 0, 0, 1, 1, 3), fn.bind(void 0, 0, 1, 0, 0, 0), fn.bind(void 0, 0, 1, 0, 0, 1), fn.bind(void 0, 0, 1, 0, 0, 2), fn.bind(void 0, 0, 1, 0, 0, 3), fn.bind(void 0, 0, 1, 0, 1, 0), fn.bind(void 0, 0, 1, 0, 1, 1), fn.bind(void 0, 0, 1, 0, 1, 2), fn.bind(void 0, 0, 1, 0, 1, 3), fn.bind(void 0, 0, 1, 1, 0, 0), fn.bind(void 0, 0, 1, 1, 0, 1), fn.bind(void 0, 0, 1, 1, 0, 2), fn.bind(void 0, 0, 1, 1, 0, 3), fn.bind(void 0, 0, 1, 1, 1, 0), fn.bind(void 0, 0, 1, 1, 1, 1), fn.bind(void 0, 0, 1, 1, 1, 2), fn.bind(void 0, 0, 1, 1, 1, 3), fn.bind(void 0, 1, 0, 0, 0, 0), fn.bind(void 0, 1, 0, 0, 0, 1), fn.bind(void 0, 1, 0, 0, 0, 2), fn.bind(void 0, 1, 0, 0, 0, 3), fn.bind(void 0, 1, 0, 0, 1, 0), fn.bind(void 0, 1, 0, 0, 1, 1), fn.bind(void 0, 1, 0, 0, 1, 2), fn.bind(void 0, 1, 0, 0, 1, 3), fn.bind(void 0, 1, 0, 1, 0, 0), fn.bind(void 0, 1, 0, 1, 0, 1), fn.bind(void 0, 1, 0, 1, 0, 2), fn.bind(void 0, 1, 0, 1, 0, 3), fn.bind(void 0, 1, 0, 1, 1, 0), fn.bind(void 0, 1, 0, 1, 1, 1), fn.bind(void 0, 1, 0, 1, 1, 2), fn.bind(void 0, 1, 0, 1, 1, 3), fn.bind(void 0, 1, 1, 0, 0, 0), fn.bind(void 0, 1, 1, 0, 0, 1), fn.bind(void 0, 1, 1, 0, 0, 2), fn.bind(void 0, 1, 1, 0, 0, 3), fn.bind(void 0, 1, 1, 0, 1, 0), fn.bind(void 0, 1, 1, 0, 1, 1), fn.bind(void 0, 1, 1, 0, 1, 2), fn.bind(void 0, 1, 1, 0, 1, 3), fn.bind(void 0, 1, 1, 1, 0, 0), fn.bind(void 0, 1, 1, 1, 0, 1), fn.bind(void 0, 1, 1, 1, 0, 2), fn.bind(void 0, 1, 1, 1, 0, 3), fn.bind(void 0, 1, 1, 1, 1, 0), fn.bind(void 0, 1, 1, 1, 1, 1), fn.bind(void 0, 1, 1, 1, 1, 2), fn.bind(void 0, 1, 1, 1, 1, 3)];
        const hn = wt;
        function dn(e3) {
          (e3 = e3 || {}).empty || (St(e3.familyName, "When creating a new Font object, familyName is required."), St(e3.styleName, "When creating a new Font object, styleName is required."), St(e3.unitsPerEm, "When creating a new Font object, unitsPerEm is required."), St(e3.ascender, "When creating a new Font object, ascender is required."), St(e3.descender, "When creating a new Font object, descender is required."), St(e3.descender < 0, "Descender should be negative (e.g. -512)."), this.names = { fontFamily: { en: e3.familyName || " " }, fontSubfamily: { en: e3.styleName || " " }, fullName: { en: e3.fullName || e3.familyName + " " + e3.styleName }, postScriptName: { en: e3.postScriptName || e3.familyName + e3.styleName }, designer: { en: e3.designer || " " }, designerURL: { en: e3.designerURL || " " }, manufacturer: { en: e3.manufacturer || " " }, manufacturerURL: { en: e3.manufacturerURL || " " }, license: { en: e3.license || " " }, licenseURL: { en: e3.licenseURL || " " }, version: { en: e3.version || "Version 0.1" }, description: { en: e3.description || " " }, copyright: { en: e3.copyright || " " }, trademark: { en: e3.trademark || " " } }, this.unitsPerEm = e3.unitsPerEm || 1e3, this.ascender = e3.ascender, this.descender = e3.descender, this.createdTimestamp = e3.createdTimestamp, this.tables = { os2: { usWeightClass: e3.weightClass || this.usWeightClasses.MEDIUM, usWidthClass: e3.widthClass || this.usWidthClasses.MEDIUM, fsSelection: e3.fsSelection || this.fsSelectionValues.REGULAR } }), this.supported = true, this.glyphs = new ce.GlyphSet(this, e3.glyphs || []), this.encoding = new Z(this), this.position = new gt(this), this.substitution = new bt(this), this.tables = this.tables || {}, Object.defineProperty(this, "hinting", { get: function() {
            return this._hinting ? this._hinting : "truetype" === this.outlinesFormat ? this._hinting = new hn(this) : void 0;
          } });
        }
        dn.prototype.hasChar = function(e3) {
          return null !== this.encoding.charToGlyphIndex(e3);
        }, dn.prototype.charToGlyphIndex = function(e3) {
          return this.encoding.charToGlyphIndex(e3);
        }, dn.prototype.charToGlyph = function(e3) {
          const t3 = this.charToGlyphIndex(e3);
          let n3 = this.glyphs.get(t3);
          return n3 || (n3 = this.glyphs.get(0)), n3;
        }, dn.prototype.stringToGlyphs = function(e3, t3) {
          t3 = t3 || this.defaultRenderOptions;
          const n3 = [];
          for (let t4 = 0; t4 < e3.length; t4 += 1) {
            const s4 = e3[t4];
            n3.push(this.charToGlyphIndex(s4));
          }
          let s3 = n3.length;
          if (t3.features) {
            const e4 = t3.script || this.substitution.getDefaultScriptName();
            let o4 = [];
            t3.features.liga && (o4 = o4.concat(this.substitution.getFeature("liga", e4, t3.language))), t3.features.rlig && (o4 = o4.concat(this.substitution.getFeature("rlig", e4, t3.language)));
            for (let e5 = 0; e5 < s3; e5 += 1)
              for (let t4 = 0; t4 < o4.length; t4++) {
                const r4 = o4[t4], a3 = r4.sub, i3 = a3.length;
                let l2 = 0;
                for (; l2 < i3 && a3[l2] === n3[e5 + l2]; )
                  l2++;
                l2 === i3 && (n3.splice(e5, i3, r4.by), s3 = s3 - i3 + 1);
              }
          }
          const o3 = new Array(s3), r3 = this.glyphs.get(0);
          for (let e4 = 0; e4 < s3; e4 += 1)
            o3[e4] = this.glyphs.get(n3[e4]) || r3;
          return o3;
        }, dn.prototype.nameToGlyphIndex = function(e3) {
          return this.glyphNames.nameToGlyphIndex(e3);
        }, dn.prototype.nameToGlyph = function(e3) {
          const t3 = this.nameToGlyphIndex(e3);
          let n3 = this.glyphs.get(t3);
          return n3 || (n3 = this.glyphs.get(0)), n3;
        }, dn.prototype.glyphIndexToName = function(e3) {
          return this.glyphNames.glyphIndexToName ? this.glyphNames.glyphIndexToName(e3) : "";
        }, dn.prototype.getKerningValue = function(e3, t3) {
          return e3 = e3.index || e3, t3 = t3.index || t3, this.kerningPairs[e3 + "," + t3] || 0;
        }, dn.prototype.defaultRenderOptions = { kerning: true, features: { liga: true, rlig: true } }, dn.prototype.forEachGlyph = function(e3, t3, n3, s3, o3, r3) {
          t3 = void 0 !== t3 ? t3 : 0, n3 = void 0 !== n3 ? n3 : 0, s3 = void 0 !== s3 ? s3 : 72, o3 = o3 || this.defaultRenderOptions;
          const a3 = 1 / this.unitsPerEm * s3, i3 = this.stringToGlyphs(e3, o3);
          let l2;
          if (o3.kerning) {
            const e4 = o3.script || this.position.getDefaultScriptName();
            l2 = this.position.getKerningTables(e4, o3.language);
          }
          for (let e4 = 0; e4 < i3.length; e4 += 1) {
            const u2 = i3[e4];
            r3.call(this, u2, t3, n3, s3, o3), u2.advanceWidth && (t3 += u2.advanceWidth * a3), o3.kerning && e4 < i3.length - 1 && (t3 += (l2 ? this.position.getKerningValue(l2, u2.index, i3[e4 + 1].index) : this.getKerningValue(u2, i3[e4 + 1])) * a3), o3.letterSpacing ? t3 += o3.letterSpacing * s3 : o3.tracking && (t3 += o3.tracking / 1e3 * s3);
          }
          return t3;
        }, dn.prototype.getPath = function(e3, t3, n3, s3, o3) {
          const r3 = new u();
          return this.forEachGlyph(e3, t3, n3, s3, o3, function(e4, t4, n4, s4) {
            const a3 = e4.getPath(t4, n4, s4, o3, this);
            r3.extend(a3);
          }), r3;
        }, dn.prototype.getPaths = function(e3, t3, n3, s3, o3) {
          const r3 = [];
          return this.forEachGlyph(e3, t3, n3, s3, o3, function(e4, t4, n4, s4) {
            const a3 = e4.getPath(t4, n4, s4, o3, this);
            r3.push(a3);
          }), r3;
        }, dn.prototype.getAdvanceWidth = function(e3, t3, n3) {
          return this.forEachGlyph(e3, 0, 0, t3, n3, function() {
          });
        }, dn.prototype.draw = function(e3, t3, n3, s3, o3, r3) {
          this.getPath(t3, n3, s3, o3, r3).draw(e3);
        }, dn.prototype.drawPoints = function(e3, t3, n3, s3, o3, r3) {
          this.forEachGlyph(t3, n3, s3, o3, r3, function(t4, n4, s4, o4) {
            t4.drawPoints(e3, n4, s4, o4);
          });
        }, dn.prototype.drawMetrics = function(e3, t3, n3, s3, o3, r3) {
          this.forEachGlyph(t3, n3, s3, o3, r3, function(t4, n4, s4, o4) {
            t4.drawMetrics(e3, n4, s4, o4);
          });
        }, dn.prototype.getEnglishName = function(e3) {
          const t3 = this.names[e3];
          if (t3)
            return t3.en;
        }, dn.prototype.validate = function() {
          const e3 = [], t3 = this;
          function n3(t4, n4) {
            t4 || e3.push(n4);
          }
          function s3(e4) {
            const s4 = t3.getEnglishName(e4);
            n3(s4 && s4.trim().length > 0, "No English " + e4 + " specified.");
          }
          s3("fontFamily"), s3("weightName"), s3("manufacturer"), s3("copyright"), s3("version"), n3(this.unitsPerEm > 0, "No unitsPerEm specified.");
        }, dn.prototype.toTables = function() {
          return lt(this);
        }, dn.prototype.toBuffer = function() {
          return console.warn("Font.toBuffer is deprecated. Use Font.toArrayBuffer instead."), this.toArrayBuffer();
        }, dn.prototype.toArrayBuffer = function() {
          const e3 = this.toTables().encode(), t3 = new ArrayBuffer(e3.length), n3 = new Uint8Array(t3);
          for (let t4 = 0; t4 < e3.length; t4++)
            n3[t4] = e3[t4];
          return t3;
        }, dn.prototype.download = function(e3) {
          const t3 = this.getEnglishName("fontFamily"), s3 = this.getEnglishName("fontSubfamily");
          e3 = e3 || t3.replace(/\s/g, "") + "-" + s3 + ".otf";
          const o3 = this.toArrayBuffer();
          if ("undefined" != typeof window)
            window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem, window.requestFileSystem(window.TEMPORARY, o3.byteLength, function(t4) {
              t4.root.getFile(e3, { create: true }, function(e4) {
                e4.createWriter(function(t5) {
                  const n3 = new DataView(o3), s4 = new Blob([n3], { type: "font/opentype" });
                  t5.write(s4), t5.addEventListener("writeend", function() {
                    location.href = e4.toURL();
                  }, false);
                });
              });
            }, function(e4) {
              throw new Error(e4.name + ": " + e4.message);
            });
          else {
            const t4 = n2(89), s4 = function(e4) {
              const t5 = new Buffer(e4.byteLength), n3 = new Uint8Array(e4);
              for (let e5 = 0; e5 < t5.length; ++e5)
                t5[e5] = n3[e5];
              return t5;
            }(o3);
            t4.writeFileSync(e3, s4);
          }
        }, dn.prototype.fsSelectionValues = { ITALIC: 1, UNDERSCORE: 2, NEGATIVE: 4, OUTLINED: 8, STRIKEOUT: 16, BOLD: 32, REGULAR: 64, USER_TYPO_METRICS: 128, WWS: 256, OBLIQUE: 512 }, dn.prototype.usWidthClasses = { ULTRA_CONDENSED: 1, EXTRA_CONDENSED: 2, CONDENSED: 3, SEMI_CONDENSED: 4, MEDIUM: 5, SEMI_EXPANDED: 6, EXPANDED: 7, EXTRA_EXPANDED: 8, ULTRA_EXPANDED: 9 }, dn.prototype.usWeightClasses = { THIN: 100, EXTRA_LIGHT: 200, LIGHT: 300, NORMAL: 400, MEDIUM: 500, SEMI_BOLD: 600, BOLD: 700, EXTRA_BOLD: 800, BLACK: 900 };
        const gn = dn;
        function mn(e3, t3) {
          const n3 = JSON.stringify(e3);
          let s3 = 256;
          for (let e4 in t3) {
            let o3 = parseInt(e4);
            if (o3 && !(o3 < 256)) {
              if (JSON.stringify(t3[e4]) === n3)
                return o3;
              s3 <= o3 && (s3 = o3 + 1);
            }
          }
          return t3[s3] = e3, s3;
        }
        function yn(e3, t3, n3) {
          const s3 = mn(t3.name, n3);
          return [{ name: "tag_" + e3, type: "TAG", value: t3.tag }, { name: "minValue_" + e3, type: "FIXED", value: t3.minValue << 16 }, { name: "defaultValue_" + e3, type: "FIXED", value: t3.defaultValue << 16 }, { name: "maxValue_" + e3, type: "FIXED", value: t3.maxValue << 16 }, { name: "flags_" + e3, type: "USHORT", value: 0 }, { name: "nameID_" + e3, type: "USHORT", value: s3 }];
        }
        function vn(e3, t3, n3) {
          const s3 = {}, o3 = new z.Parser(e3, t3);
          return s3.tag = o3.parseTag(), s3.minValue = o3.parseFixed(), s3.defaultValue = o3.parseFixed(), s3.maxValue = o3.parseFixed(), o3.skip("uShort", 1), s3.name = n3[o3.parseUShort()] || {}, s3;
        }
        function bn(e3, t3, n3, s3) {
          const o3 = [{ name: "nameID_" + e3, type: "USHORT", value: mn(t3.name, s3) }, { name: "flags_" + e3, type: "USHORT", value: 0 }];
          for (let s4 = 0; s4 < n3.length; ++s4) {
            const r3 = n3[s4].tag;
            o3.push({ name: "axis_" + e3 + " " + r3, type: "FIXED", value: t3.coordinates[r3] << 16 });
          }
          return o3;
        }
        function xn(e3, t3, n3, s3) {
          const o3 = {}, r3 = new z.Parser(e3, t3);
          o3.name = s3[r3.parseUShort()] || {}, r3.skip("uShort", 1), o3.coordinates = {};
          for (let e4 = 0; e4 < n3.length; ++e4)
            o3.coordinates[n3[e4].tag] = r3.parseFixed();
          return o3;
        }
        const Sn = { make: function(e3, t3) {
          const n3 = new M.Table("fvar", [{ name: "version", type: "ULONG", value: 65536 }, { name: "offsetToData", type: "USHORT", value: 0 }, { name: "countSizePairs", type: "USHORT", value: 2 }, { name: "axisCount", type: "USHORT", value: e3.axes.length }, { name: "axisSize", type: "USHORT", value: 20 }, { name: "instanceCount", type: "USHORT", value: e3.instances.length }, { name: "instanceSize", type: "USHORT", value: 4 + 4 * e3.axes.length }]);
          n3.offsetToData = n3.sizeOf();
          for (let s3 = 0; s3 < e3.axes.length; s3++)
            n3.fields = n3.fields.concat(yn(s3, e3.axes[s3], t3));
          for (let s3 = 0; s3 < e3.instances.length; s3++)
            n3.fields = n3.fields.concat(bn(s3, e3.instances[s3], e3.axes, t3));
          return n3;
        }, parse: function(e3, t3, n3) {
          const s3 = new z.Parser(e3, t3), o3 = s3.parseULong();
          f.argument(65536 === o3, "Unsupported fvar table version.");
          const r3 = s3.parseOffset16();
          s3.skip("uShort", 1);
          const a3 = s3.parseUShort(), i3 = s3.parseUShort(), l2 = s3.parseUShort(), u2 = s3.parseUShort(), c2 = [];
          for (let s4 = 0; s4 < a3; s4++)
            c2.push(vn(e3, t3 + r3 + s4 * i3, n3));
          const p2 = [], h2 = t3 + r3 + a3 * i3;
          for (let t4 = 0; t4 < l2; t4++)
            p2.push(xn(e3, h2 + t4 * u2, c2, n3));
          return { axes: c2, instances: p2 };
        } }, Un = new Array(10);
        Un[1] = function() {
          const e3 = this.offset + this.relativeOffset, t3 = this.parseUShort();
          return 1 === t3 ? { posFormat: 1, coverage: this.parsePointer(_.coverage), value: this.parseValueRecord() } : 2 === t3 ? { posFormat: 2, coverage: this.parsePointer(_.coverage), values: this.parseValueRecordList() } : void f.assert(false, "0x" + e3.toString(16) + ": GPOS lookup type 1 format must be 1 or 2.");
        }, Un[2] = function() {
          const e3 = this.offset + this.relativeOffset, t3 = this.parseUShort(), n3 = this.parsePointer(_.coverage), s3 = this.parseUShort(), o3 = this.parseUShort();
          if (1 === t3)
            return { posFormat: t3, coverage: n3, valueFormat1: s3, valueFormat2: o3, pairSets: this.parseList(_.pointer(_.list(function() {
              return { secondGlyph: this.parseUShort(), value1: this.parseValueRecord(s3), value2: this.parseValueRecord(o3) };
            }))) };
          if (2 === t3) {
            const e4 = this.parsePointer(_.classDef), r3 = this.parsePointer(_.classDef), a3 = this.parseUShort(), i3 = this.parseUShort();
            return { posFormat: t3, coverage: n3, valueFormat1: s3, valueFormat2: o3, classDef1: e4, classDef2: r3, class1Count: a3, class2Count: i3, classRecords: this.parseList(a3, _.list(i3, function() {
              return { value1: this.parseValueRecord(s3), value2: this.parseValueRecord(o3) };
            })) };
          }
          f.assert(false, "0x" + e3.toString(16) + ": GPOS lookup type 2 format must be 1 or 2.");
        }, Un[3] = function() {
          return { error: "GPOS Lookup 3 not supported" };
        }, Un[4] = function() {
          return { error: "GPOS Lookup 4 not supported" };
        }, Un[5] = function() {
          return { error: "GPOS Lookup 5 not supported" };
        }, Un[6] = function() {
          return { error: "GPOS Lookup 6 not supported" };
        }, Un[7] = function() {
          return { error: "GPOS Lookup 7 not supported" };
        }, Un[8] = function() {
          return { error: "GPOS Lookup 8 not supported" };
        }, Un[9] = function() {
          return { error: "GPOS Lookup 9 not supported" };
        };
        const kn = new Array(10), Tn = { parse: function(e3, t3) {
          const n3 = new _(e3, t3 = t3 || 0), s3 = n3.parseVersion(1);
          return f.argument(1 === s3 || 1.1 === s3, "Unsupported GPOS table version " + s3), 1 === s3 ? { version: s3, scripts: n3.parseScriptList(), features: n3.parseFeatureList(), lookups: n3.parseLookupList(Un) } : { version: s3, scripts: n3.parseScriptList(), features: n3.parseFeatureList(), lookups: n3.parseLookupList(Un), variations: n3.parseFeatureVariationsList() };
        }, make: function(e3) {
          return new M.Table("GPOS", [{ name: "version", type: "ULONG", value: 65536 }, { name: "scripts", type: "TABLE", value: new M.ScriptList(e3.scripts) }, { name: "features", type: "TABLE", value: new M.FeatureList(e3.features) }, { name: "lookups", type: "TABLE", value: new M.LookupList(e3.lookups, kn) }]);
        } }, En = { parse: function(e3, t3) {
          const n3 = new z.Parser(e3, t3), s3 = n3.parseUShort();
          if (0 === s3)
            return function(e4) {
              const t4 = {};
              e4.skip("uShort");
              const n4 = e4.parseUShort();
              f.argument(0 === n4, "Unsupported kern sub-table version."), e4.skip("uShort", 2);
              const s4 = e4.parseUShort();
              e4.skip("uShort", 3);
              for (let n5 = 0; n5 < s4; n5 += 1) {
                const n6 = e4.parseUShort(), s5 = e4.parseUShort(), o3 = e4.parseShort();
                t4[n6 + "," + s5] = o3;
              }
              return t4;
            }(n3);
          if (1 === s3)
            return function(e4) {
              const t4 = {};
              e4.skip("uShort"), e4.parseULong() > 1 && console.warn("Only the first kern subtable is supported."), e4.skip("uLong");
              const n4 = 255 & e4.parseUShort();
              if (e4.skip("uShort"), 0 === n4) {
                const n5 = e4.parseUShort();
                e4.skip("uShort", 3);
                for (let s4 = 0; s4 < n5; s4 += 1) {
                  const n6 = e4.parseUShort(), s5 = e4.parseUShort(), o3 = e4.parseShort();
                  t4[n6 + "," + s5] = o3;
                }
              }
              return t4;
            }(n3);
          throw new Error("Unsupported kern table version (" + s3 + ").");
        } }, wn = { parse: function(e3, t3, n3, s3) {
          const o3 = new z.Parser(e3, t3), r3 = s3 ? o3.parseUShort : o3.parseULong, a3 = [];
          for (let e4 = 0; e4 < n3 + 1; e4 += 1) {
            let e5 = r3.call(o3);
            s3 && (e5 *= 2), a3.push(e5);
          }
          return a3;
        } };
        function On(e3, t3) {
          n2(89).readFile(e3, function(e4, n3) {
            if (e4)
              return t3(e4.message);
            t3(null, xt(n3));
          });
        }
        function In(e3, t3) {
          const n3 = new XMLHttpRequest();
          n3.open("get", e3, true), n3.responseType = "arraybuffer", n3.onload = function() {
            return n3.response ? t3(null, n3.response) : t3("Font could not be loaded: " + n3.statusText);
          }, n3.onerror = function() {
            t3("Font could not be loaded");
          }, n3.send();
        }
        function Rn(e3, t3) {
          const n3 = [];
          let s3 = 12;
          for (let o3 = 0; o3 < t3; o3 += 1) {
            const t4 = z.getTag(e3, s3), o4 = z.getULong(e3, s3 + 4), r3 = z.getULong(e3, s3 + 8), a3 = z.getULong(e3, s3 + 12);
            n3.push({ tag: t4, checksum: o4, offset: r3, length: a3, compression: false }), s3 += 16;
          }
          return n3;
        }
        function Ln(e3, t3) {
          if ("WOFF" === t3.compression) {
            const n3 = new Uint8Array(e3.buffer, t3.offset + 2, t3.compressedLength - 2), s3 = new Uint8Array(t3.length);
            if (o2()(n3, s3), s3.byteLength !== t3.length)
              throw new Error("Decompression error: " + t3.tag + " decompressed length doesn't match recorded length");
            return { data: new DataView(s3.buffer, 0), offset: 0 };
          }
          return { data: e3, offset: t3.offset };
        }
        function Bn(e3) {
          let t3, n3;
          const s3 = new gn({ empty: true }), o3 = new DataView(e3, 0);
          let r3, a3 = [];
          const i3 = z.getTag(o3, 0);
          if (i3 === String.fromCharCode(0, 1, 0, 0) || "true" === i3 || "typ1" === i3)
            s3.outlinesFormat = "truetype", r3 = z.getUShort(o3, 4), a3 = Rn(o3, r3);
          else if ("OTTO" === i3)
            s3.outlinesFormat = "cff", r3 = z.getUShort(o3, 4), a3 = Rn(o3, r3);
          else {
            if ("wOFF" !== i3)
              throw new Error("Unsupported OpenType signature " + i3);
            {
              const e4 = z.getTag(o3, 4);
              if (e4 === String.fromCharCode(0, 1, 0, 0))
                s3.outlinesFormat = "truetype";
              else {
                if ("OTTO" !== e4)
                  throw new Error("Unsupported OpenType flavor " + i3);
                s3.outlinesFormat = "cff";
              }
              r3 = z.getUShort(o3, 12), a3 = function(e5, t4) {
                const n4 = [];
                let s4 = 44;
                for (let o4 = 0; o4 < t4; o4 += 1) {
                  const t5 = z.getTag(e5, s4), o5 = z.getULong(e5, s4 + 4), r4 = z.getULong(e5, s4 + 8), a4 = z.getULong(e5, s4 + 12);
                  let i4;
                  i4 = r4 < a4 && "WOFF", n4.push({ tag: t5, offset: o5, compression: i4, compressedLength: r4, length: a4 }), s4 += 20;
                }
                return n4;
              }(o3, r3);
            }
          }
          let l2, u2, c2, p2, f2, h2, d2, g2, m2, y2, v2;
          for (let e4 = 0; e4 < r3; e4 += 1) {
            const r4 = a3[e4];
            let i4;
            switch (r4.tag) {
              case "cmap":
                i4 = Ln(o3, r4), s3.tables.cmap = q.parse(i4.data, i4.offset), s3.encoding = new Q(s3.tables.cmap);
                break;
              case "cvt ":
                i4 = Ln(o3, r4), v2 = new z.Parser(i4.data, i4.offset), s3.tables.cvt = v2.parseShortList(r4.length / 2);
                break;
              case "fvar":
                u2 = r4;
                break;
              case "fpgm":
                i4 = Ln(o3, r4), v2 = new z.Parser(i4.data, i4.offset), s3.tables.fpgm = v2.parseByteList(r4.length);
                break;
              case "head":
                i4 = Ln(o3, r4), s3.tables.head = Le.parse(i4.data, i4.offset), s3.unitsPerEm = s3.tables.head.unitsPerEm, t3 = s3.tables.head.indexToLocFormat;
                break;
              case "hhea":
                i4 = Ln(o3, r4), s3.tables.hhea = Be.parse(i4.data, i4.offset), s3.ascender = s3.tables.hhea.ascender, s3.descender = s3.tables.hhea.descender, s3.numberOfHMetrics = s3.tables.hhea.numberOfHMetrics;
                break;
              case "hmtx":
                h2 = r4;
                break;
              case "ltag":
                i4 = Ln(o3, r4), n3 = De.parse(i4.data, i4.offset);
                break;
              case "maxp":
                i4 = Ln(o3, r4), s3.tables.maxp = Me.parse(i4.data, i4.offset), s3.numGlyphs = s3.tables.maxp.numGlyphs;
                break;
              case "name":
                m2 = r4;
                break;
              case "OS/2":
                i4 = Ln(o3, r4), s3.tables.os2 = Ze.parse(i4.data, i4.offset);
                break;
              case "post":
                i4 = Ln(o3, r4), s3.tables.post = Qe.parse(i4.data, i4.offset), s3.glyphNames = new K(s3.tables.post);
                break;
              case "prep":
                i4 = Ln(o3, r4), v2 = new z.Parser(i4.data, i4.offset), s3.tables.prep = v2.parseByteList(r4.length);
                break;
              case "glyf":
                c2 = r4;
                break;
              case "loca":
                g2 = r4;
                break;
              case "CFF ":
                l2 = r4;
                break;
              case "kern":
                d2 = r4;
                break;
              case "GPOS":
                p2 = r4;
                break;
              case "GSUB":
                f2 = r4;
                break;
              case "meta":
                y2 = r4;
            }
          }
          const b2 = Ln(o3, m2);
          if (s3.tables.name = Ve.parse(b2.data, b2.offset, n3), s3.names = s3.tables.name, c2 && g2) {
            const e4 = 0 === t3, n4 = Ln(o3, g2), r4 = wn.parse(n4.data, n4.offset, s3.numGlyphs, e4), a4 = Ln(o3, c2);
            s3.glyphs = re.parse(a4.data, a4.offset, r4, s3);
          } else {
            if (!l2)
              throw new Error("Font doesn't contain TrueType or CFF outlines.");
            {
              const e4 = Ln(o3, l2);
              Re.parse(e4.data, e4.offset, s3);
            }
          }
          const x2 = Ln(o3, h2);
          if (Ce.parse(x2.data, x2.offset, s3.numberOfHMetrics, s3.numGlyphs, s3.glyphs), function(e4) {
            let t4;
            const n4 = e4.tables.cmap.glyphIndexMap, s4 = Object.keys(n4);
            for (let o4 = 0; o4 < s4.length; o4 += 1) {
              const r4 = s4[o4], a4 = n4[r4];
              t4 = e4.glyphs.get(a4), t4.addUnicode(parseInt(r4));
            }
            for (let n5 = 0; n5 < e4.glyphs.length; n5 += 1)
              t4 = e4.glyphs.get(n5), e4.cffEncoding ? e4.isCIDFont ? t4.name = "gid" + n5 : t4.name = e4.cffEncoding.charset[n5] : e4.glyphNames.names && (t4.name = e4.glyphNames.glyphIndexToName(n5));
          }(s3), d2) {
            const e4 = Ln(o3, d2);
            s3.kerningPairs = En.parse(e4.data, e4.offset);
          } else
            s3.kerningPairs = {};
          if (p2) {
            const e4 = Ln(o3, p2);
            s3.tables.gpos = Tn.parse(e4.data, e4.offset);
          }
          if (f2) {
            const e4 = Ln(o3, f2);
            s3.tables.gsub = et.parse(e4.data, e4.offset);
          }
          if (u2) {
            const e4 = Ln(o3, u2);
            s3.tables.fvar = Sn.parse(e4.data, e4.offset, s3.names);
          }
          if (y2) {
            const e4 = Ln(o3, y2);
            s3.tables.meta = tt.parse(e4.data, e4.offset), s3.metas = s3.tables.meta;
          }
          return s3;
        }
        function Cn(e3, t3) {
          ("undefined" == typeof window ? On : In)(e3, function(e4, n3) {
            if (e4)
              return t3(e4);
            let s3;
            try {
              s3 = Bn(n3);
            } catch (e5) {
              return t3(e5, null);
            }
            return t3(null, s3);
          });
        }
        function Dn(e3) {
          return Bn(xt(n2(89).readFileSync(e3)));
        }
      }, 896: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        const s2 = n2(978);
        class o2 extends s2.Writable {
          constructor() {
            super(...arguments), this.offset = 0, this._waiters = [], this._closed = false;
          }
          _write(e3, t3, n3) {
            let s3 = 0;
            const o3 = () => {
              for (; this._waiters.length > 0; ) {
                const t4 = this._waiters[0];
                if (this._buffer) {
                  const o4 = this._buffer.size - this._buffer.offset;
                  if (!(o4 + e3.length >= t4.size)) {
                    if (!t4.skip) {
                      const t5 = Buffer.alloc(o4 + e3.length);
                      this._buffer.buf.copy(t5, 0, this._buffer.offset, this._buffer.size), e3.copy(t5, o4, 0, e3.length), this._buffer.buf = t5;
                    }
                    this._buffer.offset = 0, this._buffer.size = o4 + e3.length, n3();
                    break;
                  }
                  if (t4.skip)
                    this._buffer = void 0, t4.resolve();
                  else {
                    const n4 = Math.min(o4, t4.size), s4 = Buffer.alloc(t4.size);
                    this._buffer.buf.copy(s4, 0, this._buffer.offset, this._buffer.offset + n4), e3.copy(s4, n4, 0, t4.size - n4), t4.resolve(s4);
                  }
                  if (this.offset += t4.size, this._waiters.shift(), this._buffer = void 0, o4 + e3.length === t4.size) {
                    n3();
                    break;
                  }
                  s3 += t4.size - o4;
                } else {
                  if (!(e3.length - s3 >= t4.size)) {
                    this._buffer = { buf: t4.skip ? void 0 : e3.slice(s3), offset: 0, size: e3.length - s3 }, s3 = e3.length, n3();
                    break;
                  }
                  if (t4.skip ? t4.resolve() : t4.resolve(e3.slice(s3, s3 + t4.size)), this.offset += t4.size, this._waiters.shift(), s3 += t4.size, e3.length === s3) {
                    n3();
                    break;
                  }
                }
              }
              this._processTrigger = e3.length - s3 > 0 ? o3 : void 0;
            };
            o3();
          }
          _destroy(e3, t3) {
            this._processTrigger = void 0;
            for (const t4 of this._waiters)
              t4.reject(e3 || new Error("stream destroyed"));
            this._waiters = [], this._closed = true;
          }
          _final(e3) {
            this._processTrigger = void 0;
            for (const e4 of this._waiters)
              e4.reject(new Error("not enough data in stream"));
            this._waiters = [], this._closed = true;
          }
          read(e3) {
            return new Promise((t3, n3) => {
              this._closed && n3(new Error("stream is closed")), this._waiters.push({ resolve: t3, reject: n3, size: e3, skip: false }), this._processTrigger && this._processTrigger();
            });
          }
          skip(e3) {
            return new Promise((t3, n3) => {
              this._closed && n3(new Error("stream is closed")), this._waiters.push({ resolve: t3, reject: n3, size: e3, skip: true }), this._processTrigger && this._processTrigger();
            });
          }
        }
        function r2() {
          return new o2();
        }
        e2.exports = Object.assign(r2, { default: r2 }), t2.default = r2;
      }, 311: (e2) => {
        function t2() {
          this.table = new Uint16Array(16), this.trans = new Uint16Array(288);
        }
        function n2(e3, n3) {
          this.source = e3, this.sourceIndex = 0, this.tag = 0, this.bitcount = 0, this.dest = n3, this.destLen = 0, this.ltree = new t2(), this.dtree = new t2();
        }
        var s2 = new t2(), o2 = new t2(), r2 = new Uint8Array(30), a2 = new Uint16Array(30), i2 = new Uint8Array(30), l = new Uint16Array(30), u = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), c = new t2(), p = new Uint8Array(320);
        function f(e3, t3, n3, s3) {
          var o3, r3;
          for (o3 = 0; o3 < n3; ++o3)
            e3[o3] = 0;
          for (o3 = 0; o3 < 30 - n3; ++o3)
            e3[o3 + n3] = o3 / n3 | 0;
          for (r3 = s3, o3 = 0; o3 < 30; ++o3)
            t3[o3] = r3, r3 += 1 << e3[o3];
        }
        var h = new Uint16Array(16);
        function d(e3, t3, n3, s3) {
          var o3, r3;
          for (o3 = 0; o3 < 16; ++o3)
            e3.table[o3] = 0;
          for (o3 = 0; o3 < s3; ++o3)
            e3.table[t3[n3 + o3]]++;
          for (e3.table[0] = 0, r3 = 0, o3 = 0; o3 < 16; ++o3)
            h[o3] = r3, r3 += e3.table[o3];
          for (o3 = 0; o3 < s3; ++o3)
            t3[n3 + o3] && (e3.trans[h[t3[n3 + o3]]++] = o3);
        }
        function g(e3) {
          e3.bitcount-- || (e3.tag = e3.source[e3.sourceIndex++], e3.bitcount = 7);
          var t3 = 1 & e3.tag;
          return e3.tag >>>= 1, t3;
        }
        function m(e3, t3, n3) {
          if (!t3)
            return n3;
          for (; e3.bitcount < 24; )
            e3.tag |= e3.source[e3.sourceIndex++] << e3.bitcount, e3.bitcount += 8;
          var s3 = e3.tag & 65535 >>> 16 - t3;
          return e3.tag >>>= t3, e3.bitcount -= t3, s3 + n3;
        }
        function y(e3, t3) {
          for (; e3.bitcount < 24; )
            e3.tag |= e3.source[e3.sourceIndex++] << e3.bitcount, e3.bitcount += 8;
          var n3 = 0, s3 = 0, o3 = 0, r3 = e3.tag;
          do {
            s3 = 2 * s3 + (1 & r3), r3 >>>= 1, ++o3, n3 += t3.table[o3], s3 -= t3.table[o3];
          } while (s3 >= 0);
          return e3.tag = r3, e3.bitcount -= o3, t3.trans[n3 + s3];
        }
        function v(e3, t3, n3) {
          var s3, o3, r3, a3, i3, l2;
          for (s3 = m(e3, 5, 257), o3 = m(e3, 5, 1), r3 = m(e3, 4, 4), a3 = 0; a3 < 19; ++a3)
            p[a3] = 0;
          for (a3 = 0; a3 < r3; ++a3) {
            var f2 = m(e3, 3, 0);
            p[u[a3]] = f2;
          }
          for (d(c, p, 0, 19), i3 = 0; i3 < s3 + o3; ) {
            var h2 = y(e3, c);
            switch (h2) {
              case 16:
                var g2 = p[i3 - 1];
                for (l2 = m(e3, 2, 3); l2; --l2)
                  p[i3++] = g2;
                break;
              case 17:
                for (l2 = m(e3, 3, 3); l2; --l2)
                  p[i3++] = 0;
                break;
              case 18:
                for (l2 = m(e3, 7, 11); l2; --l2)
                  p[i3++] = 0;
                break;
              default:
                p[i3++] = h2;
            }
          }
          d(t3, p, 0, s3), d(n3, p, s3, o3);
        }
        function b(e3, t3, n3) {
          for (; ; ) {
            var s3, o3, u2, c2, p2 = y(e3, t3);
            if (256 === p2)
              return 0;
            if (p2 < 256)
              e3.dest[e3.destLen++] = p2;
            else
              for (s3 = m(e3, r2[p2 -= 257], a2[p2]), o3 = y(e3, n3), c2 = u2 = e3.destLen - m(e3, i2[o3], l[o3]); c2 < u2 + s3; ++c2)
                e3.dest[e3.destLen++] = e3.dest[c2];
          }
        }
        function x(e3) {
          for (var t3, n3; e3.bitcount > 8; )
            e3.sourceIndex--, e3.bitcount -= 8;
          if ((t3 = 256 * (t3 = e3.source[e3.sourceIndex + 1]) + e3.source[e3.sourceIndex]) !== (65535 & ~(256 * e3.source[e3.sourceIndex + 3] + e3.source[e3.sourceIndex + 2])))
            return -3;
          for (e3.sourceIndex += 4, n3 = t3; n3; --n3)
            e3.dest[e3.destLen++] = e3.source[e3.sourceIndex++];
          return e3.bitcount = 0, 0;
        }
        !function(e3, t3) {
          var n3;
          for (n3 = 0; n3 < 7; ++n3)
            e3.table[n3] = 0;
          for (e3.table[7] = 24, e3.table[8] = 152, e3.table[9] = 112, n3 = 0; n3 < 24; ++n3)
            e3.trans[n3] = 256 + n3;
          for (n3 = 0; n3 < 144; ++n3)
            e3.trans[24 + n3] = n3;
          for (n3 = 0; n3 < 8; ++n3)
            e3.trans[168 + n3] = 280 + n3;
          for (n3 = 0; n3 < 112; ++n3)
            e3.trans[176 + n3] = 144 + n3;
          for (n3 = 0; n3 < 5; ++n3)
            t3.table[n3] = 0;
          for (t3.table[5] = 32, n3 = 0; n3 < 32; ++n3)
            t3.trans[n3] = n3;
        }(s2, o2), f(r2, a2, 4, 3), f(i2, l, 2, 1), r2[28] = 0, a2[28] = 258, e2.exports = function(e3, t3) {
          var r3, a3, i3 = new n2(e3, t3);
          do {
            switch (r3 = g(i3), m(i3, 2, 0)) {
              case 0:
                a3 = x(i3);
                break;
              case 1:
                a3 = b(i3, s2, o2);
                break;
              case 2:
                v(i3, i3.ltree, i3.dtree), a3 = b(i3, i3.ltree, i3.dtree);
                break;
              default:
                a3 = -3;
            }
            if (0 !== a3)
              throw new Error("Data error");
          } while (!r3);
          return i3.destLen < i3.dest.length ? "function" == typeof i3.dest.slice ? i3.dest.slice(0, i3.destLen) : i3.dest.subarray(0, i3.destLen) : i3.dest;
        };
      }, 371: (e2) => {
        "use strict";
        e2.exports = function(e3) {
          e3.prototype[Symbol.iterator] = function* () {
            for (let e4 = this.head; e4; e4 = e4.next)
              yield e4.value;
          };
        };
      }, 411: (e2, t2, n2) => {
        "use strict";
        function s2(e3) {
          var t3 = this;
          if (t3 instanceof s2 || (t3 = new s2()), t3.tail = null, t3.head = null, t3.length = 0, e3 && "function" == typeof e3.forEach)
            e3.forEach(function(e4) {
              t3.push(e4);
            });
          else if (arguments.length > 0)
            for (var n3 = 0, o3 = arguments.length; n3 < o3; n3++)
              t3.push(arguments[n3]);
          return t3;
        }
        function o2(e3, t3, n3) {
          var s3 = t3 === e3.head ? new i2(n3, null, t3, e3) : new i2(n3, t3, t3.next, e3);
          return null === s3.next && (e3.tail = s3), null === s3.prev && (e3.head = s3), e3.length++, s3;
        }
        function r2(e3, t3) {
          e3.tail = new i2(t3, e3.tail, null, e3), e3.head || (e3.head = e3.tail), e3.length++;
        }
        function a2(e3, t3) {
          e3.head = new i2(t3, null, e3.head, e3), e3.tail || (e3.tail = e3.head), e3.length++;
        }
        function i2(e3, t3, n3, s3) {
          if (!(this instanceof i2))
            return new i2(e3, t3, n3, s3);
          this.list = s3, this.value = e3, t3 ? (t3.next = this, this.prev = t3) : this.prev = null, n3 ? (n3.prev = this, this.next = n3) : this.next = null;
        }
        e2.exports = s2, s2.Node = i2, s2.create = s2, s2.prototype.removeNode = function(e3) {
          if (e3.list !== this)
            throw new Error("removing node which does not belong to this list");
          var t3 = e3.next, n3 = e3.prev;
          return t3 && (t3.prev = n3), n3 && (n3.next = t3), e3 === this.head && (this.head = t3), e3 === this.tail && (this.tail = n3), e3.list.length--, e3.next = null, e3.prev = null, e3.list = null, t3;
        }, s2.prototype.unshiftNode = function(e3) {
          if (e3 !== this.head) {
            e3.list && e3.list.removeNode(e3);
            var t3 = this.head;
            e3.list = this, e3.next = t3, t3 && (t3.prev = e3), this.head = e3, this.tail || (this.tail = e3), this.length++;
          }
        }, s2.prototype.pushNode = function(e3) {
          if (e3 !== this.tail) {
            e3.list && e3.list.removeNode(e3);
            var t3 = this.tail;
            e3.list = this, e3.prev = t3, t3 && (t3.next = e3), this.tail = e3, this.head || (this.head = e3), this.length++;
          }
        }, s2.prototype.push = function() {
          for (var e3 = 0, t3 = arguments.length; e3 < t3; e3++)
            r2(this, arguments[e3]);
          return this.length;
        }, s2.prototype.unshift = function() {
          for (var e3 = 0, t3 = arguments.length; e3 < t3; e3++)
            a2(this, arguments[e3]);
          return this.length;
        }, s2.prototype.pop = function() {
          if (this.tail) {
            var e3 = this.tail.value;
            return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e3;
          }
        }, s2.prototype.shift = function() {
          if (this.head) {
            var e3 = this.head.value;
            return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e3;
          }
        }, s2.prototype.forEach = function(e3, t3) {
          t3 = t3 || this;
          for (var n3 = this.head, s3 = 0; null !== n3; s3++)
            e3.call(t3, n3.value, s3, this), n3 = n3.next;
        }, s2.prototype.forEachReverse = function(e3, t3) {
          t3 = t3 || this;
          for (var n3 = this.tail, s3 = this.length - 1; null !== n3; s3--)
            e3.call(t3, n3.value, s3, this), n3 = n3.prev;
        }, s2.prototype.get = function(e3) {
          for (var t3 = 0, n3 = this.head; null !== n3 && t3 < e3; t3++)
            n3 = n3.next;
          if (t3 === e3 && null !== n3)
            return n3.value;
        }, s2.prototype.getReverse = function(e3) {
          for (var t3 = 0, n3 = this.tail; null !== n3 && t3 < e3; t3++)
            n3 = n3.prev;
          if (t3 === e3 && null !== n3)
            return n3.value;
        }, s2.prototype.map = function(e3, t3) {
          t3 = t3 || this;
          for (var n3 = new s2(), o3 = this.head; null !== o3; )
            n3.push(e3.call(t3, o3.value, this)), o3 = o3.next;
          return n3;
        }, s2.prototype.mapReverse = function(e3, t3) {
          t3 = t3 || this;
          for (var n3 = new s2(), o3 = this.tail; null !== o3; )
            n3.push(e3.call(t3, o3.value, this)), o3 = o3.prev;
          return n3;
        }, s2.prototype.reduce = function(e3, t3) {
          var n3, s3 = this.head;
          if (arguments.length > 1)
            n3 = t3;
          else {
            if (!this.head)
              throw new TypeError("Reduce of empty list with no initial value");
            s3 = this.head.next, n3 = this.head.value;
          }
          for (var o3 = 0; null !== s3; o3++)
            n3 = e3(n3, s3.value, o3), s3 = s3.next;
          return n3;
        }, s2.prototype.reduceReverse = function(e3, t3) {
          var n3, s3 = this.tail;
          if (arguments.length > 1)
            n3 = t3;
          else {
            if (!this.tail)
              throw new TypeError("Reduce of empty list with no initial value");
            s3 = this.tail.prev, n3 = this.tail.value;
          }
          for (var o3 = this.length - 1; null !== s3; o3--)
            n3 = e3(n3, s3.value, o3), s3 = s3.prev;
          return n3;
        }, s2.prototype.toArray = function() {
          for (var e3 = new Array(this.length), t3 = 0, n3 = this.head; null !== n3; t3++)
            e3[t3] = n3.value, n3 = n3.next;
          return e3;
        }, s2.prototype.toArrayReverse = function() {
          for (var e3 = new Array(this.length), t3 = 0, n3 = this.tail; null !== n3; t3++)
            e3[t3] = n3.value, n3 = n3.prev;
          return e3;
        }, s2.prototype.slice = function(e3, t3) {
          (t3 = t3 || this.length) < 0 && (t3 += this.length), (e3 = e3 || 0) < 0 && (e3 += this.length);
          var n3 = new s2();
          if (t3 < e3 || t3 < 0)
            return n3;
          e3 < 0 && (e3 = 0), t3 > this.length && (t3 = this.length);
          for (var o3 = 0, r3 = this.head; null !== r3 && o3 < e3; o3++)
            r3 = r3.next;
          for (; null !== r3 && o3 < t3; o3++, r3 = r3.next)
            n3.push(r3.value);
          return n3;
        }, s2.prototype.sliceReverse = function(e3, t3) {
          (t3 = t3 || this.length) < 0 && (t3 += this.length), (e3 = e3 || 0) < 0 && (e3 += this.length);
          var n3 = new s2();
          if (t3 < e3 || t3 < 0)
            return n3;
          e3 < 0 && (e3 = 0), t3 > this.length && (t3 = this.length);
          for (var o3 = this.length, r3 = this.tail; null !== r3 && o3 > t3; o3--)
            r3 = r3.prev;
          for (; null !== r3 && o3 > e3; o3--, r3 = r3.prev)
            n3.push(r3.value);
          return n3;
        }, s2.prototype.splice = function(e3, t3, ...n3) {
          e3 > this.length && (e3 = this.length - 1), e3 < 0 && (e3 = this.length + e3);
          for (var s3 = 0, r3 = this.head; null !== r3 && s3 < e3; s3++)
            r3 = r3.next;
          var a3 = [];
          for (s3 = 0; r3 && s3 < t3; s3++)
            a3.push(r3.value), r3 = this.removeNode(r3);
          for (null === r3 && (r3 = this.tail), r3 !== this.head && r3 !== this.tail && (r3 = r3.prev), s3 = 0; s3 < n3.length; s3++)
            r3 = o2(this, r3, n3[s3]);
          return a3;
        }, s2.prototype.reverse = function() {
          for (var e3 = this.head, t3 = this.tail, n3 = e3; null !== n3; n3 = n3.prev) {
            var s3 = n3.prev;
            n3.prev = n3.next, n3.next = s3;
          }
          return this.head = t3, this.tail = e3, this;
        };
        try {
          n2(371)(s2);
        } catch (e3) {
        }
      }, 109: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        const s2 = n2(98), o2 = n2(104);
        let r2;
        t2.default = async function(e3, t3) {
          var n3, i2;
          if (!r2) {
            if ("undefined" != typeof navigator && "fonts" in navigator) {
              try {
                const e5 = await (null === (i2 = (n3 = navigator.permissions).request) || void 0 === i2 ? void 0 : i2.call(n3, { name: "local-fonts" }));
                if (e5 && "granted" !== e5.state)
                  throw new Error("Permission to access local fonts not granted.");
              } catch (e5) {
                if ("TypeError" !== e5.name)
                  throw e5;
              }
              const e4 = {};
              try {
                const t4 = await navigator.fonts.query();
                for (const n4 of t4)
                  e4.hasOwnProperty(n4.family) || (e4[n4.family] = []), e4[n4.family].push(n4);
                r2 = Promise.resolve(e4);
              } catch (e5) {
                console.error(e5.name, e5.message);
              }
            } else if ("undefined" != typeof window && "queryLocalFonts" in window) {
              const e4 = {};
              try {
                const t4 = await window.queryLocalFonts();
                for (const n4 of t4)
                  e4.hasOwnProperty(n4.family) || (e4[n4.family] = []), e4[n4.family].push(n4);
                r2 = Promise.resolve(e4);
              } catch (e5) {
                console.error(e5.name, e5.message);
              }
            }
            r2 || (r2 = Promise.resolve({}));
          }
          const l = await r2;
          for (const n4 of (0, o2.default)(e3)) {
            if (a2.includes(n4))
              return;
            if (l.hasOwnProperty(n4) && l[n4].length > 0) {
              const e4 = l[n4][0];
              if ("blob" in e4) {
                const n5 = await e4.blob(), o3 = await n5.arrayBuffer();
                return (0, s2.loadBuffer)(o3, { cacheSize: t3 });
              }
              return;
            }
          }
        };
        const a2 = ["serif", "sans-serif", "cursive", "fantasy", "monospace", "system-ui", "emoji", "math", "fangsong"];
      }, 833: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.enableLigatures = void 0;
        const s2 = n2(109);
        t2.enableLigatures = function(e3, t3 = []) {
          let n3, o2, r2, a2 = 0;
          return e3.registerCharacterJoiner((i2) => {
            const l = e3.options.fontFamily;
            if (l && (0 === a2 || n3 !== l)) {
              o2 = void 0, a2 = 1, n3 = l;
              const t4 = n3;
              (0, s2.default)(t4, 1e5).then((n4) => {
                t4 === e3.options.fontFamily && (a2 = 2, o2 = n4, n4 && e3.refresh(0, e3.rows - 1));
              }).catch((n4) => {
                t4 === e3.options.fontFamily && (a2 = 3, "debug" === e3.options.logLevel && console.debug(r2, new Error("Failure while loading font")), o2 = void 0, r2 = n4);
              });
            }
            return o2 && 2 === a2 ? o2.findLigatureRanges(i2).map((e4) => [e4[0], e4[1]]) : function(e4, t4) {
              const n4 = [];
              for (let s3 = 0; s3 < e4.length; s3++)
                for (let o3 = 0; o3 < t4.length; o3++)
                  if (e4.startsWith(t4[o3], s3)) {
                    n4.push([s3, s3 + t4[o3].length]), s3 += t4[o3].length - 1;
                    break;
                  }
              return n4;
            }(i2, t3);
          });
        };
      }, 104: (e2, t2) => {
        "use strict";
        function n2(e3, t3) {
          let n3 = "", s3 = false;
          for (; e3.offset < e3.input.length; ) {
            const r3 = e3.input[e3.offset++];
            if (s3)
              /[\dA-Fa-f]/.test(r3) ? (e3.offset--, n3 += o2(e3)) : "\n" !== r3 && (n3 += r3), s3 = false;
            else
              switch (r3) {
                case t3:
                  return n3;
                case "\\":
                  s3 = true;
                  break;
                default:
                  n3 += r3;
              }
          }
          throw new Error("Unterminated string");
        }
        function s2(e3) {
          let t3 = "", n3 = false;
          for (; e3.offset < e3.input.length; ) {
            const s3 = e3.input[e3.offset++];
            if (n3)
              /[\dA-Fa-f]/.test(s3) ? (e3.offset--, t3 += o2(e3)) : t3 += s3, n3 = false;
            else
              switch (s3) {
                case "\\":
                  n3 = true;
                  break;
                case ",":
                  return t3;
                default:
                  /\s/.test(s3) ? t3.endsWith(" ") || (t3 += " ") : t3 += s3;
              }
          }
          return t3;
        }
        function o2(e3) {
          let t3 = "";
          for (; e3.offset < e3.input.length; ) {
            const n3 = e3.input[e3.offset++];
            if (/\s/.test(n3))
              return r2(t3);
            if (t3.length >= 6 || !/[\dA-Fa-f]/.test(n3))
              return e3.offset--, r2(t3);
            t3 += n3;
          }
          return r2(t3);
        }
        function r2(e3) {
          return String.fromCodePoint(parseInt(e3, 16));
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          if ("string" != typeof e3)
            throw new Error("Font family must be a string");
          const t3 = { input: e3, offset: 0 }, o3 = [];
          let r3 = "";
          for (; t3.offset < t3.input.length; ) {
            const e4 = t3.input[t3.offset++];
            switch (e4) {
              case "'":
              case '"':
                r3 += n2(t3, e4);
                break;
              case ",":
                o3.push(r3), r3 = "";
                break;
              default:
                /\s/.test(e4) || (t3.offset--, r3 += s2(t3), o3.push(r3), r3 = "");
            }
          }
          return o3;
        };
      }, 89: (t2) => {
        "use strict";
        t2.exports = e;
      }, 56: (e2) => {
        "use strict";
        e2.exports = t;
      }, 978: (e2) => {
        "use strict";
        e2.exports = s;
      }, 269: (e2) => {
        "use strict";
        e2.exports = n;
      }, 82: () => {
      }, 456: () => {
      } }, r = {};
      function a(e2) {
        var t2 = r[e2];
        if (void 0 !== t2)
          return t2.exports;
        var n2 = r[e2] = { exports: {} };
        return o[e2].call(n2.exports, n2, n2.exports, a), n2.exports;
      }
      a.n = (e2) => {
        var t2 = e2 && e2.__esModule ? () => e2.default : () => e2;
        return a.d(t2, { a: t2 }), t2;
      }, a.d = (e2, t2) => {
        for (var n2 in t2)
          a.o(t2, n2) && !a.o(e2, n2) && Object.defineProperty(e2, n2, { enumerable: true, get: t2[n2] });
      }, a.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), a.r = (e2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
      };
      var i = {};
      return (() => {
        "use strict";
        var e2 = i;
        Object.defineProperty(e2, "__esModule", { value: true }), e2.LigaturesAddon = void 0;
        const t2 = a(833);
        e2.LigaturesAddon = class {
          constructor(e3) {
            this._fallbackLigatures = ((null == e3 ? void 0 : e3.fallbackLigatures) || ["<--", "<---", "<<-", "<-", "->", "->>", "-->", "--->", "<==", "<===", "<<=", "<=", "=>", "=>>", "==>", "===>", ">=", ">>=", "<->", "<-->", "<--->", "<---->", "<=>", "<==>", "<===>", "<====>", "-------->", "<~~", "<~", "~>", "~~>", "::", ":::", "==", "!=", "===", "!==", ":=", ":-", ":+", "<*", "<*>", "*>", "<|", "<|>", "|>", "+:", "-:", "=:", ":>", "++", "+++", "<!--", "<!---", "<***>"]).sort((e4, t3) => t3.length - e4.length);
          }
          activate(e3) {
            this._terminal = e3, this._characterJoinerId = (0, t2.enableLigatures)(e3, this._fallbackLigatures);
          }
          dispose() {
            var e3;
            void 0 !== this._characterJoinerId && (null === (e3 = this._terminal) || void 0 === e3 || e3.deregisterCharacterJoiner(this._characterJoinerId), this._characterJoinerId = void 0);
          }
        };
      })(), i;
    })());
  }
});
export default require_addon_ligatures();
/*! Bundled license information:

@xterm/addon-ligatures/lib/addon-ligatures.js:
  (*! For license information please see addon-ligatures.js.LICENSE.txt *)
*/
//# sourceMappingURL=@xterm_addon-ligatures.js.map
